// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"postgresql","activeProvider":"postgresql","url":{"fromEnvVar":"DATABASE_URL","value":""},"config":null}]`

const schema = `datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}

model User {
  id        String    @id @default(cuid())
  email     String    @unique
  username  String    @unique
  password  String
  bio       String
  avatar    String
  firstName String
  lastName  String
  Spiciness Int
  Sweetness Int
  Sourness  Int
  Type      String
  Allergies String
  City      String
  posts     Post[]
  likes     Like[]
  comments  Comment[]
  followers Follows[] @relation("FollowersRelation")
  following Follows[] @relation("FollowingRelation")
  Tag       Tag[]
}

model Post {
  id             String      @id @default(cuid())
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  title          String
  description    String
  longitude      String
  latitude       String
  Cuisine        String
  Dish           String
  Type           String
  Spiciness      Int
  Sweetness      Int
  Sourness       Int
  pictures       String
  userId         String
  city           String
  user           User        @relation(fields: [userId], references: [id])
  likes          Like[]
  comments       Comment[]
  tags           Tag[]
  restaurantId   String? // Optional
  restaurant     Restaurant? @relation(fields: [restaurantId], references: [id])
  originalPost   Post?       @relation("RepostRelation", fields: [originalPostId], references: [id])
  originalPostId String? // For reposts, references the original post
  repostedPosts  Post[]      @relation("RepostRelation")
}

model Comment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  content   String
  postId    String
  post      Post     @relation(fields: [postId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
}

model Like {
  id     String @id @default(cuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id])
  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model Tag {
  id     String @id @default(cuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id])
  userId String
  user   User   @relation(fields: [userId], references: [id])
}

model Follows {
  id          String @id @default(cuid())
  followerId  String
  follower    User   @relation("FollowersRelation", fields: [followerId], references: [id])
  followingId String
  following   User   @relation("FollowingRelation", fields: [followingId], references: [id])
}

model Restaurant {
  id        String   @id @default(cuid())
  name      String
  address   String
  city      String
  state     String
  zipCode   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  posts     Post[]
}
`
const schemaDatasourceURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set" + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}
	c.Post = postActions{client: c}
	c.Comment = commentActions{client: c}
	c.Like = likeActions{client: c}
	c.Tag = tagActions{client: c}
	c.Follows = followsActions{client: c}
	c.Restaurant = restaurantActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
	// Post provides access to CRUD methods.
	Post postActions
	// Comment provides access to CRUD methods.
	Comment commentActions
	// Like provides access to CRUD methods.
	Like likeActions
	// Tag provides access to CRUD methods.
	Tag tagActions
	// Follows provides access to CRUD methods.
	Follows followsActions
	// Restaurant provides access to CRUD methods.
	Restaurant restaurantActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID        UserScalarFieldEnum = "id"
	UserScalarFieldEnumEmail     UserScalarFieldEnum = "email"
	UserScalarFieldEnumUsername  UserScalarFieldEnum = "username"
	UserScalarFieldEnumPassword  UserScalarFieldEnum = "password"
	UserScalarFieldEnumBio       UserScalarFieldEnum = "bio"
	UserScalarFieldEnumAvatar    UserScalarFieldEnum = "avatar"
	UserScalarFieldEnumFirstName UserScalarFieldEnum = "firstName"
	UserScalarFieldEnumLastName  UserScalarFieldEnum = "lastName"
	UserScalarFieldEnumSpiciness UserScalarFieldEnum = "Spiciness"
	UserScalarFieldEnumSweetness UserScalarFieldEnum = "Sweetness"
	UserScalarFieldEnumSourness  UserScalarFieldEnum = "Sourness"
	UserScalarFieldEnumType      UserScalarFieldEnum = "Type"
	UserScalarFieldEnumAllergies UserScalarFieldEnum = "Allergies"
	UserScalarFieldEnumCity      UserScalarFieldEnum = "City"
)

type PostScalarFieldEnum string

const (
	PostScalarFieldEnumID             PostScalarFieldEnum = "id"
	PostScalarFieldEnumCreatedAt      PostScalarFieldEnum = "createdAt"
	PostScalarFieldEnumUpdatedAt      PostScalarFieldEnum = "updatedAt"
	PostScalarFieldEnumTitle          PostScalarFieldEnum = "title"
	PostScalarFieldEnumDescription    PostScalarFieldEnum = "description"
	PostScalarFieldEnumLongitude      PostScalarFieldEnum = "longitude"
	PostScalarFieldEnumLatitude       PostScalarFieldEnum = "latitude"
	PostScalarFieldEnumCuisine        PostScalarFieldEnum = "Cuisine"
	PostScalarFieldEnumDish           PostScalarFieldEnum = "Dish"
	PostScalarFieldEnumType           PostScalarFieldEnum = "Type"
	PostScalarFieldEnumSpiciness      PostScalarFieldEnum = "Spiciness"
	PostScalarFieldEnumSweetness      PostScalarFieldEnum = "Sweetness"
	PostScalarFieldEnumSourness       PostScalarFieldEnum = "Sourness"
	PostScalarFieldEnumPictures       PostScalarFieldEnum = "pictures"
	PostScalarFieldEnumUserID         PostScalarFieldEnum = "userId"
	PostScalarFieldEnumCity           PostScalarFieldEnum = "city"
	PostScalarFieldEnumRestaurantID   PostScalarFieldEnum = "restaurantId"
	PostScalarFieldEnumOriginalPostID PostScalarFieldEnum = "originalPostId"
)

type CommentScalarFieldEnum string

const (
	CommentScalarFieldEnumID        CommentScalarFieldEnum = "id"
	CommentScalarFieldEnumCreatedAt CommentScalarFieldEnum = "createdAt"
	CommentScalarFieldEnumUpdatedAt CommentScalarFieldEnum = "updatedAt"
	CommentScalarFieldEnumContent   CommentScalarFieldEnum = "content"
	CommentScalarFieldEnumPostID    CommentScalarFieldEnum = "postId"
	CommentScalarFieldEnumUserID    CommentScalarFieldEnum = "userId"
)

type LikeScalarFieldEnum string

const (
	LikeScalarFieldEnumID     LikeScalarFieldEnum = "id"
	LikeScalarFieldEnumPostID LikeScalarFieldEnum = "postId"
	LikeScalarFieldEnumUserID LikeScalarFieldEnum = "userId"
)

type TagScalarFieldEnum string

const (
	TagScalarFieldEnumID     TagScalarFieldEnum = "id"
	TagScalarFieldEnumPostID TagScalarFieldEnum = "postId"
	TagScalarFieldEnumUserID TagScalarFieldEnum = "userId"
)

type FollowsScalarFieldEnum string

const (
	FollowsScalarFieldEnumID          FollowsScalarFieldEnum = "id"
	FollowsScalarFieldEnumFollowerID  FollowsScalarFieldEnum = "followerId"
	FollowsScalarFieldEnumFollowingID FollowsScalarFieldEnum = "followingId"
)

type RestaurantScalarFieldEnum string

const (
	RestaurantScalarFieldEnumID        RestaurantScalarFieldEnum = "id"
	RestaurantScalarFieldEnumName      RestaurantScalarFieldEnum = "name"
	RestaurantScalarFieldEnumAddress   RestaurantScalarFieldEnum = "address"
	RestaurantScalarFieldEnumCity      RestaurantScalarFieldEnum = "city"
	RestaurantScalarFieldEnumState     RestaurantScalarFieldEnum = "state"
	RestaurantScalarFieldEnumZipCode   RestaurantScalarFieldEnum = "zipCode"
	RestaurantScalarFieldEnumCreatedAt RestaurantScalarFieldEnum = "createdAt"
	RestaurantScalarFieldEnumUpdatedAt RestaurantScalarFieldEnum = "updatedAt"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type userPrismaFields = prismaFields

const userFieldID userPrismaFields = "id"

const userFieldEmail userPrismaFields = "email"

const userFieldUsername userPrismaFields = "username"

const userFieldPassword userPrismaFields = "password"

const userFieldBio userPrismaFields = "bio"

const userFieldAvatar userPrismaFields = "avatar"

const userFieldFirstName userPrismaFields = "firstName"

const userFieldLastName userPrismaFields = "lastName"

const userFieldSpiciness userPrismaFields = "Spiciness"

const userFieldSweetness userPrismaFields = "Sweetness"

const userFieldSourness userPrismaFields = "Sourness"

const userFieldType userPrismaFields = "Type"

const userFieldAllergies userPrismaFields = "Allergies"

const userFieldCity userPrismaFields = "City"

const userFieldPosts userPrismaFields = "posts"

const userFieldLikes userPrismaFields = "likes"

const userFieldComments userPrismaFields = "comments"

const userFieldFollowers userPrismaFields = "followers"

const userFieldFollowing userPrismaFields = "following"

const userFieldTag userPrismaFields = "Tag"

type postPrismaFields = prismaFields

const postFieldID postPrismaFields = "id"

const postFieldCreatedAt postPrismaFields = "createdAt"

const postFieldUpdatedAt postPrismaFields = "updatedAt"

const postFieldTitle postPrismaFields = "title"

const postFieldDescription postPrismaFields = "description"

const postFieldLongitude postPrismaFields = "longitude"

const postFieldLatitude postPrismaFields = "latitude"

const postFieldCuisine postPrismaFields = "Cuisine"

const postFieldDish postPrismaFields = "Dish"

const postFieldType postPrismaFields = "Type"

const postFieldSpiciness postPrismaFields = "Spiciness"

const postFieldSweetness postPrismaFields = "Sweetness"

const postFieldSourness postPrismaFields = "Sourness"

const postFieldPictures postPrismaFields = "pictures"

const postFieldUserID postPrismaFields = "userId"

const postFieldCity postPrismaFields = "city"

const postFieldUser postPrismaFields = "user"

const postFieldLikes postPrismaFields = "likes"

const postFieldComments postPrismaFields = "comments"

const postFieldTags postPrismaFields = "tags"

const postFieldRestaurantID postPrismaFields = "restaurantId"

const postFieldRestaurant postPrismaFields = "restaurant"

const postFieldOriginalPost postPrismaFields = "originalPost"

const postFieldOriginalPostID postPrismaFields = "originalPostId"

const postFieldRepostedPosts postPrismaFields = "repostedPosts"

type commentPrismaFields = prismaFields

const commentFieldID commentPrismaFields = "id"

const commentFieldCreatedAt commentPrismaFields = "createdAt"

const commentFieldUpdatedAt commentPrismaFields = "updatedAt"

const commentFieldContent commentPrismaFields = "content"

const commentFieldPostID commentPrismaFields = "postId"

const commentFieldPost commentPrismaFields = "post"

const commentFieldUserID commentPrismaFields = "userId"

const commentFieldUser commentPrismaFields = "user"

type likePrismaFields = prismaFields

const likeFieldID likePrismaFields = "id"

const likeFieldPostID likePrismaFields = "postId"

const likeFieldPost likePrismaFields = "post"

const likeFieldUserID likePrismaFields = "userId"

const likeFieldUser likePrismaFields = "user"

type tagPrismaFields = prismaFields

const tagFieldID tagPrismaFields = "id"

const tagFieldPostID tagPrismaFields = "postId"

const tagFieldPost tagPrismaFields = "post"

const tagFieldUserID tagPrismaFields = "userId"

const tagFieldUser tagPrismaFields = "user"

type followsPrismaFields = prismaFields

const followsFieldID followsPrismaFields = "id"

const followsFieldFollowerID followsPrismaFields = "followerId"

const followsFieldFollower followsPrismaFields = "follower"

const followsFieldFollowingID followsPrismaFields = "followingId"

const followsFieldFollowing followsPrismaFields = "following"

type restaurantPrismaFields = prismaFields

const restaurantFieldID restaurantPrismaFields = "id"

const restaurantFieldName restaurantPrismaFields = "name"

const restaurantFieldAddress restaurantPrismaFields = "address"

const restaurantFieldCity restaurantPrismaFields = "city"

const restaurantFieldState restaurantPrismaFields = "state"

const restaurantFieldZipCode restaurantPrismaFields = "zipCode"

const restaurantFieldCreatedAt restaurantPrismaFields = "createdAt"

const restaurantFieldUpdatedAt restaurantPrismaFields = "updatedAt"

const restaurantFieldPosts restaurantPrismaFields = "posts"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	m.Post = postMock{
		mock: m,
	}

	m.Comment = commentMock{
		mock: m,
	}

	m.Like = likeMock{
		mock: m,
	}

	m.Tag = tagMock{
		mock: m,
	}

	m.Follows = followsMock{
		mock: m,
	}

	m.Restaurant = restaurantMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock

	Post postMock

	Comment commentMock

	Like likeMock

	Tag tagMock

	Follows followsMock

	Restaurant restaurantMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type postMock struct {
	mock *Mock
}

type PostMockExpectParam interface {
	ExtractQuery() builder.Query
	postModel()
}

func (m *postMock) Expect(query PostMockExpectParam) *postMockExec {
	return &postMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type postMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *postMockExec) Returns(v PostModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *postMockExec) ReturnsMany(v []PostModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *postMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type commentMock struct {
	mock *Mock
}

type CommentMockExpectParam interface {
	ExtractQuery() builder.Query
	commentModel()
}

func (m *commentMock) Expect(query CommentMockExpectParam) *commentMockExec {
	return &commentMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type commentMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *commentMockExec) Returns(v CommentModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *commentMockExec) ReturnsMany(v []CommentModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *commentMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type likeMock struct {
	mock *Mock
}

type LikeMockExpectParam interface {
	ExtractQuery() builder.Query
	likeModel()
}

func (m *likeMock) Expect(query LikeMockExpectParam) *likeMockExec {
	return &likeMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type likeMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *likeMockExec) Returns(v LikeModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *likeMockExec) ReturnsMany(v []LikeModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *likeMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type tagMock struct {
	mock *Mock
}

type TagMockExpectParam interface {
	ExtractQuery() builder.Query
	tagModel()
}

func (m *tagMock) Expect(query TagMockExpectParam) *tagMockExec {
	return &tagMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type tagMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *tagMockExec) Returns(v TagModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *tagMockExec) ReturnsMany(v []TagModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *tagMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type followsMock struct {
	mock *Mock
}

type FollowsMockExpectParam interface {
	ExtractQuery() builder.Query
	followsModel()
}

func (m *followsMock) Expect(query FollowsMockExpectParam) *followsMockExec {
	return &followsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type followsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *followsMockExec) Returns(v FollowsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *followsMockExec) ReturnsMany(v []FollowsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *followsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type restaurantMock struct {
	mock *Mock
}

type RestaurantMockExpectParam interface {
	ExtractQuery() builder.Query
	restaurantModel()
}

func (m *restaurantMock) Expect(query RestaurantMockExpectParam) *restaurantMockExec {
	return &restaurantMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type restaurantMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *restaurantMockExec) Returns(v RestaurantModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *restaurantMockExec) ReturnsMany(v []RestaurantModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *restaurantMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID        string `json:"id"`
	Email     string `json:"email"`
	Username  string `json:"username"`
	Password  string `json:"password"`
	Bio       string `json:"bio"`
	Avatar    string `json:"avatar"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
	Spiciness int    `json:"Spiciness"`
	Sweetness int    `json:"Sweetness"`
	Sourness  int    `json:"Sourness"`
	Type      string `json:"Type"`
	Allergies string `json:"Allergies"`
	City      string `json:"City"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	ID        RawString `json:"id"`
	Email     RawString `json:"email"`
	Username  RawString `json:"username"`
	Password  RawString `json:"password"`
	Bio       RawString `json:"bio"`
	Avatar    RawString `json:"avatar"`
	FirstName RawString `json:"firstName"`
	LastName  RawString `json:"lastName"`
	Spiciness RawInt    `json:"Spiciness"`
	Sweetness RawInt    `json:"Sweetness"`
	Sourness  RawInt    `json:"Sourness"`
	Type      RawString `json:"Type"`
	Allergies RawString `json:"Allergies"`
	City      RawString `json:"City"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
	Posts     []PostModel    `json:"posts,omitempty"`
	Likes     []LikeModel    `json:"likes,omitempty"`
	Comments  []CommentModel `json:"comments,omitempty"`
	Followers []FollowsModel `json:"followers,omitempty"`
	Following []FollowsModel `json:"following,omitempty"`
	Tag       []TagModel     `json:"Tag,omitempty"`
}

func (r UserModel) Posts() (value []PostModel) {
	if r.RelationsUser.Posts == nil {
		panic("attempted to access posts but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Posts
}

func (r UserModel) Likes() (value []LikeModel) {
	if r.RelationsUser.Likes == nil {
		panic("attempted to access likes but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Likes
}

func (r UserModel) Comments() (value []CommentModel) {
	if r.RelationsUser.Comments == nil {
		panic("attempted to access comments but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Comments
}

func (r UserModel) Followers() (value []FollowsModel) {
	if r.RelationsUser.Followers == nil {
		panic("attempted to access followers but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Followers
}

func (r UserModel) Following() (value []FollowsModel) {
	if r.RelationsUser.Following == nil {
		panic("attempted to access following but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Following
}

func (r UserModel) Tag() (value []TagModel) {
	if r.RelationsUser.Tag == nil {
		panic("attempted to access tag but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Tag
}

// PostModel represents the Post model and is a wrapper for accessing fields and methods
type PostModel struct {
	InnerPost
	RelationsPost
}

// InnerPost holds the actual data
type InnerPost struct {
	ID             string   `json:"id"`
	CreatedAt      DateTime `json:"createdAt"`
	UpdatedAt      DateTime `json:"updatedAt"`
	Title          string   `json:"title"`
	Description    string   `json:"description"`
	Longitude      string   `json:"longitude"`
	Latitude       string   `json:"latitude"`
	Cuisine        string   `json:"Cuisine"`
	Dish           string   `json:"Dish"`
	Type           string   `json:"Type"`
	Spiciness      int      `json:"Spiciness"`
	Sweetness      int      `json:"Sweetness"`
	Sourness       int      `json:"Sourness"`
	Pictures       string   `json:"pictures"`
	UserID         string   `json:"userId"`
	City           string   `json:"city"`
	RestaurantID   *string  `json:"restaurantId,omitempty"`
	OriginalPostID *string  `json:"originalPostId,omitempty"`
}

// RawPostModel is a struct for Post when used in raw queries
type RawPostModel struct {
	ID             RawString   `json:"id"`
	CreatedAt      RawDateTime `json:"createdAt"`
	UpdatedAt      RawDateTime `json:"updatedAt"`
	Title          RawString   `json:"title"`
	Description    RawString   `json:"description"`
	Longitude      RawString   `json:"longitude"`
	Latitude       RawString   `json:"latitude"`
	Cuisine        RawString   `json:"Cuisine"`
	Dish           RawString   `json:"Dish"`
	Type           RawString   `json:"Type"`
	Spiciness      RawInt      `json:"Spiciness"`
	Sweetness      RawInt      `json:"Sweetness"`
	Sourness       RawInt      `json:"Sourness"`
	Pictures       RawString   `json:"pictures"`
	UserID         RawString   `json:"userId"`
	City           RawString   `json:"city"`
	RestaurantID   *RawString  `json:"restaurantId,omitempty"`
	OriginalPostID *RawString  `json:"originalPostId,omitempty"`
}

// RelationsPost holds the relation data separately
type RelationsPost struct {
	User          *UserModel       `json:"user,omitempty"`
	Likes         []LikeModel      `json:"likes,omitempty"`
	Comments      []CommentModel   `json:"comments,omitempty"`
	Tags          []TagModel       `json:"tags,omitempty"`
	Restaurant    *RestaurantModel `json:"restaurant,omitempty"`
	OriginalPost  *PostModel       `json:"originalPost,omitempty"`
	RepostedPosts []PostModel      `json:"repostedPosts,omitempty"`
}

func (r PostModel) User() (value *UserModel) {
	if r.RelationsPost.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsPost.User
}

func (r PostModel) Likes() (value []LikeModel) {
	if r.RelationsPost.Likes == nil {
		panic("attempted to access likes but did not fetch it using the .With() syntax")
	}
	return r.RelationsPost.Likes
}

func (r PostModel) Comments() (value []CommentModel) {
	if r.RelationsPost.Comments == nil {
		panic("attempted to access comments but did not fetch it using the .With() syntax")
	}
	return r.RelationsPost.Comments
}

func (r PostModel) Tags() (value []TagModel) {
	if r.RelationsPost.Tags == nil {
		panic("attempted to access tags but did not fetch it using the .With() syntax")
	}
	return r.RelationsPost.Tags
}

func (r PostModel) RestaurantID() (value String, ok bool) {
	if r.InnerPost.RestaurantID == nil {
		return value, false
	}
	return *r.InnerPost.RestaurantID, true
}

func (r PostModel) Restaurant() (value *RestaurantModel, ok bool) {
	if r.RelationsPost.Restaurant == nil {
		return value, false
	}
	return r.RelationsPost.Restaurant, true
}

func (r PostModel) OriginalPost() (value *PostModel, ok bool) {
	if r.RelationsPost.OriginalPost == nil {
		return value, false
	}
	return r.RelationsPost.OriginalPost, true
}

func (r PostModel) OriginalPostID() (value String, ok bool) {
	if r.InnerPost.OriginalPostID == nil {
		return value, false
	}
	return *r.InnerPost.OriginalPostID, true
}

func (r PostModel) RepostedPosts() (value []PostModel) {
	if r.RelationsPost.RepostedPosts == nil {
		panic("attempted to access repostedPosts but did not fetch it using the .With() syntax")
	}
	return r.RelationsPost.RepostedPosts
}

// CommentModel represents the Comment model and is a wrapper for accessing fields and methods
type CommentModel struct {
	InnerComment
	RelationsComment
}

// InnerComment holds the actual data
type InnerComment struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
	Content   string   `json:"content"`
	PostID    string   `json:"postId"`
	UserID    string   `json:"userId"`
}

// RawCommentModel is a struct for Comment when used in raw queries
type RawCommentModel struct {
	ID        RawString   `json:"id"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
	Content   RawString   `json:"content"`
	PostID    RawString   `json:"postId"`
	UserID    RawString   `json:"userId"`
}

// RelationsComment holds the relation data separately
type RelationsComment struct {
	Post *PostModel `json:"post,omitempty"`
	User *UserModel `json:"user,omitempty"`
}

func (r CommentModel) Post() (value *PostModel) {
	if r.RelationsComment.Post == nil {
		panic("attempted to access post but did not fetch it using the .With() syntax")
	}
	return r.RelationsComment.Post
}

func (r CommentModel) User() (value *UserModel) {
	if r.RelationsComment.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsComment.User
}

// LikeModel represents the Like model and is a wrapper for accessing fields and methods
type LikeModel struct {
	InnerLike
	RelationsLike
}

// InnerLike holds the actual data
type InnerLike struct {
	ID     string `json:"id"`
	PostID string `json:"postId"`
	UserID string `json:"userId"`
}

// RawLikeModel is a struct for Like when used in raw queries
type RawLikeModel struct {
	ID     RawString `json:"id"`
	PostID RawString `json:"postId"`
	UserID RawString `json:"userId"`
}

// RelationsLike holds the relation data separately
type RelationsLike struct {
	Post *PostModel `json:"post,omitempty"`
	User *UserModel `json:"user,omitempty"`
}

func (r LikeModel) Post() (value *PostModel) {
	if r.RelationsLike.Post == nil {
		panic("attempted to access post but did not fetch it using the .With() syntax")
	}
	return r.RelationsLike.Post
}

func (r LikeModel) User() (value *UserModel) {
	if r.RelationsLike.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsLike.User
}

// TagModel represents the Tag model and is a wrapper for accessing fields and methods
type TagModel struct {
	InnerTag
	RelationsTag
}

// InnerTag holds the actual data
type InnerTag struct {
	ID     string `json:"id"`
	PostID string `json:"postId"`
	UserID string `json:"userId"`
}

// RawTagModel is a struct for Tag when used in raw queries
type RawTagModel struct {
	ID     RawString `json:"id"`
	PostID RawString `json:"postId"`
	UserID RawString `json:"userId"`
}

// RelationsTag holds the relation data separately
type RelationsTag struct {
	Post *PostModel `json:"post,omitempty"`
	User *UserModel `json:"user,omitempty"`
}

func (r TagModel) Post() (value *PostModel) {
	if r.RelationsTag.Post == nil {
		panic("attempted to access post but did not fetch it using the .With() syntax")
	}
	return r.RelationsTag.Post
}

func (r TagModel) User() (value *UserModel) {
	if r.RelationsTag.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsTag.User
}

// FollowsModel represents the Follows model and is a wrapper for accessing fields and methods
type FollowsModel struct {
	InnerFollows
	RelationsFollows
}

// InnerFollows holds the actual data
type InnerFollows struct {
	ID          string `json:"id"`
	FollowerID  string `json:"followerId"`
	FollowingID string `json:"followingId"`
}

// RawFollowsModel is a struct for Follows when used in raw queries
type RawFollowsModel struct {
	ID          RawString `json:"id"`
	FollowerID  RawString `json:"followerId"`
	FollowingID RawString `json:"followingId"`
}

// RelationsFollows holds the relation data separately
type RelationsFollows struct {
	Follower  *UserModel `json:"follower,omitempty"`
	Following *UserModel `json:"following,omitempty"`
}

func (r FollowsModel) Follower() (value *UserModel) {
	if r.RelationsFollows.Follower == nil {
		panic("attempted to access follower but did not fetch it using the .With() syntax")
	}
	return r.RelationsFollows.Follower
}

func (r FollowsModel) Following() (value *UserModel) {
	if r.RelationsFollows.Following == nil {
		panic("attempted to access following but did not fetch it using the .With() syntax")
	}
	return r.RelationsFollows.Following
}

// RestaurantModel represents the Restaurant model and is a wrapper for accessing fields and methods
type RestaurantModel struct {
	InnerRestaurant
	RelationsRestaurant
}

// InnerRestaurant holds the actual data
type InnerRestaurant struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Address   string   `json:"address"`
	City      string   `json:"city"`
	State     string   `json:"state"`
	ZipCode   string   `json:"zipCode"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawRestaurantModel is a struct for Restaurant when used in raw queries
type RawRestaurantModel struct {
	ID        RawString   `json:"id"`
	Name      RawString   `json:"name"`
	Address   RawString   `json:"address"`
	City      RawString   `json:"city"`
	State     RawString   `json:"state"`
	ZipCode   RawString   `json:"zipCode"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsRestaurant holds the relation data separately
type RelationsRestaurant struct {
	Posts []PostModel `json:"posts,omitempty"`
}

func (r RestaurantModel) Posts() (value []PostModel) {
	if r.RelationsRestaurant.Posts == nil {
		panic("attempted to access posts but did not fetch it using the .With() syntax")
	}
	return r.RelationsRestaurant.Posts
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDString

	// Email
	//
	// @required
	// @unique
	Email userQueryEmailString

	// Username
	//
	// @required
	// @unique
	Username userQueryUsernameString

	// Password
	//
	// @required
	Password userQueryPasswordString

	// Bio
	//
	// @required
	Bio userQueryBioString

	// Avatar
	//
	// @required
	Avatar userQueryAvatarString

	// FirstName
	//
	// @required
	FirstName userQueryFirstNameString

	// LastName
	//
	// @required
	LastName userQueryLastNameString

	// Spiciness
	//
	// @required
	Spiciness userQuerySpicinessInt

	// Sweetness
	//
	// @required
	Sweetness userQuerySweetnessInt

	// Sourness
	//
	// @required
	Sourness userQuerySournessInt

	// Type
	//
	// @required
	Type userQueryTypeString

	// Allergies
	//
	// @required
	Allergies userQueryAllergiesString

	// City
	//
	// @required
	City userQueryCityString

	Posts userQueryPostsRelations

	Likes userQueryLikesRelations

	Comments userQueryCommentsRelations

	Followers userQueryFollowersRelations

	Following userQueryFollowingRelations

	Tag userQueryTagRelations
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIDString) Equals(value string) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EqualsIfPresent(value *string) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryIDString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryIDString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryIDString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryIDString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryIDString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryIDString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryIDString) Field() userPrismaFields {
	return userFieldID
}

// base struct
type userQueryEmailString struct{}

// Set the required value of Email
func (r userQueryEmailString) Set(value string) userWithPrismaEmailSetParam {

	return userWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r userQueryEmailString) SetIfPresent(value *String) userWithPrismaEmailSetParam {
	if value == nil {
		return userWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryEmailString) Equals(value string) userWithPrismaEmailEqualsUniqueParam {

	return userWithPrismaEmailEqualsUniqueParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EqualsIfPresent(value *string) userWithPrismaEmailEqualsUniqueParam {
	if value == nil {
		return userWithPrismaEmailEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryEmailString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userQueryEmailString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userQueryEmailString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryEmailString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryEmailString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryEmailString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryEmailString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryEmailString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryEmailString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryEmailString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryEmailString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryEmailString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryEmailString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryEmailString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryEmailString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryEmailString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryEmailString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryEmailString) Field() userPrismaFields {
	return userFieldEmail
}

// base struct
type userQueryUsernameString struct{}

// Set the required value of Username
func (r userQueryUsernameString) Set(value string) userWithPrismaUsernameSetParam {

	return userWithPrismaUsernameSetParam{
		data: builder.Field{
			Name:  "username",
			Value: value,
		},
	}

}

// Set the optional value of Username dynamically
func (r userQueryUsernameString) SetIfPresent(value *String) userWithPrismaUsernameSetParam {
	if value == nil {
		return userWithPrismaUsernameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUsernameString) Equals(value string) userWithPrismaUsernameEqualsUniqueParam {

	return userWithPrismaUsernameEqualsUniqueParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) EqualsIfPresent(value *string) userWithPrismaUsernameEqualsUniqueParam {
	if value == nil {
		return userWithPrismaUsernameEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUsernameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "username",
			Value: direction,
		},
	}
}

func (r userQueryUsernameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "username",
			Value: cursor,
		},
	}
}

func (r userQueryUsernameString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryUsernameString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryUsernameString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryUsernameString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryUsernameString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryUsernameString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryUsernameString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryUsernameString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryUsernameString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryUsernameString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryUsernameString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryUsernameString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryUsernameString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryUsernameString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryUsernameString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryUsernameString) Field() userPrismaFields {
	return userFieldUsername
}

// base struct
type userQueryPasswordString struct{}

// Set the required value of Password
func (r userQueryPasswordString) Set(value string) userWithPrismaPasswordSetParam {

	return userWithPrismaPasswordSetParam{
		data: builder.Field{
			Name:  "password",
			Value: value,
		},
	}

}

// Set the optional value of Password dynamically
func (r userQueryPasswordString) SetIfPresent(value *String) userWithPrismaPasswordSetParam {
	if value == nil {
		return userWithPrismaPasswordSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryPasswordString) Equals(value string) userWithPrismaPasswordEqualsParam {

	return userWithPrismaPasswordEqualsParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EqualsIfPresent(value *string) userWithPrismaPasswordEqualsParam {
	if value == nil {
		return userWithPrismaPasswordEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryPasswordString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "password",
			Value: direction,
		},
	}
}

func (r userQueryPasswordString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "password",
			Value: cursor,
		},
	}
}

func (r userQueryPasswordString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryPasswordString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryPasswordString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryPasswordString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryPasswordString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryPasswordString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryPasswordString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryPasswordString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryPasswordString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryPasswordString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryPasswordString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryPasswordString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryPasswordString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryPasswordString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryPasswordString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryPasswordString) Field() userPrismaFields {
	return userFieldPassword
}

// base struct
type userQueryBioString struct{}

// Set the required value of Bio
func (r userQueryBioString) Set(value string) userWithPrismaBioSetParam {

	return userWithPrismaBioSetParam{
		data: builder.Field{
			Name:  "bio",
			Value: value,
		},
	}

}

// Set the optional value of Bio dynamically
func (r userQueryBioString) SetIfPresent(value *String) userWithPrismaBioSetParam {
	if value == nil {
		return userWithPrismaBioSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryBioString) Equals(value string) userWithPrismaBioEqualsParam {

	return userWithPrismaBioEqualsParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) EqualsIfPresent(value *string) userWithPrismaBioEqualsParam {
	if value == nil {
		return userWithPrismaBioEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryBioString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "bio",
			Value: direction,
		},
	}
}

func (r userQueryBioString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "bio",
			Value: cursor,
		},
	}
}

func (r userQueryBioString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryBioString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryBioString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryBioString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryBioString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryBioString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryBioString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryBioString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryBioString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryBioString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryBioString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryBioString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryBioString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryBioString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryBioString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "bio",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryBioString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryBioString) Field() userPrismaFields {
	return userFieldBio
}

// base struct
type userQueryAvatarString struct{}

// Set the required value of Avatar
func (r userQueryAvatarString) Set(value string) userWithPrismaAvatarSetParam {

	return userWithPrismaAvatarSetParam{
		data: builder.Field{
			Name:  "avatar",
			Value: value,
		},
	}

}

// Set the optional value of Avatar dynamically
func (r userQueryAvatarString) SetIfPresent(value *String) userWithPrismaAvatarSetParam {
	if value == nil {
		return userWithPrismaAvatarSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryAvatarString) Equals(value string) userWithPrismaAvatarEqualsParam {

	return userWithPrismaAvatarEqualsParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) EqualsIfPresent(value *string) userWithPrismaAvatarEqualsParam {
	if value == nil {
		return userWithPrismaAvatarEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryAvatarString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "avatar",
			Value: direction,
		},
	}
}

func (r userQueryAvatarString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "avatar",
			Value: cursor,
		},
	}
}

func (r userQueryAvatarString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryAvatarString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryAvatarString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryAvatarString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryAvatarString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryAvatarString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryAvatarString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryAvatarString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryAvatarString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryAvatarString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryAvatarString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryAvatarString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryAvatarString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryAvatarString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryAvatarString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryAvatarString) Field() userPrismaFields {
	return userFieldAvatar
}

// base struct
type userQueryFirstNameString struct{}

// Set the required value of FirstName
func (r userQueryFirstNameString) Set(value string) userWithPrismaFirstNameSetParam {

	return userWithPrismaFirstNameSetParam{
		data: builder.Field{
			Name:  "firstName",
			Value: value,
		},
	}

}

// Set the optional value of FirstName dynamically
func (r userQueryFirstNameString) SetIfPresent(value *String) userWithPrismaFirstNameSetParam {
	if value == nil {
		return userWithPrismaFirstNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryFirstNameString) Equals(value string) userWithPrismaFirstNameEqualsParam {

	return userWithPrismaFirstNameEqualsParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EqualsIfPresent(value *string) userWithPrismaFirstNameEqualsParam {
	if value == nil {
		return userWithPrismaFirstNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryFirstNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "firstName",
			Value: direction,
		},
	}
}

func (r userQueryFirstNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "firstName",
			Value: cursor,
		},
	}
}

func (r userQueryFirstNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryFirstNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryFirstNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryFirstNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryFirstNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryFirstNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryFirstNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryFirstNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryFirstNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryFirstNameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryFirstNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryFirstNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryFirstNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryFirstNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryFirstNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryFirstNameString) Field() userPrismaFields {
	return userFieldFirstName
}

// base struct
type userQueryLastNameString struct{}

// Set the required value of LastName
func (r userQueryLastNameString) Set(value string) userWithPrismaLastNameSetParam {

	return userWithPrismaLastNameSetParam{
		data: builder.Field{
			Name:  "lastName",
			Value: value,
		},
	}

}

// Set the optional value of LastName dynamically
func (r userQueryLastNameString) SetIfPresent(value *String) userWithPrismaLastNameSetParam {
	if value == nil {
		return userWithPrismaLastNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryLastNameString) Equals(value string) userWithPrismaLastNameEqualsParam {

	return userWithPrismaLastNameEqualsParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) EqualsIfPresent(value *string) userWithPrismaLastNameEqualsParam {
	if value == nil {
		return userWithPrismaLastNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryLastNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "lastName",
			Value: direction,
		},
	}
}

func (r userQueryLastNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "lastName",
			Value: cursor,
		},
	}
}

func (r userQueryLastNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryLastNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryLastNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryLastNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryLastNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryLastNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryLastNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryLastNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryLastNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryLastNameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryLastNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryLastNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryLastNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryLastNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryLastNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryLastNameString) Field() userPrismaFields {
	return userFieldLastName
}

// base struct
type userQuerySpicinessInt struct{}

// Set the required value of Spiciness
func (r userQuerySpicinessInt) Set(value int) userWithPrismaSpicinessSetParam {

	return userWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name:  "Spiciness",
			Value: value,
		},
	}

}

// Set the optional value of Spiciness dynamically
func (r userQuerySpicinessInt) SetIfPresent(value *Int) userWithPrismaSpicinessSetParam {
	if value == nil {
		return userWithPrismaSpicinessSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Spiciness
func (r userQuerySpicinessInt) Increment(value int) userWithPrismaSpicinessSetParam {
	return userWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) IncrementIfPresent(value *int) userWithPrismaSpicinessSetParam {
	if value == nil {
		return userWithPrismaSpicinessSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Spiciness
func (r userQuerySpicinessInt) Decrement(value int) userWithPrismaSpicinessSetParam {
	return userWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) DecrementIfPresent(value *int) userWithPrismaSpicinessSetParam {
	if value == nil {
		return userWithPrismaSpicinessSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Spiciness
func (r userQuerySpicinessInt) Multiply(value int) userWithPrismaSpicinessSetParam {
	return userWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) MultiplyIfPresent(value *int) userWithPrismaSpicinessSetParam {
	if value == nil {
		return userWithPrismaSpicinessSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Spiciness
func (r userQuerySpicinessInt) Divide(value int) userWithPrismaSpicinessSetParam {
	return userWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) DivideIfPresent(value *int) userWithPrismaSpicinessSetParam {
	if value == nil {
		return userWithPrismaSpicinessSetParam{}
	}
	return r.Divide(*value)
}

func (r userQuerySpicinessInt) Equals(value int) userWithPrismaSpicinessEqualsParam {

	return userWithPrismaSpicinessEqualsParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) EqualsIfPresent(value *int) userWithPrismaSpicinessEqualsParam {
	if value == nil {
		return userWithPrismaSpicinessEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQuerySpicinessInt) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "Spiciness",
			Value: direction,
		},
	}
}

func (r userQuerySpicinessInt) Cursor(cursor int) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "Spiciness",
			Value: cursor,
		},
	}
}

func (r userQuerySpicinessInt) In(value []int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) InIfPresent(value []int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQuerySpicinessInt) NotIn(value []int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) NotInIfPresent(value []int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQuerySpicinessInt) Lt(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) LtIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQuerySpicinessInt) Lte(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) LteIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQuerySpicinessInt) Gt(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) GtIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQuerySpicinessInt) Gte(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) GteIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQuerySpicinessInt) Not(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySpicinessInt) NotIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQuerySpicinessInt) LT(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQuerySpicinessInt) LTIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r userQuerySpicinessInt) LTE(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQuerySpicinessInt) LTEIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r userQuerySpicinessInt) GT(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQuerySpicinessInt) GTIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r userQuerySpicinessInt) GTE(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQuerySpicinessInt) GTEIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.GTE(*value)
}

func (r userQuerySpicinessInt) Field() userPrismaFields {
	return userFieldSpiciness
}

// base struct
type userQuerySweetnessInt struct{}

// Set the required value of Sweetness
func (r userQuerySweetnessInt) Set(value int) userWithPrismaSweetnessSetParam {

	return userWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name:  "Sweetness",
			Value: value,
		},
	}

}

// Set the optional value of Sweetness dynamically
func (r userQuerySweetnessInt) SetIfPresent(value *Int) userWithPrismaSweetnessSetParam {
	if value == nil {
		return userWithPrismaSweetnessSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Sweetness
func (r userQuerySweetnessInt) Increment(value int) userWithPrismaSweetnessSetParam {
	return userWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) IncrementIfPresent(value *int) userWithPrismaSweetnessSetParam {
	if value == nil {
		return userWithPrismaSweetnessSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Sweetness
func (r userQuerySweetnessInt) Decrement(value int) userWithPrismaSweetnessSetParam {
	return userWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) DecrementIfPresent(value *int) userWithPrismaSweetnessSetParam {
	if value == nil {
		return userWithPrismaSweetnessSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Sweetness
func (r userQuerySweetnessInt) Multiply(value int) userWithPrismaSweetnessSetParam {
	return userWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) MultiplyIfPresent(value *int) userWithPrismaSweetnessSetParam {
	if value == nil {
		return userWithPrismaSweetnessSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Sweetness
func (r userQuerySweetnessInt) Divide(value int) userWithPrismaSweetnessSetParam {
	return userWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) DivideIfPresent(value *int) userWithPrismaSweetnessSetParam {
	if value == nil {
		return userWithPrismaSweetnessSetParam{}
	}
	return r.Divide(*value)
}

func (r userQuerySweetnessInt) Equals(value int) userWithPrismaSweetnessEqualsParam {

	return userWithPrismaSweetnessEqualsParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) EqualsIfPresent(value *int) userWithPrismaSweetnessEqualsParam {
	if value == nil {
		return userWithPrismaSweetnessEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQuerySweetnessInt) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "Sweetness",
			Value: direction,
		},
	}
}

func (r userQuerySweetnessInt) Cursor(cursor int) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "Sweetness",
			Value: cursor,
		},
	}
}

func (r userQuerySweetnessInt) In(value []int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) InIfPresent(value []int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQuerySweetnessInt) NotIn(value []int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) NotInIfPresent(value []int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQuerySweetnessInt) Lt(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) LtIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQuerySweetnessInt) Lte(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) LteIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQuerySweetnessInt) Gt(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) GtIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQuerySweetnessInt) Gte(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) GteIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQuerySweetnessInt) Not(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySweetnessInt) NotIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQuerySweetnessInt) LT(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQuerySweetnessInt) LTIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r userQuerySweetnessInt) LTE(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQuerySweetnessInt) LTEIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r userQuerySweetnessInt) GT(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQuerySweetnessInt) GTIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r userQuerySweetnessInt) GTE(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQuerySweetnessInt) GTEIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.GTE(*value)
}

func (r userQuerySweetnessInt) Field() userPrismaFields {
	return userFieldSweetness
}

// base struct
type userQuerySournessInt struct{}

// Set the required value of Sourness
func (r userQuerySournessInt) Set(value int) userWithPrismaSournessSetParam {

	return userWithPrismaSournessSetParam{
		data: builder.Field{
			Name:  "Sourness",
			Value: value,
		},
	}

}

// Set the optional value of Sourness dynamically
func (r userQuerySournessInt) SetIfPresent(value *Int) userWithPrismaSournessSetParam {
	if value == nil {
		return userWithPrismaSournessSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Sourness
func (r userQuerySournessInt) Increment(value int) userWithPrismaSournessSetParam {
	return userWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) IncrementIfPresent(value *int) userWithPrismaSournessSetParam {
	if value == nil {
		return userWithPrismaSournessSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Sourness
func (r userQuerySournessInt) Decrement(value int) userWithPrismaSournessSetParam {
	return userWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) DecrementIfPresent(value *int) userWithPrismaSournessSetParam {
	if value == nil {
		return userWithPrismaSournessSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Sourness
func (r userQuerySournessInt) Multiply(value int) userWithPrismaSournessSetParam {
	return userWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) MultiplyIfPresent(value *int) userWithPrismaSournessSetParam {
	if value == nil {
		return userWithPrismaSournessSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Sourness
func (r userQuerySournessInt) Divide(value int) userWithPrismaSournessSetParam {
	return userWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) DivideIfPresent(value *int) userWithPrismaSournessSetParam {
	if value == nil {
		return userWithPrismaSournessSetParam{}
	}
	return r.Divide(*value)
}

func (r userQuerySournessInt) Equals(value int) userWithPrismaSournessEqualsParam {

	return userWithPrismaSournessEqualsParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) EqualsIfPresent(value *int) userWithPrismaSournessEqualsParam {
	if value == nil {
		return userWithPrismaSournessEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQuerySournessInt) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "Sourness",
			Value: direction,
		},
	}
}

func (r userQuerySournessInt) Cursor(cursor int) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "Sourness",
			Value: cursor,
		},
	}
}

func (r userQuerySournessInt) In(value []int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) InIfPresent(value []int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQuerySournessInt) NotIn(value []int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) NotInIfPresent(value []int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQuerySournessInt) Lt(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) LtIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQuerySournessInt) Lte(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) LteIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQuerySournessInt) Gt(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) GtIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQuerySournessInt) Gte(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) GteIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQuerySournessInt) Not(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySournessInt) NotIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQuerySournessInt) LT(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQuerySournessInt) LTIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r userQuerySournessInt) LTE(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQuerySournessInt) LTEIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r userQuerySournessInt) GT(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQuerySournessInt) GTIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r userQuerySournessInt) GTE(value int) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQuerySournessInt) GTEIfPresent(value *int) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.GTE(*value)
}

func (r userQuerySournessInt) Field() userPrismaFields {
	return userFieldSourness
}

// base struct
type userQueryTypeString struct{}

// Set the required value of Type
func (r userQueryTypeString) Set(value string) userWithPrismaTypeSetParam {

	return userWithPrismaTypeSetParam{
		data: builder.Field{
			Name:  "Type",
			Value: value,
		},
	}

}

// Set the optional value of Type dynamically
func (r userQueryTypeString) SetIfPresent(value *String) userWithPrismaTypeSetParam {
	if value == nil {
		return userWithPrismaTypeSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryTypeString) Equals(value string) userWithPrismaTypeEqualsParam {

	return userWithPrismaTypeEqualsParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) EqualsIfPresent(value *string) userWithPrismaTypeEqualsParam {
	if value == nil {
		return userWithPrismaTypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryTypeString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "Type",
			Value: direction,
		},
	}
}

func (r userQueryTypeString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "Type",
			Value: cursor,
		},
	}
}

func (r userQueryTypeString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryTypeString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryTypeString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryTypeString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryTypeString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryTypeString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryTypeString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryTypeString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryTypeString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryTypeString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryTypeString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTypeString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryTypeString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryTypeString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryTypeString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryTypeString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryTypeString) Field() userPrismaFields {
	return userFieldType
}

// base struct
type userQueryAllergiesString struct{}

// Set the required value of Allergies
func (r userQueryAllergiesString) Set(value string) userWithPrismaAllergiesSetParam {

	return userWithPrismaAllergiesSetParam{
		data: builder.Field{
			Name:  "Allergies",
			Value: value,
		},
	}

}

// Set the optional value of Allergies dynamically
func (r userQueryAllergiesString) SetIfPresent(value *String) userWithPrismaAllergiesSetParam {
	if value == nil {
		return userWithPrismaAllergiesSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryAllergiesString) Equals(value string) userWithPrismaAllergiesEqualsParam {

	return userWithPrismaAllergiesEqualsParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) EqualsIfPresent(value *string) userWithPrismaAllergiesEqualsParam {
	if value == nil {
		return userWithPrismaAllergiesEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryAllergiesString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "Allergies",
			Value: direction,
		},
	}
}

func (r userQueryAllergiesString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "Allergies",
			Value: cursor,
		},
	}
}

func (r userQueryAllergiesString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryAllergiesString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryAllergiesString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryAllergiesString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryAllergiesString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryAllergiesString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryAllergiesString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryAllergiesString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryAllergiesString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryAllergiesString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryAllergiesString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAllergiesString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryAllergiesString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryAllergiesString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryAllergiesString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "Allergies",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryAllergiesString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryAllergiesString) Field() userPrismaFields {
	return userFieldAllergies
}

// base struct
type userQueryCityString struct{}

// Set the required value of City
func (r userQueryCityString) Set(value string) userWithPrismaCitySetParam {

	return userWithPrismaCitySetParam{
		data: builder.Field{
			Name:  "City",
			Value: value,
		},
	}

}

// Set the optional value of City dynamically
func (r userQueryCityString) SetIfPresent(value *String) userWithPrismaCitySetParam {
	if value == nil {
		return userWithPrismaCitySetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCityString) Equals(value string) userWithPrismaCityEqualsParam {

	return userWithPrismaCityEqualsParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) EqualsIfPresent(value *string) userWithPrismaCityEqualsParam {
	if value == nil {
		return userWithPrismaCityEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCityString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "City",
			Value: direction,
		},
	}
}

func (r userQueryCityString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "City",
			Value: cursor,
		},
	}
}

func (r userQueryCityString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCityString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCityString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCityString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCityString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCityString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCityString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryCityString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryCityString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryCityString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryCityString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCityString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryCityString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryCityString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryCityString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "City",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryCityString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryCityString) Field() userPrismaFields {
	return userFieldCity
}

// base struct
type userQueryPostsPost struct{}

type userQueryPostsRelations struct{}

// User -> Posts
//
// @relation
// @required
func (userQueryPostsRelations) Some(
	params ...PostWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Posts
//
// @relation
// @required
func (userQueryPostsRelations) Every(
	params ...PostWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Posts
//
// @relation
// @required
func (userQueryPostsRelations) None(
	params ...PostWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryPostsRelations) Fetch(

	params ...PostWhereParam,

) userToPostsFindMany {
	var v userToPostsFindMany

	v.query.Operation = "query"
	v.query.Method = "posts"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryPostsRelations) Link(
	params ...PostWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryPostsRelations) Unlink(
	params ...PostWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryPostsPost) Field() userPrismaFields {
	return userFieldPosts
}

// base struct
type userQueryLikesLike struct{}

type userQueryLikesRelations struct{}

// User -> Likes
//
// @relation
// @required
func (userQueryLikesRelations) Some(
	params ...LikeWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Likes
//
// @relation
// @required
func (userQueryLikesRelations) Every(
	params ...LikeWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Likes
//
// @relation
// @required
func (userQueryLikesRelations) None(
	params ...LikeWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryLikesRelations) Fetch(

	params ...LikeWhereParam,

) userToLikesFindMany {
	var v userToLikesFindMany

	v.query.Operation = "query"
	v.query.Method = "likes"
	v.query.Outputs = likeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryLikesRelations) Link(
	params ...LikeWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryLikesRelations) Unlink(
	params ...LikeWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryLikesLike) Field() userPrismaFields {
	return userFieldLikes
}

// base struct
type userQueryCommentsComment struct{}

type userQueryCommentsRelations struct{}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) Some(
	params ...CommentWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) Every(
	params ...CommentWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) None(
	params ...CommentWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryCommentsRelations) Fetch(

	params ...CommentWhereParam,

) userToCommentsFindMany {
	var v userToCommentsFindMany

	v.query.Operation = "query"
	v.query.Method = "comments"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryCommentsRelations) Link(
	params ...CommentWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryCommentsRelations) Unlink(
	params ...CommentWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryCommentsComment) Field() userPrismaFields {
	return userFieldComments
}

// base struct
type userQueryFollowersFollows struct{}

type userQueryFollowersRelations struct{}

// User -> Followers
//
// @relation
// @required
func (userQueryFollowersRelations) Some(
	params ...FollowsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "followers",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Followers
//
// @relation
// @required
func (userQueryFollowersRelations) Every(
	params ...FollowsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "followers",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Followers
//
// @relation
// @required
func (userQueryFollowersRelations) None(
	params ...FollowsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "followers",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryFollowersRelations) Fetch(

	params ...FollowsWhereParam,

) userToFollowersFindMany {
	var v userToFollowersFindMany

	v.query.Operation = "query"
	v.query.Method = "followers"
	v.query.Outputs = followsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryFollowersRelations) Link(
	params ...FollowsWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "followers",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryFollowersRelations) Unlink(
	params ...FollowsWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "followers",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryFollowersFollows) Field() userPrismaFields {
	return userFieldFollowers
}

// base struct
type userQueryFollowingFollows struct{}

type userQueryFollowingRelations struct{}

// User -> Following
//
// @relation
// @required
func (userQueryFollowingRelations) Some(
	params ...FollowsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Following
//
// @relation
// @required
func (userQueryFollowingRelations) Every(
	params ...FollowsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Following
//
// @relation
// @required
func (userQueryFollowingRelations) None(
	params ...FollowsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryFollowingRelations) Fetch(

	params ...FollowsWhereParam,

) userToFollowingFindMany {
	var v userToFollowingFindMany

	v.query.Operation = "query"
	v.query.Method = "following"
	v.query.Outputs = followsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryFollowingRelations) Link(
	params ...FollowsWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryFollowingRelations) Unlink(
	params ...FollowsWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryFollowingFollows) Field() userPrismaFields {
	return userFieldFollowing
}

// base struct
type userQueryTagTag struct{}

type userQueryTagRelations struct{}

// User -> Tag
//
// @relation
// @required
func (userQueryTagRelations) Some(
	params ...TagWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Tag",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Tag
//
// @relation
// @required
func (userQueryTagRelations) Every(
	params ...TagWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Tag",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Tag
//
// @relation
// @required
func (userQueryTagRelations) None(
	params ...TagWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Tag",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryTagRelations) Fetch(

	params ...TagWhereParam,

) userToTagFindMany {
	var v userToTagFindMany

	v.query.Operation = "query"
	v.query.Method = "Tag"
	v.query.Outputs = tagOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryTagRelations) Link(
	params ...TagWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "Tag",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryTagRelations) Unlink(
	params ...TagWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "Tag",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryTagTag) Field() userPrismaFields {
	return userFieldTag
}

// Post acts as a namespaces to access query methods for the Post model
var Post = postQuery{}

// postQuery exposes query functions for the post model
type postQuery struct {

	// ID
	//
	// @required
	ID postQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt postQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt postQueryUpdatedAtDateTime

	// Title
	//
	// @required
	Title postQueryTitleString

	// Description
	//
	// @required
	Description postQueryDescriptionString

	// Longitude
	//
	// @required
	Longitude postQueryLongitudeString

	// Latitude
	//
	// @required
	Latitude postQueryLatitudeString

	// Cuisine
	//
	// @required
	Cuisine postQueryCuisineString

	// Dish
	//
	// @required
	Dish postQueryDishString

	// Type
	//
	// @required
	Type postQueryTypeString

	// Spiciness
	//
	// @required
	Spiciness postQuerySpicinessInt

	// Sweetness
	//
	// @required
	Sweetness postQuerySweetnessInt

	// Sourness
	//
	// @required
	Sourness postQuerySournessInt

	// Pictures
	//
	// @required
	Pictures postQueryPicturesString

	// UserID
	//
	// @required
	UserID postQueryUserIDString

	// City
	//
	// @required
	City postQueryCityString

	User postQueryUserRelations

	Likes postQueryLikesRelations

	Comments postQueryCommentsRelations

	Tags postQueryTagsRelations

	// RestaurantID
	//
	// @optional
	RestaurantID postQueryRestaurantIDString

	Restaurant postQueryRestaurantRelations

	OriginalPost postQueryOriginalPostRelations

	// OriginalPostID
	//
	// @optional
	OriginalPostID postQueryOriginalPostIDString

	RepostedPosts postQueryRepostedPostsRelations
}

func (postQuery) Not(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (postQuery) Or(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (postQuery) And(params ...PostWhereParam) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type postQueryIDString struct{}

// Set the required value of ID
func (r postQueryIDString) Set(value string) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r postQueryIDString) SetIfPresent(value *String) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryIDString) Equals(value string) postWithPrismaIDEqualsUniqueParam {

	return postWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) EqualsIfPresent(value *string) postWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return postWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r postQueryIDString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r postQueryIDString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r postQueryIDString) In(value []string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) InIfPresent(value []string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.In(value)
}

func (r postQueryIDString) NotIn(value []string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) NotInIfPresent(value []string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.NotIn(value)
}

func (r postQueryIDString) Lt(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) LtIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Lt(*value)
}

func (r postQueryIDString) Lte(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) LteIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Lte(*value)
}

func (r postQueryIDString) Gt(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) GtIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Gt(*value)
}

func (r postQueryIDString) Gte(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) GteIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Gte(*value)
}

func (r postQueryIDString) Contains(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) ContainsIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Contains(*value)
}

func (r postQueryIDString) StartsWith(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) StartsWithIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r postQueryIDString) EndsWith(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) EndsWithIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r postQueryIDString) Mode(value QueryMode) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) ModeIfPresent(value *QueryMode) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Mode(*value)
}

func (r postQueryIDString) Not(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryIDString) NotIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryIDString) HasPrefix(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryIDString) HasPrefixIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryIDString) HasSuffix(value string) postParamUnique {
	return postParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryIDString) HasSuffixIfPresent(value *string) postParamUnique {
	if value == nil {
		return postParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryIDString) Field() postPrismaFields {
	return postFieldID
}

// base struct
type postQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r postQueryCreatedAtDateTime) Set(value DateTime) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r postQueryCreatedAtDateTime) SetIfPresent(value *DateTime) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryCreatedAtDateTime) Equals(value DateTime) postWithPrismaCreatedAtEqualsParam {

	return postWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) postWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return postWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryCreatedAtDateTime) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r postQueryCreatedAtDateTime) Cursor(cursor DateTime) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r postQueryCreatedAtDateTime) In(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) InIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryCreatedAtDateTime) NotIn(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryCreatedAtDateTime) Lt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) LtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryCreatedAtDateTime) Lte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) LteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryCreatedAtDateTime) Gt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) GtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryCreatedAtDateTime) Gte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) GteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryCreatedAtDateTime) Not(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCreatedAtDateTime) NotIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQueryCreatedAtDateTime) Before(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r postQueryCreatedAtDateTime) After(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r postQueryCreatedAtDateTime) BeforeEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r postQueryCreatedAtDateTime) AfterEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r postQueryCreatedAtDateTime) Field() postPrismaFields {
	return postFieldCreatedAt
}

// base struct
type postQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r postQueryUpdatedAtDateTime) Set(value DateTime) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r postQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryUpdatedAtDateTime) Equals(value DateTime) postWithPrismaUpdatedAtEqualsParam {

	return postWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) postWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return postWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryUpdatedAtDateTime) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r postQueryUpdatedAtDateTime) Cursor(cursor DateTime) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r postQueryUpdatedAtDateTime) In(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) InIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryUpdatedAtDateTime) NotIn(value []DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryUpdatedAtDateTime) Lt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryUpdatedAtDateTime) Lte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryUpdatedAtDateTime) Gt(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryUpdatedAtDateTime) Gte(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryUpdatedAtDateTime) Not(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQueryUpdatedAtDateTime) Before(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r postQueryUpdatedAtDateTime) After(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r postQueryUpdatedAtDateTime) BeforeEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r postQueryUpdatedAtDateTime) AfterEquals(value DateTime) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r postQueryUpdatedAtDateTime) Field() postPrismaFields {
	return postFieldUpdatedAt
}

// base struct
type postQueryTitleString struct{}

// Set the required value of Title
func (r postQueryTitleString) Set(value string) postWithPrismaTitleSetParam {

	return postWithPrismaTitleSetParam{
		data: builder.Field{
			Name:  "title",
			Value: value,
		},
	}

}

// Set the optional value of Title dynamically
func (r postQueryTitleString) SetIfPresent(value *String) postWithPrismaTitleSetParam {
	if value == nil {
		return postWithPrismaTitleSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryTitleString) Equals(value string) postWithPrismaTitleEqualsParam {

	return postWithPrismaTitleEqualsParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) EqualsIfPresent(value *string) postWithPrismaTitleEqualsParam {
	if value == nil {
		return postWithPrismaTitleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryTitleString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "title",
			Value: direction,
		},
	}
}

func (r postQueryTitleString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "title",
			Value: cursor,
		},
	}
}

func (r postQueryTitleString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryTitleString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryTitleString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryTitleString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryTitleString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryTitleString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryTitleString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryTitleString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryTitleString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryTitleString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryTitleString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTitleString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryTitleString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryTitleString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryTitleString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryTitleString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryTitleString) Field() postPrismaFields {
	return postFieldTitle
}

// base struct
type postQueryDescriptionString struct{}

// Set the required value of Description
func (r postQueryDescriptionString) Set(value string) postWithPrismaDescriptionSetParam {

	return postWithPrismaDescriptionSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r postQueryDescriptionString) SetIfPresent(value *String) postWithPrismaDescriptionSetParam {
	if value == nil {
		return postWithPrismaDescriptionSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryDescriptionString) Equals(value string) postWithPrismaDescriptionEqualsParam {

	return postWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) EqualsIfPresent(value *string) postWithPrismaDescriptionEqualsParam {
	if value == nil {
		return postWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryDescriptionString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r postQueryDescriptionString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r postQueryDescriptionString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryDescriptionString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryDescriptionString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryDescriptionString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryDescriptionString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryDescriptionString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryDescriptionString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryDescriptionString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryDescriptionString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryDescriptionString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryDescriptionString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDescriptionString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryDescriptionString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryDescriptionString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryDescriptionString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryDescriptionString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryDescriptionString) Field() postPrismaFields {
	return postFieldDescription
}

// base struct
type postQueryLongitudeString struct{}

// Set the required value of Longitude
func (r postQueryLongitudeString) Set(value string) postWithPrismaLongitudeSetParam {

	return postWithPrismaLongitudeSetParam{
		data: builder.Field{
			Name:  "longitude",
			Value: value,
		},
	}

}

// Set the optional value of Longitude dynamically
func (r postQueryLongitudeString) SetIfPresent(value *String) postWithPrismaLongitudeSetParam {
	if value == nil {
		return postWithPrismaLongitudeSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryLongitudeString) Equals(value string) postWithPrismaLongitudeEqualsParam {

	return postWithPrismaLongitudeEqualsParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) EqualsIfPresent(value *string) postWithPrismaLongitudeEqualsParam {
	if value == nil {
		return postWithPrismaLongitudeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryLongitudeString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "longitude",
			Value: direction,
		},
	}
}

func (r postQueryLongitudeString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "longitude",
			Value: cursor,
		},
	}
}

func (r postQueryLongitudeString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryLongitudeString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryLongitudeString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryLongitudeString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryLongitudeString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryLongitudeString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryLongitudeString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryLongitudeString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryLongitudeString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryLongitudeString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryLongitudeString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLongitudeString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryLongitudeString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryLongitudeString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryLongitudeString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "longitude",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryLongitudeString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryLongitudeString) Field() postPrismaFields {
	return postFieldLongitude
}

// base struct
type postQueryLatitudeString struct{}

// Set the required value of Latitude
func (r postQueryLatitudeString) Set(value string) postWithPrismaLatitudeSetParam {

	return postWithPrismaLatitudeSetParam{
		data: builder.Field{
			Name:  "latitude",
			Value: value,
		},
	}

}

// Set the optional value of Latitude dynamically
func (r postQueryLatitudeString) SetIfPresent(value *String) postWithPrismaLatitudeSetParam {
	if value == nil {
		return postWithPrismaLatitudeSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryLatitudeString) Equals(value string) postWithPrismaLatitudeEqualsParam {

	return postWithPrismaLatitudeEqualsParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) EqualsIfPresent(value *string) postWithPrismaLatitudeEqualsParam {
	if value == nil {
		return postWithPrismaLatitudeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryLatitudeString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "latitude",
			Value: direction,
		},
	}
}

func (r postQueryLatitudeString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "latitude",
			Value: cursor,
		},
	}
}

func (r postQueryLatitudeString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryLatitudeString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryLatitudeString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryLatitudeString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryLatitudeString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryLatitudeString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryLatitudeString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryLatitudeString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryLatitudeString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryLatitudeString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryLatitudeString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryLatitudeString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryLatitudeString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryLatitudeString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryLatitudeString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "latitude",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryLatitudeString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryLatitudeString) Field() postPrismaFields {
	return postFieldLatitude
}

// base struct
type postQueryCuisineString struct{}

// Set the required value of Cuisine
func (r postQueryCuisineString) Set(value string) postWithPrismaCuisineSetParam {

	return postWithPrismaCuisineSetParam{
		data: builder.Field{
			Name:  "Cuisine",
			Value: value,
		},
	}

}

// Set the optional value of Cuisine dynamically
func (r postQueryCuisineString) SetIfPresent(value *String) postWithPrismaCuisineSetParam {
	if value == nil {
		return postWithPrismaCuisineSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryCuisineString) Equals(value string) postWithPrismaCuisineEqualsParam {

	return postWithPrismaCuisineEqualsParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) EqualsIfPresent(value *string) postWithPrismaCuisineEqualsParam {
	if value == nil {
		return postWithPrismaCuisineEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryCuisineString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "Cuisine",
			Value: direction,
		},
	}
}

func (r postQueryCuisineString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "Cuisine",
			Value: cursor,
		},
	}
}

func (r postQueryCuisineString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryCuisineString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryCuisineString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryCuisineString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryCuisineString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryCuisineString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryCuisineString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryCuisineString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryCuisineString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryCuisineString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryCuisineString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCuisineString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryCuisineString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryCuisineString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryCuisineString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Cuisine",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryCuisineString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryCuisineString) Field() postPrismaFields {
	return postFieldCuisine
}

// base struct
type postQueryDishString struct{}

// Set the required value of Dish
func (r postQueryDishString) Set(value string) postWithPrismaDishSetParam {

	return postWithPrismaDishSetParam{
		data: builder.Field{
			Name:  "Dish",
			Value: value,
		},
	}

}

// Set the optional value of Dish dynamically
func (r postQueryDishString) SetIfPresent(value *String) postWithPrismaDishSetParam {
	if value == nil {
		return postWithPrismaDishSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryDishString) Equals(value string) postWithPrismaDishEqualsParam {

	return postWithPrismaDishEqualsParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) EqualsIfPresent(value *string) postWithPrismaDishEqualsParam {
	if value == nil {
		return postWithPrismaDishEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryDishString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "Dish",
			Value: direction,
		},
	}
}

func (r postQueryDishString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "Dish",
			Value: cursor,
		},
	}
}

func (r postQueryDishString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryDishString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryDishString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryDishString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryDishString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryDishString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryDishString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryDishString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryDishString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryDishString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryDishString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryDishString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryDishString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryDishString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryDishString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Dish",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryDishString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryDishString) Field() postPrismaFields {
	return postFieldDish
}

// base struct
type postQueryTypeString struct{}

// Set the required value of Type
func (r postQueryTypeString) Set(value string) postWithPrismaTypeSetParam {

	return postWithPrismaTypeSetParam{
		data: builder.Field{
			Name:  "Type",
			Value: value,
		},
	}

}

// Set the optional value of Type dynamically
func (r postQueryTypeString) SetIfPresent(value *String) postWithPrismaTypeSetParam {
	if value == nil {
		return postWithPrismaTypeSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryTypeString) Equals(value string) postWithPrismaTypeEqualsParam {

	return postWithPrismaTypeEqualsParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) EqualsIfPresent(value *string) postWithPrismaTypeEqualsParam {
	if value == nil {
		return postWithPrismaTypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryTypeString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "Type",
			Value: direction,
		},
	}
}

func (r postQueryTypeString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "Type",
			Value: cursor,
		},
	}
}

func (r postQueryTypeString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryTypeString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryTypeString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryTypeString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryTypeString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryTypeString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryTypeString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryTypeString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryTypeString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryTypeString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryTypeString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryTypeString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryTypeString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryTypeString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryTypeString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Type",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryTypeString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryTypeString) Field() postPrismaFields {
	return postFieldType
}

// base struct
type postQuerySpicinessInt struct{}

// Set the required value of Spiciness
func (r postQuerySpicinessInt) Set(value int) postWithPrismaSpicinessSetParam {

	return postWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name:  "Spiciness",
			Value: value,
		},
	}

}

// Set the optional value of Spiciness dynamically
func (r postQuerySpicinessInt) SetIfPresent(value *Int) postWithPrismaSpicinessSetParam {
	if value == nil {
		return postWithPrismaSpicinessSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Spiciness
func (r postQuerySpicinessInt) Increment(value int) postWithPrismaSpicinessSetParam {
	return postWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) IncrementIfPresent(value *int) postWithPrismaSpicinessSetParam {
	if value == nil {
		return postWithPrismaSpicinessSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Spiciness
func (r postQuerySpicinessInt) Decrement(value int) postWithPrismaSpicinessSetParam {
	return postWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) DecrementIfPresent(value *int) postWithPrismaSpicinessSetParam {
	if value == nil {
		return postWithPrismaSpicinessSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Spiciness
func (r postQuerySpicinessInt) Multiply(value int) postWithPrismaSpicinessSetParam {
	return postWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) MultiplyIfPresent(value *int) postWithPrismaSpicinessSetParam {
	if value == nil {
		return postWithPrismaSpicinessSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Spiciness
func (r postQuerySpicinessInt) Divide(value int) postWithPrismaSpicinessSetParam {
	return postWithPrismaSpicinessSetParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) DivideIfPresent(value *int) postWithPrismaSpicinessSetParam {
	if value == nil {
		return postWithPrismaSpicinessSetParam{}
	}
	return r.Divide(*value)
}

func (r postQuerySpicinessInt) Equals(value int) postWithPrismaSpicinessEqualsParam {

	return postWithPrismaSpicinessEqualsParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) EqualsIfPresent(value *int) postWithPrismaSpicinessEqualsParam {
	if value == nil {
		return postWithPrismaSpicinessEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQuerySpicinessInt) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "Spiciness",
			Value: direction,
		},
	}
}

func (r postQuerySpicinessInt) Cursor(cursor int) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "Spiciness",
			Value: cursor,
		},
	}
}

func (r postQuerySpicinessInt) In(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) InIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQuerySpicinessInt) NotIn(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) NotInIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQuerySpicinessInt) Lt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) LtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQuerySpicinessInt) Lte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) LteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQuerySpicinessInt) Gt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) GtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQuerySpicinessInt) Gte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) GteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQuerySpicinessInt) Not(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySpicinessInt) NotIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQuerySpicinessInt) LT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQuerySpicinessInt) LTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r postQuerySpicinessInt) LTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQuerySpicinessInt) LTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r postQuerySpicinessInt) GT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQuerySpicinessInt) GTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r postQuerySpicinessInt) GTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Spiciness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQuerySpicinessInt) GTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GTE(*value)
}

func (r postQuerySpicinessInt) Field() postPrismaFields {
	return postFieldSpiciness
}

// base struct
type postQuerySweetnessInt struct{}

// Set the required value of Sweetness
func (r postQuerySweetnessInt) Set(value int) postWithPrismaSweetnessSetParam {

	return postWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name:  "Sweetness",
			Value: value,
		},
	}

}

// Set the optional value of Sweetness dynamically
func (r postQuerySweetnessInt) SetIfPresent(value *Int) postWithPrismaSweetnessSetParam {
	if value == nil {
		return postWithPrismaSweetnessSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Sweetness
func (r postQuerySweetnessInt) Increment(value int) postWithPrismaSweetnessSetParam {
	return postWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) IncrementIfPresent(value *int) postWithPrismaSweetnessSetParam {
	if value == nil {
		return postWithPrismaSweetnessSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Sweetness
func (r postQuerySweetnessInt) Decrement(value int) postWithPrismaSweetnessSetParam {
	return postWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) DecrementIfPresent(value *int) postWithPrismaSweetnessSetParam {
	if value == nil {
		return postWithPrismaSweetnessSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Sweetness
func (r postQuerySweetnessInt) Multiply(value int) postWithPrismaSweetnessSetParam {
	return postWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) MultiplyIfPresent(value *int) postWithPrismaSweetnessSetParam {
	if value == nil {
		return postWithPrismaSweetnessSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Sweetness
func (r postQuerySweetnessInt) Divide(value int) postWithPrismaSweetnessSetParam {
	return postWithPrismaSweetnessSetParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) DivideIfPresent(value *int) postWithPrismaSweetnessSetParam {
	if value == nil {
		return postWithPrismaSweetnessSetParam{}
	}
	return r.Divide(*value)
}

func (r postQuerySweetnessInt) Equals(value int) postWithPrismaSweetnessEqualsParam {

	return postWithPrismaSweetnessEqualsParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) EqualsIfPresent(value *int) postWithPrismaSweetnessEqualsParam {
	if value == nil {
		return postWithPrismaSweetnessEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQuerySweetnessInt) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "Sweetness",
			Value: direction,
		},
	}
}

func (r postQuerySweetnessInt) Cursor(cursor int) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "Sweetness",
			Value: cursor,
		},
	}
}

func (r postQuerySweetnessInt) In(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) InIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQuerySweetnessInt) NotIn(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) NotInIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQuerySweetnessInt) Lt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) LtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQuerySweetnessInt) Lte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) LteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQuerySweetnessInt) Gt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) GtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQuerySweetnessInt) Gte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) GteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQuerySweetnessInt) Not(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySweetnessInt) NotIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQuerySweetnessInt) LT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQuerySweetnessInt) LTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r postQuerySweetnessInt) LTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQuerySweetnessInt) LTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r postQuerySweetnessInt) GT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQuerySweetnessInt) GTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r postQuerySweetnessInt) GTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sweetness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQuerySweetnessInt) GTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GTE(*value)
}

func (r postQuerySweetnessInt) Field() postPrismaFields {
	return postFieldSweetness
}

// base struct
type postQuerySournessInt struct{}

// Set the required value of Sourness
func (r postQuerySournessInt) Set(value int) postWithPrismaSournessSetParam {

	return postWithPrismaSournessSetParam{
		data: builder.Field{
			Name:  "Sourness",
			Value: value,
		},
	}

}

// Set the optional value of Sourness dynamically
func (r postQuerySournessInt) SetIfPresent(value *Int) postWithPrismaSournessSetParam {
	if value == nil {
		return postWithPrismaSournessSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Sourness
func (r postQuerySournessInt) Increment(value int) postWithPrismaSournessSetParam {
	return postWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) IncrementIfPresent(value *int) postWithPrismaSournessSetParam {
	if value == nil {
		return postWithPrismaSournessSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Sourness
func (r postQuerySournessInt) Decrement(value int) postWithPrismaSournessSetParam {
	return postWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) DecrementIfPresent(value *int) postWithPrismaSournessSetParam {
	if value == nil {
		return postWithPrismaSournessSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Sourness
func (r postQuerySournessInt) Multiply(value int) postWithPrismaSournessSetParam {
	return postWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) MultiplyIfPresent(value *int) postWithPrismaSournessSetParam {
	if value == nil {
		return postWithPrismaSournessSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Sourness
func (r postQuerySournessInt) Divide(value int) postWithPrismaSournessSetParam {
	return postWithPrismaSournessSetParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) DivideIfPresent(value *int) postWithPrismaSournessSetParam {
	if value == nil {
		return postWithPrismaSournessSetParam{}
	}
	return r.Divide(*value)
}

func (r postQuerySournessInt) Equals(value int) postWithPrismaSournessEqualsParam {

	return postWithPrismaSournessEqualsParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) EqualsIfPresent(value *int) postWithPrismaSournessEqualsParam {
	if value == nil {
		return postWithPrismaSournessEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQuerySournessInt) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "Sourness",
			Value: direction,
		},
	}
}

func (r postQuerySournessInt) Cursor(cursor int) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "Sourness",
			Value: cursor,
		},
	}
}

func (r postQuerySournessInt) In(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) InIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQuerySournessInt) NotIn(value []int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) NotInIfPresent(value []int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQuerySournessInt) Lt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) LtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQuerySournessInt) Lte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) LteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQuerySournessInt) Gt(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) GtIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQuerySournessInt) Gte(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) GteIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQuerySournessInt) Not(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQuerySournessInt) NotIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r postQuerySournessInt) LT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r postQuerySournessInt) LTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r postQuerySournessInt) LTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r postQuerySournessInt) LTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r postQuerySournessInt) GT(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r postQuerySournessInt) GTIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r postQuerySournessInt) GTE(value int) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "Sourness",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r postQuerySournessInt) GTEIfPresent(value *int) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.GTE(*value)
}

func (r postQuerySournessInt) Field() postPrismaFields {
	return postFieldSourness
}

// base struct
type postQueryPicturesString struct{}

// Set the required value of Pictures
func (r postQueryPicturesString) Set(value string) postWithPrismaPicturesSetParam {

	return postWithPrismaPicturesSetParam{
		data: builder.Field{
			Name:  "pictures",
			Value: value,
		},
	}

}

// Set the optional value of Pictures dynamically
func (r postQueryPicturesString) SetIfPresent(value *String) postWithPrismaPicturesSetParam {
	if value == nil {
		return postWithPrismaPicturesSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryPicturesString) Equals(value string) postWithPrismaPicturesEqualsParam {

	return postWithPrismaPicturesEqualsParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) EqualsIfPresent(value *string) postWithPrismaPicturesEqualsParam {
	if value == nil {
		return postWithPrismaPicturesEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryPicturesString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "pictures",
			Value: direction,
		},
	}
}

func (r postQueryPicturesString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "pictures",
			Value: cursor,
		},
	}
}

func (r postQueryPicturesString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryPicturesString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryPicturesString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryPicturesString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryPicturesString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryPicturesString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryPicturesString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryPicturesString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryPicturesString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryPicturesString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryPicturesString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryPicturesString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryPicturesString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryPicturesString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryPicturesString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "pictures",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryPicturesString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryPicturesString) Field() postPrismaFields {
	return postFieldPictures
}

// base struct
type postQueryUserIDString struct{}

// Set the required value of UserID
func (r postQueryUserIDString) Set(value string) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r postQueryUserIDString) SetIfPresent(value *String) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

func (r postQueryUserIDString) Equals(value string) postWithPrismaUserIDEqualsParam {

	return postWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) EqualsIfPresent(value *string) postWithPrismaUserIDEqualsParam {
	if value == nil {
		return postWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryUserIDString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r postQueryUserIDString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r postQueryUserIDString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryUserIDString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryUserIDString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryUserIDString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryUserIDString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryUserIDString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryUserIDString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryUserIDString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryUserIDString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryUserIDString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryUserIDString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryUserIDString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryUserIDString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryUserIDString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryUserIDString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryUserIDString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryUserIDString) Field() postPrismaFields {
	return postFieldUserID
}

// base struct
type postQueryCityString struct{}

// Set the required value of City
func (r postQueryCityString) Set(value string) postWithPrismaCitySetParam {

	return postWithPrismaCitySetParam{
		data: builder.Field{
			Name:  "city",
			Value: value,
		},
	}

}

// Set the optional value of City dynamically
func (r postQueryCityString) SetIfPresent(value *String) postWithPrismaCitySetParam {
	if value == nil {
		return postWithPrismaCitySetParam{}
	}

	return r.Set(*value)
}

func (r postQueryCityString) Equals(value string) postWithPrismaCityEqualsParam {

	return postWithPrismaCityEqualsParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) EqualsIfPresent(value *string) postWithPrismaCityEqualsParam {
	if value == nil {
		return postWithPrismaCityEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryCityString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "city",
			Value: direction,
		},
	}
}

func (r postQueryCityString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "city",
			Value: cursor,
		},
	}
}

func (r postQueryCityString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryCityString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryCityString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryCityString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryCityString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryCityString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryCityString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryCityString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryCityString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryCityString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryCityString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryCityString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryCityString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryCityString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryCityString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryCityString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryCityString) Field() postPrismaFields {
	return postFieldCity
}

// base struct
type postQueryUserUser struct{}

type postQueryUserRelations struct{}

// Post -> User
//
// @relation
// @required
func (postQueryUserRelations) Where(
	params ...UserWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryUserRelations) Fetch() postToUserFindUnique {
	var v postToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r postQueryUserRelations) Link(
	params UserWhereParam,
) postWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return postWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return postWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r postQueryUserRelations) Unlink() postWithPrismaUserSetParam {
	var v postWithPrismaUserSetParam

	v = postWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r postQueryUserUser) Field() postPrismaFields {
	return postFieldUser
}

// base struct
type postQueryLikesLike struct{}

type postQueryLikesRelations struct{}

// Post -> Likes
//
// @relation
// @required
func (postQueryLikesRelations) Some(
	params ...LikeWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Likes
//
// @relation
// @required
func (postQueryLikesRelations) Every(
	params ...LikeWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Likes
//
// @relation
// @required
func (postQueryLikesRelations) None(
	params ...LikeWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryLikesRelations) Fetch(

	params ...LikeWhereParam,

) postToLikesFindMany {
	var v postToLikesFindMany

	v.query.Operation = "query"
	v.query.Method = "likes"
	v.query.Outputs = likeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postQueryLikesRelations) Link(
	params ...LikeWhereParam,
) postSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r postQueryLikesRelations) Unlink(
	params ...LikeWhereParam,
) postSetParam {
	var v postSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = postSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r postQueryLikesLike) Field() postPrismaFields {
	return postFieldLikes
}

// base struct
type postQueryCommentsComment struct{}

type postQueryCommentsRelations struct{}

// Post -> Comments
//
// @relation
// @required
func (postQueryCommentsRelations) Some(
	params ...CommentWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Comments
//
// @relation
// @required
func (postQueryCommentsRelations) Every(
	params ...CommentWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Comments
//
// @relation
// @required
func (postQueryCommentsRelations) None(
	params ...CommentWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryCommentsRelations) Fetch(

	params ...CommentWhereParam,

) postToCommentsFindMany {
	var v postToCommentsFindMany

	v.query.Operation = "query"
	v.query.Method = "comments"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postQueryCommentsRelations) Link(
	params ...CommentWhereParam,
) postSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r postQueryCommentsRelations) Unlink(
	params ...CommentWhereParam,
) postSetParam {
	var v postSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = postSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r postQueryCommentsComment) Field() postPrismaFields {
	return postFieldComments
}

// base struct
type postQueryTagsTag struct{}

type postQueryTagsRelations struct{}

// Post -> Tags
//
// @relation
// @required
func (postQueryTagsRelations) Some(
	params ...TagWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Tags
//
// @relation
// @required
func (postQueryTagsRelations) Every(
	params ...TagWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> Tags
//
// @relation
// @required
func (postQueryTagsRelations) None(
	params ...TagWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryTagsRelations) Fetch(

	params ...TagWhereParam,

) postToTagsFindMany {
	var v postToTagsFindMany

	v.query.Operation = "query"
	v.query.Method = "tags"
	v.query.Outputs = tagOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postQueryTagsRelations) Link(
	params ...TagWhereParam,
) postSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postSetParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r postQueryTagsRelations) Unlink(
	params ...TagWhereParam,
) postSetParam {
	var v postSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = postSetParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r postQueryTagsTag) Field() postPrismaFields {
	return postFieldTags
}

// base struct
type postQueryRestaurantIDString struct{}

// Set the optional value of RestaurantID
func (r postQueryRestaurantIDString) Set(value string) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "restaurantId",
			Value: value,
		},
	}

}

// Set the optional value of RestaurantID dynamically
func (r postQueryRestaurantIDString) SetIfPresent(value *String) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of RestaurantID dynamically
func (r postQueryRestaurantIDString) SetOptional(value *String) postSetParam {
	if value == nil {

		var v *string
		return postSetParam{
			data: builder.Field{
				Name:  "restaurantId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r postQueryRestaurantIDString) Equals(value string) postWithPrismaRestaurantIDEqualsParam {

	return postWithPrismaRestaurantIDEqualsParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) EqualsIfPresent(value *string) postWithPrismaRestaurantIDEqualsParam {
	if value == nil {
		return postWithPrismaRestaurantIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryRestaurantIDString) EqualsOptional(value *String) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) IsNull() postDefaultParam {
	var str *string = nil
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "restaurantId",
			Value: direction,
		},
	}
}

func (r postQueryRestaurantIDString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "restaurantId",
			Value: cursor,
		},
	}
}

func (r postQueryRestaurantIDString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryRestaurantIDString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryRestaurantIDString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryRestaurantIDString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryRestaurantIDString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryRestaurantIDString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryRestaurantIDString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryRestaurantIDString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryRestaurantIDString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryRestaurantIDString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryRestaurantIDString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryRestaurantIDString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryRestaurantIDString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryRestaurantIDString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryRestaurantIDString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "restaurantId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryRestaurantIDString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryRestaurantIDString) Field() postPrismaFields {
	return postFieldRestaurantID
}

// base struct
type postQueryRestaurantRestaurant struct{}

type postQueryRestaurantRelations struct{}

// Post -> Restaurant
//
// @relation
// @optional
func (postQueryRestaurantRelations) Where(
	params ...RestaurantWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "restaurant",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryRestaurantRelations) Fetch() postToRestaurantFindUnique {
	var v postToRestaurantFindUnique

	v.query.Operation = "query"
	v.query.Method = "restaurant"
	v.query.Outputs = restaurantOutput

	return v
}

func (r postQueryRestaurantRelations) Link(
	params RestaurantWhereParam,
) postSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return postSetParam{}
	}

	fields = append(fields, f)

	return postSetParam{
		data: builder.Field{
			Name: "restaurant",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r postQueryRestaurantRelations) Unlink() postSetParam {
	var v postSetParam

	v = postSetParam{
		data: builder.Field{
			Name: "restaurant",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r postQueryRestaurantRestaurant) Field() postPrismaFields {
	return postFieldRestaurant
}

// base struct
type postQueryOriginalPostPost struct{}

type postQueryOriginalPostRelations struct{}

// Post -> OriginalPost
//
// @relation
// @optional
func (postQueryOriginalPostRelations) Where(
	params ...PostWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "originalPost",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryOriginalPostRelations) Fetch() postToOriginalPostFindUnique {
	var v postToOriginalPostFindUnique

	v.query.Operation = "query"
	v.query.Method = "originalPost"
	v.query.Outputs = postOutput

	return v
}

func (r postQueryOriginalPostRelations) Link(
	params PostWhereParam,
) postSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return postSetParam{}
	}

	fields = append(fields, f)

	return postSetParam{
		data: builder.Field{
			Name: "originalPost",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r postQueryOriginalPostRelations) Unlink() postSetParam {
	var v postSetParam

	v = postSetParam{
		data: builder.Field{
			Name: "originalPost",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r postQueryOriginalPostPost) Field() postPrismaFields {
	return postFieldOriginalPost
}

// base struct
type postQueryOriginalPostIDString struct{}

// Set the optional value of OriginalPostID
func (r postQueryOriginalPostIDString) Set(value string) postSetParam {

	return postSetParam{
		data: builder.Field{
			Name:  "originalPostId",
			Value: value,
		},
	}

}

// Set the optional value of OriginalPostID dynamically
func (r postQueryOriginalPostIDString) SetIfPresent(value *String) postSetParam {
	if value == nil {
		return postSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of OriginalPostID dynamically
func (r postQueryOriginalPostIDString) SetOptional(value *String) postSetParam {
	if value == nil {

		var v *string
		return postSetParam{
			data: builder.Field{
				Name:  "originalPostId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r postQueryOriginalPostIDString) Equals(value string) postWithPrismaOriginalPostIDEqualsParam {

	return postWithPrismaOriginalPostIDEqualsParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) EqualsIfPresent(value *string) postWithPrismaOriginalPostIDEqualsParam {
	if value == nil {
		return postWithPrismaOriginalPostIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r postQueryOriginalPostIDString) EqualsOptional(value *String) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) IsNull() postDefaultParam {
	var str *string = nil
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) Order(direction SortOrder) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name:  "originalPostId",
			Value: direction,
		},
	}
}

func (r postQueryOriginalPostIDString) Cursor(cursor string) postCursorParam {
	return postCursorParam{
		data: builder.Field{
			Name:  "originalPostId",
			Value: cursor,
		},
	}
}

func (r postQueryOriginalPostIDString) In(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) InIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.In(value)
}

func (r postQueryOriginalPostIDString) NotIn(value []string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) NotInIfPresent(value []string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.NotIn(value)
}

func (r postQueryOriginalPostIDString) Lt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) LtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lt(*value)
}

func (r postQueryOriginalPostIDString) Lte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) LteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Lte(*value)
}

func (r postQueryOriginalPostIDString) Gt(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) GtIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gt(*value)
}

func (r postQueryOriginalPostIDString) Gte(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) GteIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Gte(*value)
}

func (r postQueryOriginalPostIDString) Contains(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) ContainsIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Contains(*value)
}

func (r postQueryOriginalPostIDString) StartsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) StartsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r postQueryOriginalPostIDString) EndsWith(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) EndsWithIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r postQueryOriginalPostIDString) Mode(value QueryMode) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) ModeIfPresent(value *QueryMode) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Mode(*value)
}

func (r postQueryOriginalPostIDString) Not(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r postQueryOriginalPostIDString) NotIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r postQueryOriginalPostIDString) HasPrefix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r postQueryOriginalPostIDString) HasPrefixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r postQueryOriginalPostIDString) HasSuffix(value string) postDefaultParam {
	return postDefaultParam{
		data: builder.Field{
			Name: "originalPostId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r postQueryOriginalPostIDString) HasSuffixIfPresent(value *string) postDefaultParam {
	if value == nil {
		return postDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r postQueryOriginalPostIDString) Field() postPrismaFields {
	return postFieldOriginalPostID
}

// base struct
type postQueryRepostedPostsPost struct{}

type postQueryRepostedPostsRelations struct{}

// Post -> RepostedPosts
//
// @relation
// @required
func (postQueryRepostedPostsRelations) Some(
	params ...PostWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "repostedPosts",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> RepostedPosts
//
// @relation
// @required
func (postQueryRepostedPostsRelations) Every(
	params ...PostWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "repostedPosts",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Post -> RepostedPosts
//
// @relation
// @required
func (postQueryRepostedPostsRelations) None(
	params ...PostWhereParam,
) postDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postDefaultParam{
		data: builder.Field{
			Name: "repostedPosts",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (postQueryRepostedPostsRelations) Fetch(

	params ...PostWhereParam,

) postToRepostedPostsFindMany {
	var v postToRepostedPostsFindMany

	v.query.Operation = "query"
	v.query.Method = "repostedPosts"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postQueryRepostedPostsRelations) Link(
	params ...PostWhereParam,
) postSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postSetParam{
		data: builder.Field{
			Name: "repostedPosts",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r postQueryRepostedPostsRelations) Unlink(
	params ...PostWhereParam,
) postSetParam {
	var v postSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = postSetParam{
		data: builder.Field{
			Name: "repostedPosts",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r postQueryRepostedPostsPost) Field() postPrismaFields {
	return postFieldRepostedPosts
}

// Comment acts as a namespaces to access query methods for the Comment model
var Comment = commentQuery{}

// commentQuery exposes query functions for the comment model
type commentQuery struct {

	// ID
	//
	// @required
	ID commentQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt commentQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt commentQueryUpdatedAtDateTime

	// Content
	//
	// @required
	Content commentQueryContentString

	// PostID
	//
	// @required
	PostID commentQueryPostIDString

	Post commentQueryPostRelations

	// UserID
	//
	// @required
	UserID commentQueryUserIDString

	User commentQueryUserRelations
}

func (commentQuery) Not(params ...CommentWhereParam) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (commentQuery) Or(params ...CommentWhereParam) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (commentQuery) And(params ...CommentWhereParam) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type commentQueryIDString struct{}

// Set the required value of ID
func (r commentQueryIDString) Set(value string) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r commentQueryIDString) SetIfPresent(value *String) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryIDString) Equals(value string) commentWithPrismaIDEqualsUniqueParam {

	return commentWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) EqualsIfPresent(value *string) commentWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return commentWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryIDString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r commentQueryIDString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r commentQueryIDString) In(value []string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) InIfPresent(value []string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.In(value)
}

func (r commentQueryIDString) NotIn(value []string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) NotInIfPresent(value []string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.NotIn(value)
}

func (r commentQueryIDString) Lt(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) LtIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Lt(*value)
}

func (r commentQueryIDString) Lte(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) LteIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Lte(*value)
}

func (r commentQueryIDString) Gt(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) GtIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Gt(*value)
}

func (r commentQueryIDString) Gte(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) GteIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Gte(*value)
}

func (r commentQueryIDString) Contains(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) ContainsIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Contains(*value)
}

func (r commentQueryIDString) StartsWith(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) StartsWithIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryIDString) EndsWith(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) EndsWithIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryIDString) Mode(value QueryMode) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) ModeIfPresent(value *QueryMode) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Mode(*value)
}

func (r commentQueryIDString) Not(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryIDString) NotIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryIDString) HasPrefix(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryIDString) HasPrefixIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryIDString) HasSuffix(value string) commentParamUnique {
	return commentParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryIDString) HasSuffixIfPresent(value *string) commentParamUnique {
	if value == nil {
		return commentParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryIDString) Field() commentPrismaFields {
	return commentFieldID
}

// base struct
type commentQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r commentQueryCreatedAtDateTime) Set(value DateTime) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r commentQueryCreatedAtDateTime) SetIfPresent(value *DateTime) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryCreatedAtDateTime) Equals(value DateTime) commentWithPrismaCreatedAtEqualsParam {

	return commentWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) commentWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return commentWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryCreatedAtDateTime) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r commentQueryCreatedAtDateTime) Cursor(cursor DateTime) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r commentQueryCreatedAtDateTime) In(value []DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) InIfPresent(value []DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryCreatedAtDateTime) NotIn(value []DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryCreatedAtDateTime) Lt(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) LtIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryCreatedAtDateTime) Lte(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) LteIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryCreatedAtDateTime) Gt(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) GtIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryCreatedAtDateTime) Gte(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) GteIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryCreatedAtDateTime) Not(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryCreatedAtDateTime) NotIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r commentQueryCreatedAtDateTime) Before(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r commentQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r commentQueryCreatedAtDateTime) After(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r commentQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r commentQueryCreatedAtDateTime) BeforeEquals(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r commentQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r commentQueryCreatedAtDateTime) AfterEquals(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r commentQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r commentQueryCreatedAtDateTime) Field() commentPrismaFields {
	return commentFieldCreatedAt
}

// base struct
type commentQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r commentQueryUpdatedAtDateTime) Set(value DateTime) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r commentQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryUpdatedAtDateTime) Equals(value DateTime) commentWithPrismaUpdatedAtEqualsParam {

	return commentWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) commentWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return commentWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryUpdatedAtDateTime) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r commentQueryUpdatedAtDateTime) Cursor(cursor DateTime) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r commentQueryUpdatedAtDateTime) In(value []DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) InIfPresent(value []DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryUpdatedAtDateTime) NotIn(value []DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryUpdatedAtDateTime) Lt(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryUpdatedAtDateTime) Lte(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryUpdatedAtDateTime) Gt(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryUpdatedAtDateTime) Gte(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryUpdatedAtDateTime) Not(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r commentQueryUpdatedAtDateTime) Before(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r commentQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r commentQueryUpdatedAtDateTime) After(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r commentQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r commentQueryUpdatedAtDateTime) BeforeEquals(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r commentQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r commentQueryUpdatedAtDateTime) AfterEquals(value DateTime) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r commentQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r commentQueryUpdatedAtDateTime) Field() commentPrismaFields {
	return commentFieldUpdatedAt
}

// base struct
type commentQueryContentString struct{}

// Set the required value of Content
func (r commentQueryContentString) Set(value string) commentWithPrismaContentSetParam {

	return commentWithPrismaContentSetParam{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}

}

// Set the optional value of Content dynamically
func (r commentQueryContentString) SetIfPresent(value *String) commentWithPrismaContentSetParam {
	if value == nil {
		return commentWithPrismaContentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryContentString) Equals(value string) commentWithPrismaContentEqualsParam {

	return commentWithPrismaContentEqualsParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) EqualsIfPresent(value *string) commentWithPrismaContentEqualsParam {
	if value == nil {
		return commentWithPrismaContentEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryContentString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "content",
			Value: direction,
		},
	}
}

func (r commentQueryContentString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "content",
			Value: cursor,
		},
	}
}

func (r commentQueryContentString) In(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) InIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryContentString) NotIn(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) NotInIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryContentString) Lt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) LtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryContentString) Lte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) LteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryContentString) Gt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) GtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryContentString) Gte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) GteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryContentString) Contains(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) ContainsIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentQueryContentString) StartsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) StartsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryContentString) EndsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) EndsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryContentString) Mode(value QueryMode) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) ModeIfPresent(value *QueryMode) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Mode(*value)
}

func (r commentQueryContentString) Not(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryContentString) NotIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryContentString) HasPrefix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryContentString) HasPrefixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryContentString) HasSuffix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryContentString) HasSuffixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryContentString) Field() commentPrismaFields {
	return commentFieldContent
}

// base struct
type commentQueryPostIDString struct{}

// Set the required value of PostID
func (r commentQueryPostIDString) Set(value string) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "postId",
			Value: value,
		},
	}

}

// Set the optional value of PostID dynamically
func (r commentQueryPostIDString) SetIfPresent(value *String) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryPostIDString) Equals(value string) commentWithPrismaPostIDEqualsParam {

	return commentWithPrismaPostIDEqualsParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) EqualsIfPresent(value *string) commentWithPrismaPostIDEqualsParam {
	if value == nil {
		return commentWithPrismaPostIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryPostIDString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "postId",
			Value: direction,
		},
	}
}

func (r commentQueryPostIDString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "postId",
			Value: cursor,
		},
	}
}

func (r commentQueryPostIDString) In(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) InIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryPostIDString) NotIn(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) NotInIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryPostIDString) Lt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) LtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryPostIDString) Lte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) LteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryPostIDString) Gt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) GtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryPostIDString) Gte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) GteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryPostIDString) Contains(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) ContainsIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentQueryPostIDString) StartsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) StartsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryPostIDString) EndsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) EndsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryPostIDString) Mode(value QueryMode) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) ModeIfPresent(value *QueryMode) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Mode(*value)
}

func (r commentQueryPostIDString) Not(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryPostIDString) NotIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryPostIDString) HasPrefix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryPostIDString) HasPrefixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryPostIDString) HasSuffix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryPostIDString) HasSuffixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryPostIDString) Field() commentPrismaFields {
	return commentFieldPostID
}

// base struct
type commentQueryPostPost struct{}

type commentQueryPostRelations struct{}

// Comment -> Post
//
// @relation
// @required
func (commentQueryPostRelations) Where(
	params ...PostWhereParam,
) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (commentQueryPostRelations) Fetch() commentToPostFindUnique {
	var v commentToPostFindUnique

	v.query.Operation = "query"
	v.query.Method = "post"
	v.query.Outputs = postOutput

	return v
}

func (r commentQueryPostRelations) Link(
	params PostWhereParam,
) commentWithPrismaPostSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return commentWithPrismaPostSetParam{}
	}

	fields = append(fields, f)

	return commentWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r commentQueryPostRelations) Unlink() commentWithPrismaPostSetParam {
	var v commentWithPrismaPostSetParam

	v = commentWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r commentQueryPostPost) Field() commentPrismaFields {
	return commentFieldPost
}

// base struct
type commentQueryUserIDString struct{}

// Set the required value of UserID
func (r commentQueryUserIDString) Set(value string) commentSetParam {

	return commentSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r commentQueryUserIDString) SetIfPresent(value *String) commentSetParam {
	if value == nil {
		return commentSetParam{}
	}

	return r.Set(*value)
}

func (r commentQueryUserIDString) Equals(value string) commentWithPrismaUserIDEqualsParam {

	return commentWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) EqualsIfPresent(value *string) commentWithPrismaUserIDEqualsParam {
	if value == nil {
		return commentWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentQueryUserIDString) Order(direction SortOrder) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r commentQueryUserIDString) Cursor(cursor string) commentCursorParam {
	return commentCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r commentQueryUserIDString) In(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) InIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.In(value)
}

func (r commentQueryUserIDString) NotIn(value []string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) NotInIfPresent(value []string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentQueryUserIDString) Lt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) LtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentQueryUserIDString) Lte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) LteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentQueryUserIDString) Gt(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) GtIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentQueryUserIDString) Gte(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) GteIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentQueryUserIDString) Contains(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) ContainsIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentQueryUserIDString) StartsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) StartsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentQueryUserIDString) EndsWith(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) EndsWithIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentQueryUserIDString) Mode(value QueryMode) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) ModeIfPresent(value *QueryMode) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Mode(*value)
}

func (r commentQueryUserIDString) Not(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentQueryUserIDString) NotIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentQueryUserIDString) HasPrefix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentQueryUserIDString) HasPrefixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentQueryUserIDString) HasSuffix(value string) commentDefaultParam {
	return commentDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentQueryUserIDString) HasSuffixIfPresent(value *string) commentDefaultParam {
	if value == nil {
		return commentDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentQueryUserIDString) Field() commentPrismaFields {
	return commentFieldUserID
}

// base struct
type commentQueryUserUser struct{}

type commentQueryUserRelations struct{}

// Comment -> User
//
// @relation
// @required
func (commentQueryUserRelations) Where(
	params ...UserWhereParam,
) commentDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (commentQueryUserRelations) Fetch() commentToUserFindUnique {
	var v commentToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r commentQueryUserRelations) Link(
	params UserWhereParam,
) commentWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return commentWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return commentWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r commentQueryUserRelations) Unlink() commentWithPrismaUserSetParam {
	var v commentWithPrismaUserSetParam

	v = commentWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r commentQueryUserUser) Field() commentPrismaFields {
	return commentFieldUser
}

// Like acts as a namespaces to access query methods for the Like model
var Like = likeQuery{}

// likeQuery exposes query functions for the like model
type likeQuery struct {

	// ID
	//
	// @required
	ID likeQueryIDString

	// PostID
	//
	// @required
	PostID likeQueryPostIDString

	Post likeQueryPostRelations

	// UserID
	//
	// @required
	UserID likeQueryUserIDString

	User likeQueryUserRelations
}

func (likeQuery) Not(params ...LikeWhereParam) likeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likeDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (likeQuery) Or(params ...LikeWhereParam) likeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likeDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (likeQuery) And(params ...LikeWhereParam) likeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likeDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type likeQueryIDString struct{}

// Set the required value of ID
func (r likeQueryIDString) Set(value string) likeSetParam {

	return likeSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r likeQueryIDString) SetIfPresent(value *String) likeSetParam {
	if value == nil {
		return likeSetParam{}
	}

	return r.Set(*value)
}

func (r likeQueryIDString) Equals(value string) likeWithPrismaIDEqualsUniqueParam {

	return likeWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) EqualsIfPresent(value *string) likeWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return likeWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r likeQueryIDString) Order(direction SortOrder) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r likeQueryIDString) Cursor(cursor string) likeCursorParam {
	return likeCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r likeQueryIDString) In(value []string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) InIfPresent(value []string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.In(value)
}

func (r likeQueryIDString) NotIn(value []string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) NotInIfPresent(value []string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.NotIn(value)
}

func (r likeQueryIDString) Lt(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) LtIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.Lt(*value)
}

func (r likeQueryIDString) Lte(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) LteIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.Lte(*value)
}

func (r likeQueryIDString) Gt(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) GtIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.Gt(*value)
}

func (r likeQueryIDString) Gte(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) GteIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.Gte(*value)
}

func (r likeQueryIDString) Contains(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) ContainsIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.Contains(*value)
}

func (r likeQueryIDString) StartsWith(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) StartsWithIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r likeQueryIDString) EndsWith(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) EndsWithIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r likeQueryIDString) Mode(value QueryMode) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) ModeIfPresent(value *QueryMode) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.Mode(*value)
}

func (r likeQueryIDString) Not(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryIDString) NotIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likeQueryIDString) HasPrefix(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likeQueryIDString) HasPrefixIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likeQueryIDString) HasSuffix(value string) likeParamUnique {
	return likeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likeQueryIDString) HasSuffixIfPresent(value *string) likeParamUnique {
	if value == nil {
		return likeParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r likeQueryIDString) Field() likePrismaFields {
	return likeFieldID
}

// base struct
type likeQueryPostIDString struct{}

// Set the required value of PostID
func (r likeQueryPostIDString) Set(value string) likeSetParam {

	return likeSetParam{
		data: builder.Field{
			Name:  "postId",
			Value: value,
		},
	}

}

// Set the optional value of PostID dynamically
func (r likeQueryPostIDString) SetIfPresent(value *String) likeSetParam {
	if value == nil {
		return likeSetParam{}
	}

	return r.Set(*value)
}

func (r likeQueryPostIDString) Equals(value string) likeWithPrismaPostIDEqualsParam {

	return likeWithPrismaPostIDEqualsParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) EqualsIfPresent(value *string) likeWithPrismaPostIDEqualsParam {
	if value == nil {
		return likeWithPrismaPostIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r likeQueryPostIDString) Order(direction SortOrder) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name:  "postId",
			Value: direction,
		},
	}
}

func (r likeQueryPostIDString) Cursor(cursor string) likeCursorParam {
	return likeCursorParam{
		data: builder.Field{
			Name:  "postId",
			Value: cursor,
		},
	}
}

func (r likeQueryPostIDString) In(value []string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) InIfPresent(value []string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.In(value)
}

func (r likeQueryPostIDString) NotIn(value []string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) NotInIfPresent(value []string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r likeQueryPostIDString) Lt(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) LtIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r likeQueryPostIDString) Lte(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) LteIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r likeQueryPostIDString) Gt(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) GtIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r likeQueryPostIDString) Gte(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) GteIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r likeQueryPostIDString) Contains(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) ContainsIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r likeQueryPostIDString) StartsWith(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) StartsWithIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r likeQueryPostIDString) EndsWith(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) EndsWithIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r likeQueryPostIDString) Mode(value QueryMode) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) ModeIfPresent(value *QueryMode) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r likeQueryPostIDString) Not(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryPostIDString) NotIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likeQueryPostIDString) HasPrefix(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likeQueryPostIDString) HasPrefixIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likeQueryPostIDString) HasSuffix(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likeQueryPostIDString) HasSuffixIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r likeQueryPostIDString) Field() likePrismaFields {
	return likeFieldPostID
}

// base struct
type likeQueryPostPost struct{}

type likeQueryPostRelations struct{}

// Like -> Post
//
// @relation
// @required
func (likeQueryPostRelations) Where(
	params ...PostWhereParam,
) likeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likeDefaultParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (likeQueryPostRelations) Fetch() likeToPostFindUnique {
	var v likeToPostFindUnique

	v.query.Operation = "query"
	v.query.Method = "post"
	v.query.Outputs = postOutput

	return v
}

func (r likeQueryPostRelations) Link(
	params PostWhereParam,
) likeWithPrismaPostSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return likeWithPrismaPostSetParam{}
	}

	fields = append(fields, f)

	return likeWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r likeQueryPostRelations) Unlink() likeWithPrismaPostSetParam {
	var v likeWithPrismaPostSetParam

	v = likeWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r likeQueryPostPost) Field() likePrismaFields {
	return likeFieldPost
}

// base struct
type likeQueryUserIDString struct{}

// Set the required value of UserID
func (r likeQueryUserIDString) Set(value string) likeSetParam {

	return likeSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r likeQueryUserIDString) SetIfPresent(value *String) likeSetParam {
	if value == nil {
		return likeSetParam{}
	}

	return r.Set(*value)
}

func (r likeQueryUserIDString) Equals(value string) likeWithPrismaUserIDEqualsParam {

	return likeWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) EqualsIfPresent(value *string) likeWithPrismaUserIDEqualsParam {
	if value == nil {
		return likeWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r likeQueryUserIDString) Order(direction SortOrder) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r likeQueryUserIDString) Cursor(cursor string) likeCursorParam {
	return likeCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r likeQueryUserIDString) In(value []string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) InIfPresent(value []string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.In(value)
}

func (r likeQueryUserIDString) NotIn(value []string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) NotInIfPresent(value []string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r likeQueryUserIDString) Lt(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) LtIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r likeQueryUserIDString) Lte(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) LteIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r likeQueryUserIDString) Gt(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) GtIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r likeQueryUserIDString) Gte(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) GteIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r likeQueryUserIDString) Contains(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) ContainsIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r likeQueryUserIDString) StartsWith(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) StartsWithIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r likeQueryUserIDString) EndsWith(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) EndsWithIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r likeQueryUserIDString) Mode(value QueryMode) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) ModeIfPresent(value *QueryMode) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r likeQueryUserIDString) Not(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likeQueryUserIDString) NotIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likeQueryUserIDString) HasPrefix(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likeQueryUserIDString) HasPrefixIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likeQueryUserIDString) HasSuffix(value string) likeDefaultParam {
	return likeDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likeQueryUserIDString) HasSuffixIfPresent(value *string) likeDefaultParam {
	if value == nil {
		return likeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r likeQueryUserIDString) Field() likePrismaFields {
	return likeFieldUserID
}

// base struct
type likeQueryUserUser struct{}

type likeQueryUserRelations struct{}

// Like -> User
//
// @relation
// @required
func (likeQueryUserRelations) Where(
	params ...UserWhereParam,
) likeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likeDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (likeQueryUserRelations) Fetch() likeToUserFindUnique {
	var v likeToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r likeQueryUserRelations) Link(
	params UserWhereParam,
) likeWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return likeWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return likeWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r likeQueryUserRelations) Unlink() likeWithPrismaUserSetParam {
	var v likeWithPrismaUserSetParam

	v = likeWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r likeQueryUserUser) Field() likePrismaFields {
	return likeFieldUser
}

// Tag acts as a namespaces to access query methods for the Tag model
var Tag = tagQuery{}

// tagQuery exposes query functions for the tag model
type tagQuery struct {

	// ID
	//
	// @required
	ID tagQueryIDString

	// PostID
	//
	// @required
	PostID tagQueryPostIDString

	Post tagQueryPostRelations

	// UserID
	//
	// @required
	UserID tagQueryUserIDString

	User tagQueryUserRelations
}

func (tagQuery) Not(params ...TagWhereParam) tagDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagQuery) Or(params ...TagWhereParam) tagDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagQuery) And(params ...TagWhereParam) tagDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type tagQueryIDString struct{}

// Set the required value of ID
func (r tagQueryIDString) Set(value string) tagSetParam {

	return tagSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r tagQueryIDString) SetIfPresent(value *String) tagSetParam {
	if value == nil {
		return tagSetParam{}
	}

	return r.Set(*value)
}

func (r tagQueryIDString) Equals(value string) tagWithPrismaIDEqualsUniqueParam {

	return tagWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) EqualsIfPresent(value *string) tagWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return tagWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r tagQueryIDString) Order(direction SortOrder) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r tagQueryIDString) Cursor(cursor string) tagCursorParam {
	return tagCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r tagQueryIDString) In(value []string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) InIfPresent(value []string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.In(value)
}

func (r tagQueryIDString) NotIn(value []string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) NotInIfPresent(value []string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.NotIn(value)
}

func (r tagQueryIDString) Lt(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) LtIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.Lt(*value)
}

func (r tagQueryIDString) Lte(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) LteIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.Lte(*value)
}

func (r tagQueryIDString) Gt(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) GtIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.Gt(*value)
}

func (r tagQueryIDString) Gte(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) GteIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.Gte(*value)
}

func (r tagQueryIDString) Contains(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) ContainsIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.Contains(*value)
}

func (r tagQueryIDString) StartsWith(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) StartsWithIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r tagQueryIDString) EndsWith(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) EndsWithIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r tagQueryIDString) Mode(value QueryMode) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) ModeIfPresent(value *QueryMode) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.Mode(*value)
}

func (r tagQueryIDString) Not(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryIDString) NotIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagQueryIDString) HasPrefix(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagQueryIDString) HasPrefixIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagQueryIDString) HasSuffix(value string) tagParamUnique {
	return tagParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagQueryIDString) HasSuffixIfPresent(value *string) tagParamUnique {
	if value == nil {
		return tagParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r tagQueryIDString) Field() tagPrismaFields {
	return tagFieldID
}

// base struct
type tagQueryPostIDString struct{}

// Set the required value of PostID
func (r tagQueryPostIDString) Set(value string) tagSetParam {

	return tagSetParam{
		data: builder.Field{
			Name:  "postId",
			Value: value,
		},
	}

}

// Set the optional value of PostID dynamically
func (r tagQueryPostIDString) SetIfPresent(value *String) tagSetParam {
	if value == nil {
		return tagSetParam{}
	}

	return r.Set(*value)
}

func (r tagQueryPostIDString) Equals(value string) tagWithPrismaPostIDEqualsParam {

	return tagWithPrismaPostIDEqualsParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) EqualsIfPresent(value *string) tagWithPrismaPostIDEqualsParam {
	if value == nil {
		return tagWithPrismaPostIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r tagQueryPostIDString) Order(direction SortOrder) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name:  "postId",
			Value: direction,
		},
	}
}

func (r tagQueryPostIDString) Cursor(cursor string) tagCursorParam {
	return tagCursorParam{
		data: builder.Field{
			Name:  "postId",
			Value: cursor,
		},
	}
}

func (r tagQueryPostIDString) In(value []string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) InIfPresent(value []string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.In(value)
}

func (r tagQueryPostIDString) NotIn(value []string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) NotInIfPresent(value []string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.NotIn(value)
}

func (r tagQueryPostIDString) Lt(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) LtIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Lt(*value)
}

func (r tagQueryPostIDString) Lte(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) LteIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Lte(*value)
}

func (r tagQueryPostIDString) Gt(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) GtIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Gt(*value)
}

func (r tagQueryPostIDString) Gte(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) GteIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Gte(*value)
}

func (r tagQueryPostIDString) Contains(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) ContainsIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Contains(*value)
}

func (r tagQueryPostIDString) StartsWith(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) StartsWithIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r tagQueryPostIDString) EndsWith(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) EndsWithIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r tagQueryPostIDString) Mode(value QueryMode) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) ModeIfPresent(value *QueryMode) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Mode(*value)
}

func (r tagQueryPostIDString) Not(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryPostIDString) NotIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagQueryPostIDString) HasPrefix(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagQueryPostIDString) HasPrefixIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagQueryPostIDString) HasSuffix(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "postId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagQueryPostIDString) HasSuffixIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r tagQueryPostIDString) Field() tagPrismaFields {
	return tagFieldPostID
}

// base struct
type tagQueryPostPost struct{}

type tagQueryPostRelations struct{}

// Tag -> Post
//
// @relation
// @required
func (tagQueryPostRelations) Where(
	params ...PostWhereParam,
) tagDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagDefaultParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (tagQueryPostRelations) Fetch() tagToPostFindUnique {
	var v tagToPostFindUnique

	v.query.Operation = "query"
	v.query.Method = "post"
	v.query.Outputs = postOutput

	return v
}

func (r tagQueryPostRelations) Link(
	params PostWhereParam,
) tagWithPrismaPostSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return tagWithPrismaPostSetParam{}
	}

	fields = append(fields, f)

	return tagWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r tagQueryPostRelations) Unlink() tagWithPrismaPostSetParam {
	var v tagWithPrismaPostSetParam

	v = tagWithPrismaPostSetParam{
		data: builder.Field{
			Name: "post",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r tagQueryPostPost) Field() tagPrismaFields {
	return tagFieldPost
}

// base struct
type tagQueryUserIDString struct{}

// Set the required value of UserID
func (r tagQueryUserIDString) Set(value string) tagSetParam {

	return tagSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r tagQueryUserIDString) SetIfPresent(value *String) tagSetParam {
	if value == nil {
		return tagSetParam{}
	}

	return r.Set(*value)
}

func (r tagQueryUserIDString) Equals(value string) tagWithPrismaUserIDEqualsParam {

	return tagWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) EqualsIfPresent(value *string) tagWithPrismaUserIDEqualsParam {
	if value == nil {
		return tagWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r tagQueryUserIDString) Order(direction SortOrder) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r tagQueryUserIDString) Cursor(cursor string) tagCursorParam {
	return tagCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r tagQueryUserIDString) In(value []string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) InIfPresent(value []string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.In(value)
}

func (r tagQueryUserIDString) NotIn(value []string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) NotInIfPresent(value []string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.NotIn(value)
}

func (r tagQueryUserIDString) Lt(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) LtIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Lt(*value)
}

func (r tagQueryUserIDString) Lte(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) LteIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Lte(*value)
}

func (r tagQueryUserIDString) Gt(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) GtIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Gt(*value)
}

func (r tagQueryUserIDString) Gte(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) GteIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Gte(*value)
}

func (r tagQueryUserIDString) Contains(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) ContainsIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Contains(*value)
}

func (r tagQueryUserIDString) StartsWith(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) StartsWithIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r tagQueryUserIDString) EndsWith(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) EndsWithIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r tagQueryUserIDString) Mode(value QueryMode) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) ModeIfPresent(value *QueryMode) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Mode(*value)
}

func (r tagQueryUserIDString) Not(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagQueryUserIDString) NotIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagQueryUserIDString) HasPrefix(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagQueryUserIDString) HasPrefixIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagQueryUserIDString) HasSuffix(value string) tagDefaultParam {
	return tagDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagQueryUserIDString) HasSuffixIfPresent(value *string) tagDefaultParam {
	if value == nil {
		return tagDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r tagQueryUserIDString) Field() tagPrismaFields {
	return tagFieldUserID
}

// base struct
type tagQueryUserUser struct{}

type tagQueryUserRelations struct{}

// Tag -> User
//
// @relation
// @required
func (tagQueryUserRelations) Where(
	params ...UserWhereParam,
) tagDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (tagQueryUserRelations) Fetch() tagToUserFindUnique {
	var v tagToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r tagQueryUserRelations) Link(
	params UserWhereParam,
) tagWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return tagWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return tagWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r tagQueryUserRelations) Unlink() tagWithPrismaUserSetParam {
	var v tagWithPrismaUserSetParam

	v = tagWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r tagQueryUserUser) Field() tagPrismaFields {
	return tagFieldUser
}

// Follows acts as a namespaces to access query methods for the Follows model
var Follows = followsQuery{}

// followsQuery exposes query functions for the follows model
type followsQuery struct {

	// ID
	//
	// @required
	ID followsQueryIDString

	// FollowerID
	//
	// @required
	FollowerID followsQueryFollowerIDString

	Follower followsQueryFollowerRelations

	// FollowingID
	//
	// @required
	FollowingID followsQueryFollowingIDString

	Following followsQueryFollowingRelations
}

func (followsQuery) Not(params ...FollowsWhereParam) followsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return followsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (followsQuery) Or(params ...FollowsWhereParam) followsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return followsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (followsQuery) And(params ...FollowsWhereParam) followsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return followsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type followsQueryIDString struct{}

// Set the required value of ID
func (r followsQueryIDString) Set(value string) followsSetParam {

	return followsSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r followsQueryIDString) SetIfPresent(value *String) followsSetParam {
	if value == nil {
		return followsSetParam{}
	}

	return r.Set(*value)
}

func (r followsQueryIDString) Equals(value string) followsWithPrismaIDEqualsUniqueParam {

	return followsWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) EqualsIfPresent(value *string) followsWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return followsWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r followsQueryIDString) Order(direction SortOrder) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r followsQueryIDString) Cursor(cursor string) followsCursorParam {
	return followsCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r followsQueryIDString) In(value []string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) InIfPresent(value []string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.In(value)
}

func (r followsQueryIDString) NotIn(value []string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) NotInIfPresent(value []string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.NotIn(value)
}

func (r followsQueryIDString) Lt(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) LtIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.Lt(*value)
}

func (r followsQueryIDString) Lte(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) LteIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.Lte(*value)
}

func (r followsQueryIDString) Gt(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) GtIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.Gt(*value)
}

func (r followsQueryIDString) Gte(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) GteIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.Gte(*value)
}

func (r followsQueryIDString) Contains(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) ContainsIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.Contains(*value)
}

func (r followsQueryIDString) StartsWith(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) StartsWithIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r followsQueryIDString) EndsWith(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) EndsWithIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r followsQueryIDString) Mode(value QueryMode) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) ModeIfPresent(value *QueryMode) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.Mode(*value)
}

func (r followsQueryIDString) Not(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryIDString) NotIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r followsQueryIDString) HasPrefix(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r followsQueryIDString) HasPrefixIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r followsQueryIDString) HasSuffix(value string) followsParamUnique {
	return followsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r followsQueryIDString) HasSuffixIfPresent(value *string) followsParamUnique {
	if value == nil {
		return followsParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r followsQueryIDString) Field() followsPrismaFields {
	return followsFieldID
}

// base struct
type followsQueryFollowerIDString struct{}

// Set the required value of FollowerID
func (r followsQueryFollowerIDString) Set(value string) followsSetParam {

	return followsSetParam{
		data: builder.Field{
			Name:  "followerId",
			Value: value,
		},
	}

}

// Set the optional value of FollowerID dynamically
func (r followsQueryFollowerIDString) SetIfPresent(value *String) followsSetParam {
	if value == nil {
		return followsSetParam{}
	}

	return r.Set(*value)
}

func (r followsQueryFollowerIDString) Equals(value string) followsWithPrismaFollowerIDEqualsParam {

	return followsWithPrismaFollowerIDEqualsParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) EqualsIfPresent(value *string) followsWithPrismaFollowerIDEqualsParam {
	if value == nil {
		return followsWithPrismaFollowerIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r followsQueryFollowerIDString) Order(direction SortOrder) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name:  "followerId",
			Value: direction,
		},
	}
}

func (r followsQueryFollowerIDString) Cursor(cursor string) followsCursorParam {
	return followsCursorParam{
		data: builder.Field{
			Name:  "followerId",
			Value: cursor,
		},
	}
}

func (r followsQueryFollowerIDString) In(value []string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) InIfPresent(value []string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.In(value)
}

func (r followsQueryFollowerIDString) NotIn(value []string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) NotInIfPresent(value []string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r followsQueryFollowerIDString) Lt(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) LtIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r followsQueryFollowerIDString) Lte(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) LteIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r followsQueryFollowerIDString) Gt(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) GtIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r followsQueryFollowerIDString) Gte(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) GteIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r followsQueryFollowerIDString) Contains(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) ContainsIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r followsQueryFollowerIDString) StartsWith(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) StartsWithIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r followsQueryFollowerIDString) EndsWith(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) EndsWithIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r followsQueryFollowerIDString) Mode(value QueryMode) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) ModeIfPresent(value *QueryMode) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r followsQueryFollowerIDString) Not(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowerIDString) NotIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r followsQueryFollowerIDString) HasPrefix(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r followsQueryFollowerIDString) HasPrefixIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r followsQueryFollowerIDString) HasSuffix(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followerId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r followsQueryFollowerIDString) HasSuffixIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r followsQueryFollowerIDString) Field() followsPrismaFields {
	return followsFieldFollowerID
}

// base struct
type followsQueryFollowerUser struct{}

type followsQueryFollowerRelations struct{}

// Follows -> Follower
//
// @relation
// @required
func (followsQueryFollowerRelations) Where(
	params ...UserWhereParam,
) followsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return followsDefaultParam{
		data: builder.Field{
			Name: "follower",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (followsQueryFollowerRelations) Fetch() followsToFollowerFindUnique {
	var v followsToFollowerFindUnique

	v.query.Operation = "query"
	v.query.Method = "follower"
	v.query.Outputs = userOutput

	return v
}

func (r followsQueryFollowerRelations) Link(
	params UserWhereParam,
) followsWithPrismaFollowerSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return followsWithPrismaFollowerSetParam{}
	}

	fields = append(fields, f)

	return followsWithPrismaFollowerSetParam{
		data: builder.Field{
			Name: "follower",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r followsQueryFollowerRelations) Unlink() followsWithPrismaFollowerSetParam {
	var v followsWithPrismaFollowerSetParam

	v = followsWithPrismaFollowerSetParam{
		data: builder.Field{
			Name: "follower",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r followsQueryFollowerUser) Field() followsPrismaFields {
	return followsFieldFollower
}

// base struct
type followsQueryFollowingIDString struct{}

// Set the required value of FollowingID
func (r followsQueryFollowingIDString) Set(value string) followsSetParam {

	return followsSetParam{
		data: builder.Field{
			Name:  "followingId",
			Value: value,
		},
	}

}

// Set the optional value of FollowingID dynamically
func (r followsQueryFollowingIDString) SetIfPresent(value *String) followsSetParam {
	if value == nil {
		return followsSetParam{}
	}

	return r.Set(*value)
}

func (r followsQueryFollowingIDString) Equals(value string) followsWithPrismaFollowingIDEqualsParam {

	return followsWithPrismaFollowingIDEqualsParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) EqualsIfPresent(value *string) followsWithPrismaFollowingIDEqualsParam {
	if value == nil {
		return followsWithPrismaFollowingIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r followsQueryFollowingIDString) Order(direction SortOrder) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name:  "followingId",
			Value: direction,
		},
	}
}

func (r followsQueryFollowingIDString) Cursor(cursor string) followsCursorParam {
	return followsCursorParam{
		data: builder.Field{
			Name:  "followingId",
			Value: cursor,
		},
	}
}

func (r followsQueryFollowingIDString) In(value []string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) InIfPresent(value []string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.In(value)
}

func (r followsQueryFollowingIDString) NotIn(value []string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) NotInIfPresent(value []string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r followsQueryFollowingIDString) Lt(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) LtIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r followsQueryFollowingIDString) Lte(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) LteIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r followsQueryFollowingIDString) Gt(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) GtIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r followsQueryFollowingIDString) Gte(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) GteIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r followsQueryFollowingIDString) Contains(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) ContainsIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r followsQueryFollowingIDString) StartsWith(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) StartsWithIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r followsQueryFollowingIDString) EndsWith(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) EndsWithIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r followsQueryFollowingIDString) Mode(value QueryMode) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) ModeIfPresent(value *QueryMode) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r followsQueryFollowingIDString) Not(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r followsQueryFollowingIDString) NotIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r followsQueryFollowingIDString) HasPrefix(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r followsQueryFollowingIDString) HasPrefixIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r followsQueryFollowingIDString) HasSuffix(value string) followsDefaultParam {
	return followsDefaultParam{
		data: builder.Field{
			Name: "followingId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r followsQueryFollowingIDString) HasSuffixIfPresent(value *string) followsDefaultParam {
	if value == nil {
		return followsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r followsQueryFollowingIDString) Field() followsPrismaFields {
	return followsFieldFollowingID
}

// base struct
type followsQueryFollowingUser struct{}

type followsQueryFollowingRelations struct{}

// Follows -> Following
//
// @relation
// @required
func (followsQueryFollowingRelations) Where(
	params ...UserWhereParam,
) followsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return followsDefaultParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (followsQueryFollowingRelations) Fetch() followsToFollowingFindUnique {
	var v followsToFollowingFindUnique

	v.query.Operation = "query"
	v.query.Method = "following"
	v.query.Outputs = userOutput

	return v
}

func (r followsQueryFollowingRelations) Link(
	params UserWhereParam,
) followsWithPrismaFollowingSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return followsWithPrismaFollowingSetParam{}
	}

	fields = append(fields, f)

	return followsWithPrismaFollowingSetParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r followsQueryFollowingRelations) Unlink() followsWithPrismaFollowingSetParam {
	var v followsWithPrismaFollowingSetParam

	v = followsWithPrismaFollowingSetParam{
		data: builder.Field{
			Name: "following",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r followsQueryFollowingUser) Field() followsPrismaFields {
	return followsFieldFollowing
}

// Restaurant acts as a namespaces to access query methods for the Restaurant model
var Restaurant = restaurantQuery{}

// restaurantQuery exposes query functions for the restaurant model
type restaurantQuery struct {

	// ID
	//
	// @required
	ID restaurantQueryIDString

	// Name
	//
	// @required
	Name restaurantQueryNameString

	// Address
	//
	// @required
	Address restaurantQueryAddressString

	// City
	//
	// @required
	City restaurantQueryCityString

	// State
	//
	// @required
	State restaurantQueryStateString

	// ZipCode
	//
	// @required
	ZipCode restaurantQueryZipCodeString

	// CreatedAt
	//
	// @required
	CreatedAt restaurantQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt restaurantQueryUpdatedAtDateTime

	Posts restaurantQueryPostsRelations
}

func (restaurantQuery) Not(params ...RestaurantWhereParam) restaurantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return restaurantDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (restaurantQuery) Or(params ...RestaurantWhereParam) restaurantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return restaurantDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (restaurantQuery) And(params ...RestaurantWhereParam) restaurantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return restaurantDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type restaurantQueryIDString struct{}

// Set the required value of ID
func (r restaurantQueryIDString) Set(value string) restaurantSetParam {

	return restaurantSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r restaurantQueryIDString) SetIfPresent(value *String) restaurantSetParam {
	if value == nil {
		return restaurantSetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryIDString) Equals(value string) restaurantWithPrismaIDEqualsUniqueParam {

	return restaurantWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) EqualsIfPresent(value *string) restaurantWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return restaurantWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryIDString) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r restaurantQueryIDString) Cursor(cursor string) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r restaurantQueryIDString) In(value []string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) InIfPresent(value []string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.In(value)
}

func (r restaurantQueryIDString) NotIn(value []string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) NotInIfPresent(value []string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryIDString) Lt(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) LtIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryIDString) Lte(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) LteIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryIDString) Gt(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) GtIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryIDString) Gte(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) GteIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryIDString) Contains(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) ContainsIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.Contains(*value)
}

func (r restaurantQueryIDString) StartsWith(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) StartsWithIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r restaurantQueryIDString) EndsWith(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) EndsWithIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r restaurantQueryIDString) Mode(value QueryMode) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) ModeIfPresent(value *QueryMode) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.Mode(*value)
}

func (r restaurantQueryIDString) Not(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryIDString) NotIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r restaurantQueryIDString) HasPrefix(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r restaurantQueryIDString) HasPrefixIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r restaurantQueryIDString) HasSuffix(value string) restaurantParamUnique {
	return restaurantParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r restaurantQueryIDString) HasSuffixIfPresent(value *string) restaurantParamUnique {
	if value == nil {
		return restaurantParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r restaurantQueryIDString) Field() restaurantPrismaFields {
	return restaurantFieldID
}

// base struct
type restaurantQueryNameString struct{}

// Set the required value of Name
func (r restaurantQueryNameString) Set(value string) restaurantWithPrismaNameSetParam {

	return restaurantWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r restaurantQueryNameString) SetIfPresent(value *String) restaurantWithPrismaNameSetParam {
	if value == nil {
		return restaurantWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryNameString) Equals(value string) restaurantWithPrismaNameEqualsParam {

	return restaurantWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) EqualsIfPresent(value *string) restaurantWithPrismaNameEqualsParam {
	if value == nil {
		return restaurantWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryNameString) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r restaurantQueryNameString) Cursor(cursor string) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r restaurantQueryNameString) In(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) InIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.In(value)
}

func (r restaurantQueryNameString) NotIn(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) NotInIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryNameString) Lt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) LtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryNameString) Lte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) LteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryNameString) Gt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) GtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryNameString) Gte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) GteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryNameString) Contains(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) ContainsIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r restaurantQueryNameString) StartsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) StartsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r restaurantQueryNameString) EndsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) EndsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r restaurantQueryNameString) Mode(value QueryMode) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) ModeIfPresent(value *QueryMode) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r restaurantQueryNameString) Not(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryNameString) NotIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r restaurantQueryNameString) HasPrefix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r restaurantQueryNameString) HasPrefixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r restaurantQueryNameString) HasSuffix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r restaurantQueryNameString) HasSuffixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r restaurantQueryNameString) Field() restaurantPrismaFields {
	return restaurantFieldName
}

// base struct
type restaurantQueryAddressString struct{}

// Set the required value of Address
func (r restaurantQueryAddressString) Set(value string) restaurantWithPrismaAddressSetParam {

	return restaurantWithPrismaAddressSetParam{
		data: builder.Field{
			Name:  "address",
			Value: value,
		},
	}

}

// Set the optional value of Address dynamically
func (r restaurantQueryAddressString) SetIfPresent(value *String) restaurantWithPrismaAddressSetParam {
	if value == nil {
		return restaurantWithPrismaAddressSetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryAddressString) Equals(value string) restaurantWithPrismaAddressEqualsParam {

	return restaurantWithPrismaAddressEqualsParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) EqualsIfPresent(value *string) restaurantWithPrismaAddressEqualsParam {
	if value == nil {
		return restaurantWithPrismaAddressEqualsParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryAddressString) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "address",
			Value: direction,
		},
	}
}

func (r restaurantQueryAddressString) Cursor(cursor string) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "address",
			Value: cursor,
		},
	}
}

func (r restaurantQueryAddressString) In(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) InIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.In(value)
}

func (r restaurantQueryAddressString) NotIn(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) NotInIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryAddressString) Lt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) LtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryAddressString) Lte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) LteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryAddressString) Gt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) GtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryAddressString) Gte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) GteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryAddressString) Contains(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) ContainsIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r restaurantQueryAddressString) StartsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) StartsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r restaurantQueryAddressString) EndsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) EndsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r restaurantQueryAddressString) Mode(value QueryMode) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) ModeIfPresent(value *QueryMode) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r restaurantQueryAddressString) Not(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryAddressString) NotIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r restaurantQueryAddressString) HasPrefix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r restaurantQueryAddressString) HasPrefixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r restaurantQueryAddressString) HasSuffix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "address",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r restaurantQueryAddressString) HasSuffixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r restaurantQueryAddressString) Field() restaurantPrismaFields {
	return restaurantFieldAddress
}

// base struct
type restaurantQueryCityString struct{}

// Set the required value of City
func (r restaurantQueryCityString) Set(value string) restaurantWithPrismaCitySetParam {

	return restaurantWithPrismaCitySetParam{
		data: builder.Field{
			Name:  "city",
			Value: value,
		},
	}

}

// Set the optional value of City dynamically
func (r restaurantQueryCityString) SetIfPresent(value *String) restaurantWithPrismaCitySetParam {
	if value == nil {
		return restaurantWithPrismaCitySetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryCityString) Equals(value string) restaurantWithPrismaCityEqualsParam {

	return restaurantWithPrismaCityEqualsParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) EqualsIfPresent(value *string) restaurantWithPrismaCityEqualsParam {
	if value == nil {
		return restaurantWithPrismaCityEqualsParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryCityString) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "city",
			Value: direction,
		},
	}
}

func (r restaurantQueryCityString) Cursor(cursor string) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "city",
			Value: cursor,
		},
	}
}

func (r restaurantQueryCityString) In(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) InIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.In(value)
}

func (r restaurantQueryCityString) NotIn(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) NotInIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryCityString) Lt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) LtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryCityString) Lte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) LteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryCityString) Gt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) GtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryCityString) Gte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) GteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryCityString) Contains(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) ContainsIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r restaurantQueryCityString) StartsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) StartsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r restaurantQueryCityString) EndsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) EndsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r restaurantQueryCityString) Mode(value QueryMode) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) ModeIfPresent(value *QueryMode) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r restaurantQueryCityString) Not(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCityString) NotIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r restaurantQueryCityString) HasPrefix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r restaurantQueryCityString) HasPrefixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r restaurantQueryCityString) HasSuffix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "city",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r restaurantQueryCityString) HasSuffixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r restaurantQueryCityString) Field() restaurantPrismaFields {
	return restaurantFieldCity
}

// base struct
type restaurantQueryStateString struct{}

// Set the required value of State
func (r restaurantQueryStateString) Set(value string) restaurantWithPrismaStateSetParam {

	return restaurantWithPrismaStateSetParam{
		data: builder.Field{
			Name:  "state",
			Value: value,
		},
	}

}

// Set the optional value of State dynamically
func (r restaurantQueryStateString) SetIfPresent(value *String) restaurantWithPrismaStateSetParam {
	if value == nil {
		return restaurantWithPrismaStateSetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryStateString) Equals(value string) restaurantWithPrismaStateEqualsParam {

	return restaurantWithPrismaStateEqualsParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) EqualsIfPresent(value *string) restaurantWithPrismaStateEqualsParam {
	if value == nil {
		return restaurantWithPrismaStateEqualsParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryStateString) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "state",
			Value: direction,
		},
	}
}

func (r restaurantQueryStateString) Cursor(cursor string) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "state",
			Value: cursor,
		},
	}
}

func (r restaurantQueryStateString) In(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) InIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.In(value)
}

func (r restaurantQueryStateString) NotIn(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) NotInIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryStateString) Lt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) LtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryStateString) Lte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) LteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryStateString) Gt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) GtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryStateString) Gte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) GteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryStateString) Contains(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) ContainsIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r restaurantQueryStateString) StartsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) StartsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r restaurantQueryStateString) EndsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) EndsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r restaurantQueryStateString) Mode(value QueryMode) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) ModeIfPresent(value *QueryMode) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r restaurantQueryStateString) Not(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryStateString) NotIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r restaurantQueryStateString) HasPrefix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r restaurantQueryStateString) HasPrefixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r restaurantQueryStateString) HasSuffix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "state",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r restaurantQueryStateString) HasSuffixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r restaurantQueryStateString) Field() restaurantPrismaFields {
	return restaurantFieldState
}

// base struct
type restaurantQueryZipCodeString struct{}

// Set the required value of ZipCode
func (r restaurantQueryZipCodeString) Set(value string) restaurantWithPrismaZipCodeSetParam {

	return restaurantWithPrismaZipCodeSetParam{
		data: builder.Field{
			Name:  "zipCode",
			Value: value,
		},
	}

}

// Set the optional value of ZipCode dynamically
func (r restaurantQueryZipCodeString) SetIfPresent(value *String) restaurantWithPrismaZipCodeSetParam {
	if value == nil {
		return restaurantWithPrismaZipCodeSetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryZipCodeString) Equals(value string) restaurantWithPrismaZipCodeEqualsParam {

	return restaurantWithPrismaZipCodeEqualsParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) EqualsIfPresent(value *string) restaurantWithPrismaZipCodeEqualsParam {
	if value == nil {
		return restaurantWithPrismaZipCodeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryZipCodeString) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "zipCode",
			Value: direction,
		},
	}
}

func (r restaurantQueryZipCodeString) Cursor(cursor string) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "zipCode",
			Value: cursor,
		},
	}
}

func (r restaurantQueryZipCodeString) In(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) InIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.In(value)
}

func (r restaurantQueryZipCodeString) NotIn(value []string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) NotInIfPresent(value []string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryZipCodeString) Lt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) LtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryZipCodeString) Lte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) LteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryZipCodeString) Gt(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) GtIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryZipCodeString) Gte(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) GteIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryZipCodeString) Contains(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) ContainsIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Contains(*value)
}

func (r restaurantQueryZipCodeString) StartsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) StartsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r restaurantQueryZipCodeString) EndsWith(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) EndsWithIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r restaurantQueryZipCodeString) Mode(value QueryMode) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) ModeIfPresent(value *QueryMode) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Mode(*value)
}

func (r restaurantQueryZipCodeString) Not(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryZipCodeString) NotIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r restaurantQueryZipCodeString) HasPrefix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r restaurantQueryZipCodeString) HasPrefixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r restaurantQueryZipCodeString) HasSuffix(value string) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "zipCode",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r restaurantQueryZipCodeString) HasSuffixIfPresent(value *string) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r restaurantQueryZipCodeString) Field() restaurantPrismaFields {
	return restaurantFieldZipCode
}

// base struct
type restaurantQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r restaurantQueryCreatedAtDateTime) Set(value DateTime) restaurantSetParam {

	return restaurantSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r restaurantQueryCreatedAtDateTime) SetIfPresent(value *DateTime) restaurantSetParam {
	if value == nil {
		return restaurantSetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryCreatedAtDateTime) Equals(value DateTime) restaurantWithPrismaCreatedAtEqualsParam {

	return restaurantWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) restaurantWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return restaurantWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryCreatedAtDateTime) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) Cursor(cursor DateTime) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) In(value []DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) InIfPresent(value []DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.In(value)
}

func (r restaurantQueryCreatedAtDateTime) NotIn(value []DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryCreatedAtDateTime) Lt(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) LtIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryCreatedAtDateTime) Lte(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) LteIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryCreatedAtDateTime) Gt(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) GtIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryCreatedAtDateTime) Gte(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) GteIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryCreatedAtDateTime) Not(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryCreatedAtDateTime) NotIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r restaurantQueryCreatedAtDateTime) Before(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r restaurantQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r restaurantQueryCreatedAtDateTime) After(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r restaurantQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r restaurantQueryCreatedAtDateTime) BeforeEquals(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r restaurantQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r restaurantQueryCreatedAtDateTime) AfterEquals(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r restaurantQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r restaurantQueryCreatedAtDateTime) Field() restaurantPrismaFields {
	return restaurantFieldCreatedAt
}

// base struct
type restaurantQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r restaurantQueryUpdatedAtDateTime) Set(value DateTime) restaurantSetParam {

	return restaurantSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r restaurantQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) restaurantSetParam {
	if value == nil {
		return restaurantSetParam{}
	}

	return r.Set(*value)
}

func (r restaurantQueryUpdatedAtDateTime) Equals(value DateTime) restaurantWithPrismaUpdatedAtEqualsParam {

	return restaurantWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) restaurantWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return restaurantWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r restaurantQueryUpdatedAtDateTime) Order(direction SortOrder) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) Cursor(cursor DateTime) restaurantCursorParam {
	return restaurantCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) In(value []DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) InIfPresent(value []DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.In(value)
}

func (r restaurantQueryUpdatedAtDateTime) NotIn(value []DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.NotIn(value)
}

func (r restaurantQueryUpdatedAtDateTime) Lt(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lt(*value)
}

func (r restaurantQueryUpdatedAtDateTime) Lte(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Lte(*value)
}

func (r restaurantQueryUpdatedAtDateTime) Gt(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gt(*value)
}

func (r restaurantQueryUpdatedAtDateTime) Gte(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Gte(*value)
}

func (r restaurantQueryUpdatedAtDateTime) Not(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r restaurantQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r restaurantQueryUpdatedAtDateTime) Before(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r restaurantQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r restaurantQueryUpdatedAtDateTime) After(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r restaurantQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r restaurantQueryUpdatedAtDateTime) BeforeEquals(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r restaurantQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r restaurantQueryUpdatedAtDateTime) AfterEquals(value DateTime) restaurantDefaultParam {
	return restaurantDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r restaurantQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) restaurantDefaultParam {
	if value == nil {
		return restaurantDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r restaurantQueryUpdatedAtDateTime) Field() restaurantPrismaFields {
	return restaurantFieldUpdatedAt
}

// base struct
type restaurantQueryPostsPost struct{}

type restaurantQueryPostsRelations struct{}

// Restaurant -> Posts
//
// @relation
// @required
func (restaurantQueryPostsRelations) Some(
	params ...PostWhereParam,
) restaurantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return restaurantDefaultParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Restaurant -> Posts
//
// @relation
// @required
func (restaurantQueryPostsRelations) Every(
	params ...PostWhereParam,
) restaurantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return restaurantDefaultParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Restaurant -> Posts
//
// @relation
// @required
func (restaurantQueryPostsRelations) None(
	params ...PostWhereParam,
) restaurantDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return restaurantDefaultParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (restaurantQueryPostsRelations) Fetch(

	params ...PostWhereParam,

) restaurantToPostsFindMany {
	var v restaurantToPostsFindMany

	v.query.Operation = "query"
	v.query.Method = "posts"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r restaurantQueryPostsRelations) Link(
	params ...PostWhereParam,
) restaurantSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return restaurantSetParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r restaurantQueryPostsRelations) Unlink(
	params ...PostWhereParam,
) restaurantSetParam {
	var v restaurantSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = restaurantSetParam{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r restaurantQueryPostsPost) Field() restaurantPrismaFields {
	return restaurantFieldPosts
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "email"},
	{Name: "username"},
	{Name: "password"},
	{Name: "bio"},
	{Name: "avatar"},
	{Name: "firstName"},
	{Name: "lastName"},
	{Name: "Spiciness"},
	{Name: "Sweetness"},
	{Name: "Sourness"},
	{Name: "Type"},
	{Name: "Allergies"},
	{Name: "City"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	emailField()
}

type UserWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailSetParam) userModel() {}

func (p userWithPrismaEmailSetParam) emailField() {}

type UserWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsParam) userModel() {}

func (p userWithPrismaEmailEqualsParam) emailField() {}

func (userWithPrismaEmailSetParam) settable()  {}
func (userWithPrismaEmailEqualsParam) equals() {}

type userWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsUniqueParam) userModel()  {}
func (p userWithPrismaEmailEqualsUniqueParam) emailField() {}

func (userWithPrismaEmailEqualsUniqueParam) unique() {}
func (userWithPrismaEmailEqualsUniqueParam) equals() {}

type UserWithPrismaUsernameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	usernameField()
}

type UserWithPrismaUsernameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	usernameField()
}

type userWithPrismaUsernameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameSetParam) userModel() {}

func (p userWithPrismaUsernameSetParam) usernameField() {}

type UserWithPrismaUsernameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	usernameField()
}

type userWithPrismaUsernameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameEqualsParam) userModel() {}

func (p userWithPrismaUsernameEqualsParam) usernameField() {}

func (userWithPrismaUsernameSetParam) settable()  {}
func (userWithPrismaUsernameEqualsParam) equals() {}

type userWithPrismaUsernameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameEqualsUniqueParam) userModel()     {}
func (p userWithPrismaUsernameEqualsUniqueParam) usernameField() {}

func (userWithPrismaUsernameEqualsUniqueParam) unique() {}
func (userWithPrismaUsernameEqualsUniqueParam) equals() {}

type UserWithPrismaPasswordEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	passwordField()
}

type UserWithPrismaPasswordSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordSetParam) userModel() {}

func (p userWithPrismaPasswordSetParam) passwordField() {}

type UserWithPrismaPasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsParam) userModel() {}

func (p userWithPrismaPasswordEqualsParam) passwordField() {}

func (userWithPrismaPasswordSetParam) settable()  {}
func (userWithPrismaPasswordEqualsParam) equals() {}

type userWithPrismaPasswordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsUniqueParam) userModel()     {}
func (p userWithPrismaPasswordEqualsUniqueParam) passwordField() {}

func (userWithPrismaPasswordEqualsUniqueParam) unique() {}
func (userWithPrismaPasswordEqualsUniqueParam) equals() {}

type UserWithPrismaBioEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	bioField()
}

type UserWithPrismaBioSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	bioField()
}

type userWithPrismaBioSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaBioSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaBioSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaBioSetParam) userModel() {}

func (p userWithPrismaBioSetParam) bioField() {}

type UserWithPrismaBioWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	bioField()
}

type userWithPrismaBioEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaBioEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaBioEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaBioEqualsParam) userModel() {}

func (p userWithPrismaBioEqualsParam) bioField() {}

func (userWithPrismaBioSetParam) settable()  {}
func (userWithPrismaBioEqualsParam) equals() {}

type userWithPrismaBioEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaBioEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaBioEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaBioEqualsUniqueParam) userModel() {}
func (p userWithPrismaBioEqualsUniqueParam) bioField()  {}

func (userWithPrismaBioEqualsUniqueParam) unique() {}
func (userWithPrismaBioEqualsUniqueParam) equals() {}

type UserWithPrismaAvatarEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	avatarField()
}

type UserWithPrismaAvatarSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	avatarField()
}

type userWithPrismaAvatarSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAvatarSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAvatarSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAvatarSetParam) userModel() {}

func (p userWithPrismaAvatarSetParam) avatarField() {}

type UserWithPrismaAvatarWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	avatarField()
}

type userWithPrismaAvatarEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAvatarEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAvatarEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAvatarEqualsParam) userModel() {}

func (p userWithPrismaAvatarEqualsParam) avatarField() {}

func (userWithPrismaAvatarSetParam) settable()  {}
func (userWithPrismaAvatarEqualsParam) equals() {}

type userWithPrismaAvatarEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAvatarEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAvatarEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAvatarEqualsUniqueParam) userModel()   {}
func (p userWithPrismaAvatarEqualsUniqueParam) avatarField() {}

func (userWithPrismaAvatarEqualsUniqueParam) unique() {}
func (userWithPrismaAvatarEqualsUniqueParam) equals() {}

type UserWithPrismaFirstNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	firstNameField()
}

type UserWithPrismaFirstNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameSetParam) userModel() {}

func (p userWithPrismaFirstNameSetParam) firstNameField() {}

type UserWithPrismaFirstNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsParam) userModel() {}

func (p userWithPrismaFirstNameEqualsParam) firstNameField() {}

func (userWithPrismaFirstNameSetParam) settable()  {}
func (userWithPrismaFirstNameEqualsParam) equals() {}

type userWithPrismaFirstNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) userModel()      {}
func (p userWithPrismaFirstNameEqualsUniqueParam) firstNameField() {}

func (userWithPrismaFirstNameEqualsUniqueParam) unique() {}
func (userWithPrismaFirstNameEqualsUniqueParam) equals() {}

type UserWithPrismaLastNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	lastNameField()
}

type UserWithPrismaLastNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	lastNameField()
}

type userWithPrismaLastNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameSetParam) userModel() {}

func (p userWithPrismaLastNameSetParam) lastNameField() {}

type UserWithPrismaLastNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	lastNameField()
}

type userWithPrismaLastNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameEqualsParam) userModel() {}

func (p userWithPrismaLastNameEqualsParam) lastNameField() {}

func (userWithPrismaLastNameSetParam) settable()  {}
func (userWithPrismaLastNameEqualsParam) equals() {}

type userWithPrismaLastNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameEqualsUniqueParam) userModel()     {}
func (p userWithPrismaLastNameEqualsUniqueParam) lastNameField() {}

func (userWithPrismaLastNameEqualsUniqueParam) unique() {}
func (userWithPrismaLastNameEqualsUniqueParam) equals() {}

type UserWithPrismaSpicinessEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	spicinessField()
}

type UserWithPrismaSpicinessSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	spicinessField()
}

type userWithPrismaSpicinessSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSpicinessSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSpicinessSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSpicinessSetParam) userModel() {}

func (p userWithPrismaSpicinessSetParam) spicinessField() {}

type UserWithPrismaSpicinessWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	spicinessField()
}

type userWithPrismaSpicinessEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSpicinessEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSpicinessEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSpicinessEqualsParam) userModel() {}

func (p userWithPrismaSpicinessEqualsParam) spicinessField() {}

func (userWithPrismaSpicinessSetParam) settable()  {}
func (userWithPrismaSpicinessEqualsParam) equals() {}

type userWithPrismaSpicinessEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSpicinessEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSpicinessEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSpicinessEqualsUniqueParam) userModel()      {}
func (p userWithPrismaSpicinessEqualsUniqueParam) spicinessField() {}

func (userWithPrismaSpicinessEqualsUniqueParam) unique() {}
func (userWithPrismaSpicinessEqualsUniqueParam) equals() {}

type UserWithPrismaSweetnessEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	sweetnessField()
}

type UserWithPrismaSweetnessSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	sweetnessField()
}

type userWithPrismaSweetnessSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSweetnessSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSweetnessSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSweetnessSetParam) userModel() {}

func (p userWithPrismaSweetnessSetParam) sweetnessField() {}

type UserWithPrismaSweetnessWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	sweetnessField()
}

type userWithPrismaSweetnessEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSweetnessEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSweetnessEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSweetnessEqualsParam) userModel() {}

func (p userWithPrismaSweetnessEqualsParam) sweetnessField() {}

func (userWithPrismaSweetnessSetParam) settable()  {}
func (userWithPrismaSweetnessEqualsParam) equals() {}

type userWithPrismaSweetnessEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSweetnessEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSweetnessEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSweetnessEqualsUniqueParam) userModel()      {}
func (p userWithPrismaSweetnessEqualsUniqueParam) sweetnessField() {}

func (userWithPrismaSweetnessEqualsUniqueParam) unique() {}
func (userWithPrismaSweetnessEqualsUniqueParam) equals() {}

type UserWithPrismaSournessEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	sournessField()
}

type UserWithPrismaSournessSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	sournessField()
}

type userWithPrismaSournessSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSournessSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSournessSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSournessSetParam) userModel() {}

func (p userWithPrismaSournessSetParam) sournessField() {}

type UserWithPrismaSournessWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	sournessField()
}

type userWithPrismaSournessEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSournessEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSournessEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSournessEqualsParam) userModel() {}

func (p userWithPrismaSournessEqualsParam) sournessField() {}

func (userWithPrismaSournessSetParam) settable()  {}
func (userWithPrismaSournessEqualsParam) equals() {}

type userWithPrismaSournessEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSournessEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSournessEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSournessEqualsUniqueParam) userModel()     {}
func (p userWithPrismaSournessEqualsUniqueParam) sournessField() {}

func (userWithPrismaSournessEqualsUniqueParam) unique() {}
func (userWithPrismaSournessEqualsUniqueParam) equals() {}

type UserWithPrismaTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	typeField()
}

type UserWithPrismaTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	typeField()
}

type userWithPrismaTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTypeSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTypeSetParam) userModel() {}

func (p userWithPrismaTypeSetParam) typeField() {}

type UserWithPrismaTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	typeField()
}

type userWithPrismaTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTypeEqualsParam) userModel() {}

func (p userWithPrismaTypeEqualsParam) typeField() {}

func (userWithPrismaTypeSetParam) settable()  {}
func (userWithPrismaTypeEqualsParam) equals() {}

type userWithPrismaTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTypeEqualsUniqueParam) userModel() {}
func (p userWithPrismaTypeEqualsUniqueParam) typeField() {}

func (userWithPrismaTypeEqualsUniqueParam) unique() {}
func (userWithPrismaTypeEqualsUniqueParam) equals() {}

type UserWithPrismaAllergiesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	allergiesField()
}

type UserWithPrismaAllergiesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	allergiesField()
}

type userWithPrismaAllergiesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAllergiesSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAllergiesSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAllergiesSetParam) userModel() {}

func (p userWithPrismaAllergiesSetParam) allergiesField() {}

type UserWithPrismaAllergiesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	allergiesField()
}

type userWithPrismaAllergiesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAllergiesEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAllergiesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAllergiesEqualsParam) userModel() {}

func (p userWithPrismaAllergiesEqualsParam) allergiesField() {}

func (userWithPrismaAllergiesSetParam) settable()  {}
func (userWithPrismaAllergiesEqualsParam) equals() {}

type userWithPrismaAllergiesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAllergiesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAllergiesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAllergiesEqualsUniqueParam) userModel()      {}
func (p userWithPrismaAllergiesEqualsUniqueParam) allergiesField() {}

func (userWithPrismaAllergiesEqualsUniqueParam) unique() {}
func (userWithPrismaAllergiesEqualsUniqueParam) equals() {}

type UserWithPrismaCityEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	cityField()
}

type UserWithPrismaCitySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	cityField()
}

type userWithPrismaCitySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCitySetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCitySetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCitySetParam) userModel() {}

func (p userWithPrismaCitySetParam) cityField() {}

type UserWithPrismaCityWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	cityField()
}

type userWithPrismaCityEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCityEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCityEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCityEqualsParam) userModel() {}

func (p userWithPrismaCityEqualsParam) cityField() {}

func (userWithPrismaCitySetParam) settable()  {}
func (userWithPrismaCityEqualsParam) equals() {}

type userWithPrismaCityEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCityEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCityEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCityEqualsUniqueParam) userModel() {}
func (p userWithPrismaCityEqualsUniqueParam) cityField() {}

func (userWithPrismaCityEqualsUniqueParam) unique() {}
func (userWithPrismaCityEqualsUniqueParam) equals() {}

type UserWithPrismaPostsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	postsField()
}

type UserWithPrismaPostsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	postsField()
}

type userWithPrismaPostsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPostsSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPostsSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPostsSetParam) userModel() {}

func (p userWithPrismaPostsSetParam) postsField() {}

type UserWithPrismaPostsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	postsField()
}

type userWithPrismaPostsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPostsEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPostsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPostsEqualsParam) userModel() {}

func (p userWithPrismaPostsEqualsParam) postsField() {}

func (userWithPrismaPostsSetParam) settable()  {}
func (userWithPrismaPostsEqualsParam) equals() {}

type userWithPrismaPostsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPostsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPostsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPostsEqualsUniqueParam) userModel()  {}
func (p userWithPrismaPostsEqualsUniqueParam) postsField() {}

func (userWithPrismaPostsEqualsUniqueParam) unique() {}
func (userWithPrismaPostsEqualsUniqueParam) equals() {}

type UserWithPrismaLikesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	likesField()
}

type UserWithPrismaLikesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	likesField()
}

type userWithPrismaLikesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLikesSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLikesSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLikesSetParam) userModel() {}

func (p userWithPrismaLikesSetParam) likesField() {}

type UserWithPrismaLikesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	likesField()
}

type userWithPrismaLikesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLikesEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLikesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLikesEqualsParam) userModel() {}

func (p userWithPrismaLikesEqualsParam) likesField() {}

func (userWithPrismaLikesSetParam) settable()  {}
func (userWithPrismaLikesEqualsParam) equals() {}

type userWithPrismaLikesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLikesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLikesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLikesEqualsUniqueParam) userModel()  {}
func (p userWithPrismaLikesEqualsUniqueParam) likesField() {}

func (userWithPrismaLikesEqualsUniqueParam) unique() {}
func (userWithPrismaLikesEqualsUniqueParam) equals() {}

type UserWithPrismaCommentsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	commentsField()
}

type UserWithPrismaCommentsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	commentsField()
}

type userWithPrismaCommentsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsSetParam) userModel() {}

func (p userWithPrismaCommentsSetParam) commentsField() {}

type UserWithPrismaCommentsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	commentsField()
}

type userWithPrismaCommentsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsEqualsParam) userModel() {}

func (p userWithPrismaCommentsEqualsParam) commentsField() {}

func (userWithPrismaCommentsSetParam) settable()  {}
func (userWithPrismaCommentsEqualsParam) equals() {}

type userWithPrismaCommentsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsEqualsUniqueParam) userModel()     {}
func (p userWithPrismaCommentsEqualsUniqueParam) commentsField() {}

func (userWithPrismaCommentsEqualsUniqueParam) unique() {}
func (userWithPrismaCommentsEqualsUniqueParam) equals() {}

type UserWithPrismaFollowersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	followersField()
}

type UserWithPrismaFollowersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	followersField()
}

type userWithPrismaFollowersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFollowersSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFollowersSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFollowersSetParam) userModel() {}

func (p userWithPrismaFollowersSetParam) followersField() {}

type UserWithPrismaFollowersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	followersField()
}

type userWithPrismaFollowersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFollowersEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFollowersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFollowersEqualsParam) userModel() {}

func (p userWithPrismaFollowersEqualsParam) followersField() {}

func (userWithPrismaFollowersSetParam) settable()  {}
func (userWithPrismaFollowersEqualsParam) equals() {}

type userWithPrismaFollowersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFollowersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFollowersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFollowersEqualsUniqueParam) userModel()      {}
func (p userWithPrismaFollowersEqualsUniqueParam) followersField() {}

func (userWithPrismaFollowersEqualsUniqueParam) unique() {}
func (userWithPrismaFollowersEqualsUniqueParam) equals() {}

type UserWithPrismaFollowingEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	followingField()
}

type UserWithPrismaFollowingSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	followingField()
}

type userWithPrismaFollowingSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFollowingSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFollowingSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFollowingSetParam) userModel() {}

func (p userWithPrismaFollowingSetParam) followingField() {}

type UserWithPrismaFollowingWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	followingField()
}

type userWithPrismaFollowingEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFollowingEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFollowingEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFollowingEqualsParam) userModel() {}

func (p userWithPrismaFollowingEqualsParam) followingField() {}

func (userWithPrismaFollowingSetParam) settable()  {}
func (userWithPrismaFollowingEqualsParam) equals() {}

type userWithPrismaFollowingEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFollowingEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFollowingEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFollowingEqualsUniqueParam) userModel()      {}
func (p userWithPrismaFollowingEqualsUniqueParam) followingField() {}

func (userWithPrismaFollowingEqualsUniqueParam) unique() {}
func (userWithPrismaFollowingEqualsUniqueParam) equals() {}

type UserWithPrismaTagEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	tagField()
}

type UserWithPrismaTagSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	tagField()
}

type userWithPrismaTagSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTagSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTagSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTagSetParam) userModel() {}

func (p userWithPrismaTagSetParam) tagField() {}

type UserWithPrismaTagWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	tagField()
}

type userWithPrismaTagEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTagEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTagEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTagEqualsParam) userModel() {}

func (p userWithPrismaTagEqualsParam) tagField() {}

func (userWithPrismaTagSetParam) settable()  {}
func (userWithPrismaTagEqualsParam) equals() {}

type userWithPrismaTagEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTagEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTagEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTagEqualsUniqueParam) userModel() {}
func (p userWithPrismaTagEqualsUniqueParam) tagField()  {}

func (userWithPrismaTagEqualsUniqueParam) unique() {}
func (userWithPrismaTagEqualsUniqueParam) equals() {}

type postActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var postOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "title"},
	{Name: "description"},
	{Name: "longitude"},
	{Name: "latitude"},
	{Name: "Cuisine"},
	{Name: "Dish"},
	{Name: "Type"},
	{Name: "Spiciness"},
	{Name: "Sweetness"},
	{Name: "Sourness"},
	{Name: "pictures"},
	{Name: "userId"},
	{Name: "city"},
	{Name: "restaurantId"},
	{Name: "originalPostId"},
}

type PostRelationWith interface {
	getQuery() builder.Query
	with()
	postRelation()
}

type PostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p postDefaultParam) field() builder.Field {
	return p.data
}

func (p postDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p postDefaultParam) postModel() {}

type PostOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p postOrderByParam) field() builder.Field {
	return p.data
}

func (p postOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p postOrderByParam) postModel() {}

type PostCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	isCursor()
}

type postCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p postCursorParam) field() builder.Field {
	return p.data
}

func (p postCursorParam) isCursor() {}

func (p postCursorParam) getQuery() builder.Query {
	return p.query
}

func (p postCursorParam) postModel() {}

type PostParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	postModel()
}

type postParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p postParamUnique) postModel() {}

func (postParamUnique) unique() {}

func (p postParamUnique) field() builder.Field {
	return p.data
}

func (p postParamUnique) getQuery() builder.Query {
	return p.query
}

type PostEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
}

type postEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postEqualsParam) postModel() {}

func (postEqualsParam) equals() {}

func (p postEqualsParam) field() builder.Field {
	return p.data
}

func (p postEqualsParam) getQuery() builder.Query {
	return p.query
}

type PostEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	postModel()
}

type postEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postEqualsUniqueParam) postModel() {}

func (postEqualsUniqueParam) unique() {}
func (postEqualsUniqueParam) equals() {}

func (p postEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type PostSetParam interface {
	field() builder.Field
	settable()
	postModel()
}

type postSetParam struct {
	data builder.Field
}

func (p postSetParam) titleField() {
	//TODO implement me
	panic("implement me")
}

func (p postSetParam) getQuery() builder.Query {
	//TODO implement me
	panic("implement me")
}

func (p postSetParam) cityField() {
	//TODO implement me
	panic("implement me")
}

func (postSetParam) settable() {}

func (p postSetParam) field() builder.Field {
	return p.data
}

func (p postSetParam) postModel() {}

type PostWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	idField()
}

type PostWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	idField()
}

type postWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDSetParam) postModel() {}

func (p postWithPrismaIDSetParam) idField() {}

type PostWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	idField()
}

type postWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDEqualsParam) postModel() {}

func (p postWithPrismaIDEqualsParam) idField() {}

func (postWithPrismaIDSetParam) settable()  {}
func (postWithPrismaIDEqualsParam) equals() {}

type postWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaIDEqualsUniqueParam) postModel() {}
func (p postWithPrismaIDEqualsUniqueParam) idField()   {}

func (postWithPrismaIDEqualsUniqueParam) unique() {}
func (postWithPrismaIDEqualsUniqueParam) equals() {}

type PostWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	createdAtField()
}

type PostWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	createdAtField()
}

type postWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtSetParam) postModel() {}

func (p postWithPrismaCreatedAtSetParam) createdAtField() {}

type PostWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	createdAtField()
}

type postWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtEqualsParam) postModel() {}

func (p postWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (postWithPrismaCreatedAtSetParam) settable()  {}
func (postWithPrismaCreatedAtEqualsParam) equals() {}

type postWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCreatedAtEqualsUniqueParam) postModel()      {}
func (p postWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (postWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (postWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type PostWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	updatedAtField()
}

type PostWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	updatedAtField()
}

type postWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUpdatedAtSetParam) postModel() {}

func (p postWithPrismaUpdatedAtSetParam) updatedAtField() {}

type PostWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	updatedAtField()
}

type postWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUpdatedAtEqualsParam) postModel() {}

func (p postWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (postWithPrismaUpdatedAtSetParam) settable()  {}
func (postWithPrismaUpdatedAtEqualsParam) equals() {}

type postWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUpdatedAtEqualsUniqueParam) postModel()      {}
func (p postWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (postWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (postWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type PostWithPrismaTitleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	titleField()
}

type PostWithPrismaTitleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	titleField()
}

type postWithPrismaTitleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTitleSetParam) descriptionField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaTitleSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTitleSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTitleSetParam) postModel() {}

func (p postWithPrismaTitleSetParam) titleField() {}

type PostWithPrismaTitleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	titleField()
}

type postWithPrismaTitleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTitleEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTitleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTitleEqualsParam) postModel() {}

func (p postWithPrismaTitleEqualsParam) titleField() {}

func (postWithPrismaTitleSetParam) settable()  {}
func (postWithPrismaTitleEqualsParam) equals() {}

type postWithPrismaTitleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTitleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTitleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTitleEqualsUniqueParam) postModel()  {}
func (p postWithPrismaTitleEqualsUniqueParam) titleField() {}

func (postWithPrismaTitleEqualsUniqueParam) unique() {}
func (postWithPrismaTitleEqualsUniqueParam) equals() {}

type PostWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	descriptionField()
}

type PostWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	descriptionField()
}

type postWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaDescriptionSetParam) longitudeField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaDescriptionSetParam) postModel() {}

func (p postWithPrismaDescriptionSetParam) descriptionField() {}

type PostWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	descriptionField()
}

type postWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaDescriptionEqualsParam) postModel() {}

func (p postWithPrismaDescriptionEqualsParam) descriptionField() {}

func (postWithPrismaDescriptionSetParam) settable()  {}
func (postWithPrismaDescriptionEqualsParam) equals() {}

type postWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaDescriptionEqualsUniqueParam) postModel()        {}
func (p postWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (postWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (postWithPrismaDescriptionEqualsUniqueParam) equals() {}

type PostWithPrismaLongitudeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	longitudeField()
}

type PostWithPrismaLongitudeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	longitudeField()
}

type postWithPrismaLongitudeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLongitudeSetParam) latitudeField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaLongitudeSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLongitudeSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLongitudeSetParam) postModel() {}

func (p postWithPrismaLongitudeSetParam) longitudeField() {}

type PostWithPrismaLongitudeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	longitudeField()
}

type postWithPrismaLongitudeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLongitudeEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLongitudeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLongitudeEqualsParam) postModel() {}

func (p postWithPrismaLongitudeEqualsParam) longitudeField() {}

func (postWithPrismaLongitudeSetParam) settable()  {}
func (postWithPrismaLongitudeEqualsParam) equals() {}

type postWithPrismaLongitudeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLongitudeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLongitudeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLongitudeEqualsUniqueParam) postModel()      {}
func (p postWithPrismaLongitudeEqualsUniqueParam) longitudeField() {}

func (postWithPrismaLongitudeEqualsUniqueParam) unique() {}
func (postWithPrismaLongitudeEqualsUniqueParam) equals() {}

type PostWithPrismaLatitudeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	latitudeField()
}

type PostWithPrismaLatitudeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	latitudeField()
}

type postWithPrismaLatitudeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLatitudeSetParam) cuisineField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaLatitudeSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLatitudeSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLatitudeSetParam) postModel() {}

func (p postWithPrismaLatitudeSetParam) latitudeField() {}

type PostWithPrismaLatitudeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	latitudeField()
}

type postWithPrismaLatitudeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLatitudeEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLatitudeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLatitudeEqualsParam) postModel() {}

func (p postWithPrismaLatitudeEqualsParam) latitudeField() {}

func (postWithPrismaLatitudeSetParam) settable()  {}
func (postWithPrismaLatitudeEqualsParam) equals() {}

type postWithPrismaLatitudeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLatitudeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLatitudeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLatitudeEqualsUniqueParam) postModel()     {}
func (p postWithPrismaLatitudeEqualsUniqueParam) latitudeField() {}

func (postWithPrismaLatitudeEqualsUniqueParam) unique() {}
func (postWithPrismaLatitudeEqualsUniqueParam) equals() {}

type PostWithPrismaCuisineEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	cuisineField()
}

type PostWithPrismaCuisineSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	cuisineField()
}

type postWithPrismaCuisineSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCuisineSetParam) sweetnessField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaCuisineSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCuisineSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCuisineSetParam) postModel() {}

func (p postWithPrismaCuisineSetParam) cuisineField() {}

type PostWithPrismaCuisineWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	cuisineField()
}

type postWithPrismaCuisineEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCuisineEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCuisineEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCuisineEqualsParam) postModel() {}

func (p postWithPrismaCuisineEqualsParam) cuisineField() {}

func (postWithPrismaCuisineSetParam) settable()  {}
func (postWithPrismaCuisineEqualsParam) equals() {}

type postWithPrismaCuisineEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCuisineEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCuisineEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCuisineEqualsUniqueParam) postModel()    {}
func (p postWithPrismaCuisineEqualsUniqueParam) cuisineField() {}

func (postWithPrismaCuisineEqualsUniqueParam) unique() {}
func (postWithPrismaCuisineEqualsUniqueParam) equals() {}

type PostWithPrismaDishEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	dishField()
}

type PostWithPrismaDishSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	dishField()
}

type postWithPrismaDishSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaDishSetParam) sournessField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaDishSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaDishSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaDishSetParam) postModel() {}

func (p postWithPrismaDishSetParam) dishField() {}

type PostWithPrismaDishWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	dishField()
}

type postWithPrismaDishEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaDishEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaDishEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaDishEqualsParam) postModel() {}

func (p postWithPrismaDishEqualsParam) dishField() {}

func (postWithPrismaDishSetParam) settable()  {}
func (postWithPrismaDishEqualsParam) equals() {}

type postWithPrismaDishEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaDishEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaDishEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaDishEqualsUniqueParam) postModel() {}
func (p postWithPrismaDishEqualsUniqueParam) dishField() {}

func (postWithPrismaDishEqualsUniqueParam) unique() {}
func (postWithPrismaDishEqualsUniqueParam) equals() {}

type PostWithPrismaTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	typeField()
}

type PostWithPrismaTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	typeField()
}

type postWithPrismaTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTypeSetParam) spicinessField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaTypeSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTypeSetParam) postModel() {}

func (p postWithPrismaTypeSetParam) typeField() {}

type PostWithPrismaTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	typeField()
}

type postWithPrismaTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTypeEqualsParam) postModel() {}

func (p postWithPrismaTypeEqualsParam) typeField() {}

func (postWithPrismaTypeSetParam) settable()  {}
func (postWithPrismaTypeEqualsParam) equals() {}

type postWithPrismaTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTypeEqualsUniqueParam) postModel() {}
func (p postWithPrismaTypeEqualsUniqueParam) typeField() {}

func (postWithPrismaTypeEqualsUniqueParam) unique() {}
func (postWithPrismaTypeEqualsUniqueParam) equals() {}

type PostWithPrismaSpicinessEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	spicinessField()
}

type PostWithPrismaSpicinessSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	spicinessField()
}

type postWithPrismaSpicinessSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSpicinessSetParam) picturesField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaSpicinessSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSpicinessSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSpicinessSetParam) postModel() {}

func (p postWithPrismaSpicinessSetParam) spicinessField() {}

type PostWithPrismaSpicinessWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	spicinessField()
}

type postWithPrismaSpicinessEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSpicinessEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSpicinessEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSpicinessEqualsParam) postModel() {}

func (p postWithPrismaSpicinessEqualsParam) spicinessField() {}

func (postWithPrismaSpicinessSetParam) settable()  {}
func (postWithPrismaSpicinessEqualsParam) equals() {}

type postWithPrismaSpicinessEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSpicinessEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSpicinessEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSpicinessEqualsUniqueParam) postModel()      {}
func (p postWithPrismaSpicinessEqualsUniqueParam) spicinessField() {}

func (postWithPrismaSpicinessEqualsUniqueParam) unique() {}
func (postWithPrismaSpicinessEqualsUniqueParam) equals() {}

type PostWithPrismaSweetnessEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	sweetnessField()
}

type PostWithPrismaSweetnessSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	sweetnessField()
}

type postWithPrismaSweetnessSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSweetnessSetParam) cityField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaSweetnessSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSweetnessSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSweetnessSetParam) postModel() {}

func (p postWithPrismaSweetnessSetParam) sweetnessField() {}

type PostWithPrismaSweetnessWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	sweetnessField()
}

type postWithPrismaSweetnessEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSweetnessEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSweetnessEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSweetnessEqualsParam) postModel() {}

func (p postWithPrismaSweetnessEqualsParam) sweetnessField() {}

func (postWithPrismaSweetnessSetParam) settable()  {}
func (postWithPrismaSweetnessEqualsParam) equals() {}

type postWithPrismaSweetnessEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSweetnessEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSweetnessEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSweetnessEqualsUniqueParam) postModel()      {}
func (p postWithPrismaSweetnessEqualsUniqueParam) sweetnessField() {}

func (postWithPrismaSweetnessEqualsUniqueParam) unique() {}
func (postWithPrismaSweetnessEqualsUniqueParam) equals() {}

type PostWithPrismaSournessEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	sournessField()
}

type PostWithPrismaSournessSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	sournessField()
}

type postWithPrismaSournessSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSournessSetParam) userField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaSournessSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSournessSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSournessSetParam) postModel() {}

func (p postWithPrismaSournessSetParam) sournessField() {}

type PostWithPrismaSournessWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	sournessField()
}

type postWithPrismaSournessEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSournessEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSournessEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSournessEqualsParam) postModel() {}

func (p postWithPrismaSournessEqualsParam) sournessField() {}

func (postWithPrismaSournessSetParam) settable()  {}
func (postWithPrismaSournessEqualsParam) equals() {}

type postWithPrismaSournessEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaSournessEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaSournessEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaSournessEqualsUniqueParam) postModel()     {}
func (p postWithPrismaSournessEqualsUniqueParam) sournessField() {}

func (postWithPrismaSournessEqualsUniqueParam) unique() {}
func (postWithPrismaSournessEqualsUniqueParam) equals() {}

type PostWithPrismaPicturesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	picturesField()
}

type PostWithPrismaPicturesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	picturesField()
}

type postWithPrismaPicturesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaPicturesSetParam) dishField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaPicturesSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaPicturesSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaPicturesSetParam) postModel() {}

func (p postWithPrismaPicturesSetParam) picturesField() {}

type PostWithPrismaPicturesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	picturesField()
}

type postWithPrismaPicturesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaPicturesEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaPicturesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaPicturesEqualsParam) postModel() {}

func (p postWithPrismaPicturesEqualsParam) picturesField() {}

func (postWithPrismaPicturesSetParam) settable()  {}
func (postWithPrismaPicturesEqualsParam) equals() {}

type postWithPrismaPicturesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaPicturesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaPicturesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaPicturesEqualsUniqueParam) postModel()     {}
func (p postWithPrismaPicturesEqualsUniqueParam) picturesField() {}

func (postWithPrismaPicturesEqualsUniqueParam) unique() {}
func (postWithPrismaPicturesEqualsUniqueParam) equals() {}

type PostWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	userIDField()
}

type PostWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	userIDField()
}

type postWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUserIDSetParam) postModel() {}

func (p postWithPrismaUserIDSetParam) userIDField() {}

type PostWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	userIDField()
}

type postWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUserIDEqualsParam) postModel() {}

func (p postWithPrismaUserIDEqualsParam) userIDField() {}

func (postWithPrismaUserIDSetParam) settable()  {}
func (postWithPrismaUserIDEqualsParam) equals() {}

type postWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUserIDEqualsUniqueParam) postModel()   {}
func (p postWithPrismaUserIDEqualsUniqueParam) userIDField() {}

func (postWithPrismaUserIDEqualsUniqueParam) unique() {}
func (postWithPrismaUserIDEqualsUniqueParam) equals() {}

type PostWithPrismaCityEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	cityField()
}

type PostWithPrismaCitySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	cityField()
}

type postWithPrismaCitySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCitySetParam) typeField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaCitySetParam) userField() {
	//TODO implement me
	panic("implement me")
}

func (p postWithPrismaCitySetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCitySetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCitySetParam) postModel() {}

func (p postWithPrismaCitySetParam) cityField() {}

type PostWithPrismaCityWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	cityField()
}

type postWithPrismaCityEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCityEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCityEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCityEqualsParam) postModel() {}

func (p postWithPrismaCityEqualsParam) cityField() {}

func (postWithPrismaCitySetParam) settable()  {}
func (postWithPrismaCityEqualsParam) equals() {}

type postWithPrismaCityEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCityEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCityEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCityEqualsUniqueParam) postModel() {}
func (p postWithPrismaCityEqualsUniqueParam) cityField() {}

func (postWithPrismaCityEqualsUniqueParam) unique() {}
func (postWithPrismaCityEqualsUniqueParam) equals() {}

type PostWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	userField()
}

type PostWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	userField()
}

type postWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUserSetParam) postModel() {}

func (p postWithPrismaUserSetParam) userField() {}

type PostWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	userField()
}

type postWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUserEqualsParam) postModel() {}

func (p postWithPrismaUserEqualsParam) userField() {}

func (postWithPrismaUserSetParam) settable()  {}
func (postWithPrismaUserEqualsParam) equals() {}

type postWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaUserEqualsUniqueParam) postModel() {}
func (p postWithPrismaUserEqualsUniqueParam) userField() {}

func (postWithPrismaUserEqualsUniqueParam) unique() {}
func (postWithPrismaUserEqualsUniqueParam) equals() {}

type PostWithPrismaLikesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	likesField()
}

type PostWithPrismaLikesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	likesField()
}

type postWithPrismaLikesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLikesSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLikesSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLikesSetParam) postModel() {}

func (p postWithPrismaLikesSetParam) likesField() {}

type PostWithPrismaLikesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	likesField()
}

type postWithPrismaLikesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLikesEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLikesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLikesEqualsParam) postModel() {}

func (p postWithPrismaLikesEqualsParam) likesField() {}

func (postWithPrismaLikesSetParam) settable()  {}
func (postWithPrismaLikesEqualsParam) equals() {}

type postWithPrismaLikesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaLikesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaLikesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaLikesEqualsUniqueParam) postModel()  {}
func (p postWithPrismaLikesEqualsUniqueParam) likesField() {}

func (postWithPrismaLikesEqualsUniqueParam) unique() {}
func (postWithPrismaLikesEqualsUniqueParam) equals() {}

type PostWithPrismaCommentsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	commentsField()
}

type PostWithPrismaCommentsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	commentsField()
}

type postWithPrismaCommentsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCommentsSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCommentsSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCommentsSetParam) postModel() {}

func (p postWithPrismaCommentsSetParam) commentsField() {}

type PostWithPrismaCommentsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	commentsField()
}

type postWithPrismaCommentsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCommentsEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCommentsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCommentsEqualsParam) postModel() {}

func (p postWithPrismaCommentsEqualsParam) commentsField() {}

func (postWithPrismaCommentsSetParam) settable()  {}
func (postWithPrismaCommentsEqualsParam) equals() {}

type postWithPrismaCommentsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaCommentsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaCommentsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaCommentsEqualsUniqueParam) postModel()     {}
func (p postWithPrismaCommentsEqualsUniqueParam) commentsField() {}

func (postWithPrismaCommentsEqualsUniqueParam) unique() {}
func (postWithPrismaCommentsEqualsUniqueParam) equals() {}

type PostWithPrismaTagsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	tagsField()
}

type PostWithPrismaTagsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	tagsField()
}

type postWithPrismaTagsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTagsSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTagsSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTagsSetParam) postModel() {}

func (p postWithPrismaTagsSetParam) tagsField() {}

type PostWithPrismaTagsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	tagsField()
}

type postWithPrismaTagsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTagsEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTagsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTagsEqualsParam) postModel() {}

func (p postWithPrismaTagsEqualsParam) tagsField() {}

func (postWithPrismaTagsSetParam) settable()  {}
func (postWithPrismaTagsEqualsParam) equals() {}

type postWithPrismaTagsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaTagsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaTagsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaTagsEqualsUniqueParam) postModel() {}
func (p postWithPrismaTagsEqualsUniqueParam) tagsField() {}

func (postWithPrismaTagsEqualsUniqueParam) unique() {}
func (postWithPrismaTagsEqualsUniqueParam) equals() {}

type PostWithPrismaRestaurantIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	restaurantIDField()
}

type PostWithPrismaRestaurantIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	restaurantIDField()
}

type postWithPrismaRestaurantIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRestaurantIDSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRestaurantIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRestaurantIDSetParam) postModel() {}

func (p postWithPrismaRestaurantIDSetParam) restaurantIDField() {}

type PostWithPrismaRestaurantIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	restaurantIDField()
}

type postWithPrismaRestaurantIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRestaurantIDEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRestaurantIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRestaurantIDEqualsParam) postModel() {}

func (p postWithPrismaRestaurantIDEqualsParam) restaurantIDField() {}

func (postWithPrismaRestaurantIDSetParam) settable()  {}
func (postWithPrismaRestaurantIDEqualsParam) equals() {}

type postWithPrismaRestaurantIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRestaurantIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRestaurantIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRestaurantIDEqualsUniqueParam) postModel()         {}
func (p postWithPrismaRestaurantIDEqualsUniqueParam) restaurantIDField() {}

func (postWithPrismaRestaurantIDEqualsUniqueParam) unique() {}
func (postWithPrismaRestaurantIDEqualsUniqueParam) equals() {}

type PostWithPrismaRestaurantEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	restaurantField()
}

type PostWithPrismaRestaurantSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	restaurantField()
}

type postWithPrismaRestaurantSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRestaurantSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRestaurantSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRestaurantSetParam) postModel() {}

func (p postWithPrismaRestaurantSetParam) restaurantField() {}

type PostWithPrismaRestaurantWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	restaurantField()
}

type postWithPrismaRestaurantEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRestaurantEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRestaurantEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRestaurantEqualsParam) postModel() {}

func (p postWithPrismaRestaurantEqualsParam) restaurantField() {}

func (postWithPrismaRestaurantSetParam) settable()  {}
func (postWithPrismaRestaurantEqualsParam) equals() {}

type postWithPrismaRestaurantEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRestaurantEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRestaurantEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRestaurantEqualsUniqueParam) postModel()       {}
func (p postWithPrismaRestaurantEqualsUniqueParam) restaurantField() {}

func (postWithPrismaRestaurantEqualsUniqueParam) unique() {}
func (postWithPrismaRestaurantEqualsUniqueParam) equals() {}

type PostWithPrismaOriginalPostEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	originalPostField()
}

type PostWithPrismaOriginalPostSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	originalPostField()
}

type postWithPrismaOriginalPostSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaOriginalPostSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaOriginalPostSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaOriginalPostSetParam) postModel() {}

func (p postWithPrismaOriginalPostSetParam) originalPostField() {}

type PostWithPrismaOriginalPostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	originalPostField()
}

type postWithPrismaOriginalPostEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaOriginalPostEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaOriginalPostEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaOriginalPostEqualsParam) postModel() {}

func (p postWithPrismaOriginalPostEqualsParam) originalPostField() {}

func (postWithPrismaOriginalPostSetParam) settable()  {}
func (postWithPrismaOriginalPostEqualsParam) equals() {}

type postWithPrismaOriginalPostEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaOriginalPostEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaOriginalPostEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaOriginalPostEqualsUniqueParam) postModel()         {}
func (p postWithPrismaOriginalPostEqualsUniqueParam) originalPostField() {}

func (postWithPrismaOriginalPostEqualsUniqueParam) unique() {}
func (postWithPrismaOriginalPostEqualsUniqueParam) equals() {}

type PostWithPrismaOriginalPostIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	originalPostIDField()
}

type PostWithPrismaOriginalPostIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	originalPostIDField()
}

type postWithPrismaOriginalPostIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaOriginalPostIDSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaOriginalPostIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaOriginalPostIDSetParam) postModel() {}

func (p postWithPrismaOriginalPostIDSetParam) originalPostIDField() {}

type PostWithPrismaOriginalPostIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	originalPostIDField()
}

type postWithPrismaOriginalPostIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaOriginalPostIDEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaOriginalPostIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaOriginalPostIDEqualsParam) postModel() {}

func (p postWithPrismaOriginalPostIDEqualsParam) originalPostIDField() {}

func (postWithPrismaOriginalPostIDSetParam) settable()  {}
func (postWithPrismaOriginalPostIDEqualsParam) equals() {}

type postWithPrismaOriginalPostIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaOriginalPostIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaOriginalPostIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaOriginalPostIDEqualsUniqueParam) postModel()           {}
func (p postWithPrismaOriginalPostIDEqualsUniqueParam) originalPostIDField() {}

func (postWithPrismaOriginalPostIDEqualsUniqueParam) unique() {}
func (postWithPrismaOriginalPostIDEqualsUniqueParam) equals() {}

type PostWithPrismaRepostedPostsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	postModel()
	repostedPostsField()
}

type PostWithPrismaRepostedPostsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	repostedPostsField()
}

type postWithPrismaRepostedPostsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRepostedPostsSetParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRepostedPostsSetParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRepostedPostsSetParam) postModel() {}

func (p postWithPrismaRepostedPostsSetParam) repostedPostsField() {}

type PostWithPrismaRepostedPostsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	repostedPostsField()
}

type postWithPrismaRepostedPostsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRepostedPostsEqualsParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRepostedPostsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRepostedPostsEqualsParam) postModel() {}

func (p postWithPrismaRepostedPostsEqualsParam) repostedPostsField() {}

func (postWithPrismaRepostedPostsSetParam) settable()  {}
func (postWithPrismaRepostedPostsEqualsParam) equals() {}

type postWithPrismaRepostedPostsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p postWithPrismaRepostedPostsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p postWithPrismaRepostedPostsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p postWithPrismaRepostedPostsEqualsUniqueParam) postModel()          {}
func (p postWithPrismaRepostedPostsEqualsUniqueParam) repostedPostsField() {}

func (postWithPrismaRepostedPostsEqualsUniqueParam) unique() {}
func (postWithPrismaRepostedPostsEqualsUniqueParam) equals() {}

type commentActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var commentOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "content"},
	{Name: "postId"},
	{Name: "userId"},
}

type CommentRelationWith interface {
	getQuery() builder.Query
	with()
	commentRelation()
}

type CommentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
}

type commentDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentDefaultParam) field() builder.Field {
	return p.data
}

func (p commentDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p commentDefaultParam) commentModel() {}

type CommentOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
}

type commentOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentOrderByParam) field() builder.Field {
	return p.data
}

func (p commentOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p commentOrderByParam) commentModel() {}

type CommentCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	isCursor()
}

type commentCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentCursorParam) field() builder.Field {
	return p.data
}

func (p commentCursorParam) isCursor() {}

func (p commentCursorParam) getQuery() builder.Query {
	return p.query
}

func (p commentCursorParam) commentModel() {}

type CommentParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	commentModel()
}

type commentParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p commentParamUnique) commentModel() {}

func (commentParamUnique) unique() {}

func (p commentParamUnique) field() builder.Field {
	return p.data
}

func (p commentParamUnique) getQuery() builder.Query {
	return p.query
}

type CommentEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
}

type commentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentEqualsParam) commentModel() {}

func (commentEqualsParam) equals() {}

func (p commentEqualsParam) field() builder.Field {
	return p.data
}

func (p commentEqualsParam) getQuery() builder.Query {
	return p.query
}

type CommentEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	commentModel()
}

type commentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentEqualsUniqueParam) commentModel() {}

func (commentEqualsUniqueParam) unique() {}
func (commentEqualsUniqueParam) equals() {}

func (p commentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type CommentSetParam interface {
	field() builder.Field
	settable()
	commentModel()
}

type commentSetParam struct {
	data builder.Field
}

func (p commentSetParam) userField() {
	//TODO implement me
	panic("implement me")
}

func (p commentSetParam) getQuery() builder.Query {
	//TODO implement me
	panic("implement me")
}

func (p commentSetParam) postField() {
	//TODO implement me
	panic("implement me")
}

func (commentSetParam) settable() {}

func (p commentSetParam) field() builder.Field {
	return p.data
}

func (p commentSetParam) commentModel() {}

type CommentWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	idField()
}

type CommentWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	idField()
}

type commentWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaIDSetParam) commentModel() {}

func (p commentWithPrismaIDSetParam) idField() {}

type CommentWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	idField()
}

type commentWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaIDEqualsParam) commentModel() {}

func (p commentWithPrismaIDEqualsParam) idField() {}

func (commentWithPrismaIDSetParam) settable()  {}
func (commentWithPrismaIDEqualsParam) equals() {}

type commentWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaIDEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaIDEqualsUniqueParam) idField()      {}

func (commentWithPrismaIDEqualsUniqueParam) unique() {}
func (commentWithPrismaIDEqualsUniqueParam) equals() {}

type CommentWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	createdAtField()
}

type CommentWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	createdAtField()
}

type commentWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaCreatedAtSetParam) commentModel() {}

func (p commentWithPrismaCreatedAtSetParam) createdAtField() {}

type CommentWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	createdAtField()
}

type commentWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaCreatedAtEqualsParam) commentModel() {}

func (p commentWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (commentWithPrismaCreatedAtSetParam) settable()  {}
func (commentWithPrismaCreatedAtEqualsParam) equals() {}

type commentWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaCreatedAtEqualsUniqueParam) commentModel()   {}
func (p commentWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (commentWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (commentWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type CommentWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	updatedAtField()
}

type CommentWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	updatedAtField()
}

type commentWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUpdatedAtSetParam) commentModel() {}

func (p commentWithPrismaUpdatedAtSetParam) updatedAtField() {}

type CommentWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	updatedAtField()
}

type commentWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUpdatedAtEqualsParam) commentModel() {}

func (p commentWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (commentWithPrismaUpdatedAtSetParam) settable()  {}
func (commentWithPrismaUpdatedAtEqualsParam) equals() {}

type commentWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUpdatedAtEqualsUniqueParam) commentModel()   {}
func (p commentWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (commentWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (commentWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type CommentWithPrismaContentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	contentField()
}

type CommentWithPrismaContentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	contentField()
}

type commentWithPrismaContentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaContentSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaContentSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaContentSetParam) commentModel() {}

func (p commentWithPrismaContentSetParam) contentField() {}

type CommentWithPrismaContentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	contentField()
}

type commentWithPrismaContentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaContentEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaContentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaContentEqualsParam) commentModel() {}

func (p commentWithPrismaContentEqualsParam) contentField() {}

func (commentWithPrismaContentSetParam) settable()  {}
func (commentWithPrismaContentEqualsParam) equals() {}

type commentWithPrismaContentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaContentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaContentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaContentEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaContentEqualsUniqueParam) contentField() {}

func (commentWithPrismaContentEqualsUniqueParam) unique() {}
func (commentWithPrismaContentEqualsUniqueParam) equals() {}

type CommentWithPrismaPostIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	postIDField()
}

type CommentWithPrismaPostIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postIDField()
}

type commentWithPrismaPostIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostIDSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostIDSetParam) commentModel() {}

func (p commentWithPrismaPostIDSetParam) postIDField() {}

type CommentWithPrismaPostIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postIDField()
}

type commentWithPrismaPostIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostIDEqualsParam) commentModel() {}

func (p commentWithPrismaPostIDEqualsParam) postIDField() {}

func (commentWithPrismaPostIDSetParam) settable()  {}
func (commentWithPrismaPostIDEqualsParam) equals() {}

type commentWithPrismaPostIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostIDEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaPostIDEqualsUniqueParam) postIDField()  {}

func (commentWithPrismaPostIDEqualsUniqueParam) unique() {}
func (commentWithPrismaPostIDEqualsUniqueParam) equals() {}

type CommentWithPrismaPostEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	postField()
}

type CommentWithPrismaPostSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postField()
}

type commentWithPrismaPostSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostSetParam) commentModel() {}

func (p commentWithPrismaPostSetParam) postField() {}

type CommentWithPrismaPostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	postField()
}

type commentWithPrismaPostEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostEqualsParam) commentModel() {}

func (p commentWithPrismaPostEqualsParam) postField() {}

func (commentWithPrismaPostSetParam) settable()  {}
func (commentWithPrismaPostEqualsParam) equals() {}

type commentWithPrismaPostEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaPostEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaPostEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaPostEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaPostEqualsUniqueParam) postField()    {}

func (commentWithPrismaPostEqualsUniqueParam) unique() {}
func (commentWithPrismaPostEqualsUniqueParam) equals() {}

type CommentWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	userIDField()
}

type CommentWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userIDField()
}

type commentWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserIDSetParam) commentModel() {}

func (p commentWithPrismaUserIDSetParam) userIDField() {}

type CommentWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userIDField()
}

type commentWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserIDEqualsParam) commentModel() {}

func (p commentWithPrismaUserIDEqualsParam) userIDField() {}

func (commentWithPrismaUserIDSetParam) settable()  {}
func (commentWithPrismaUserIDEqualsParam) equals() {}

type commentWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserIDEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaUserIDEqualsUniqueParam) userIDField()  {}

func (commentWithPrismaUserIDEqualsUniqueParam) unique() {}
func (commentWithPrismaUserIDEqualsUniqueParam) equals() {}

type CommentWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentModel()
	userField()
}

type CommentWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userField()
}

type commentWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserSetParam) commentModel() {}

func (p commentWithPrismaUserSetParam) userField() {}

type CommentWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentModel()
	userField()
}

type commentWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserEqualsParam) commentModel() {}

func (p commentWithPrismaUserEqualsParam) userField() {}

func (commentWithPrismaUserSetParam) settable()  {}
func (commentWithPrismaUserEqualsParam) equals() {}

type commentWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentWithPrismaUserEqualsUniqueParam) commentModel() {}
func (p commentWithPrismaUserEqualsUniqueParam) userField()    {}

func (commentWithPrismaUserEqualsUniqueParam) unique() {}
func (commentWithPrismaUserEqualsUniqueParam) equals() {}

type likeActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var likeOutput = []builder.Output{
	{Name: "id"},
	{Name: "postId"},
	{Name: "userId"},
}

type LikeRelationWith interface {
	getQuery() builder.Query
	with()
	likeRelation()
}

type LikeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
}

type likeDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeDefaultParam) field() builder.Field {
	return p.data
}

func (p likeDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p likeDefaultParam) likeModel() {}

type LikeOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
}

type likeOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeOrderByParam) field() builder.Field {
	return p.data
}

func (p likeOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p likeOrderByParam) likeModel() {}

type LikeCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	isCursor()
}

type likeCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeCursorParam) field() builder.Field {
	return p.data
}

func (p likeCursorParam) isCursor() {}

func (p likeCursorParam) getQuery() builder.Query {
	return p.query
}

func (p likeCursorParam) likeModel() {}

type LikeParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	likeModel()
}

type likeParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p likeParamUnique) likeModel() {}

func (likeParamUnique) unique() {}

func (p likeParamUnique) field() builder.Field {
	return p.data
}

func (p likeParamUnique) getQuery() builder.Query {
	return p.query
}

type LikeEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likeModel()
}

type likeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeEqualsParam) likeModel() {}

func (likeEqualsParam) equals() {}

func (p likeEqualsParam) field() builder.Field {
	return p.data
}

func (p likeEqualsParam) getQuery() builder.Query {
	return p.query
}

type LikeEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	likeModel()
}

type likeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeEqualsUniqueParam) likeModel() {}

func (likeEqualsUniqueParam) unique() {}
func (likeEqualsUniqueParam) equals() {}

func (p likeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type LikeSetParam interface {
	field() builder.Field
	settable()
	likeModel()
}

type likeSetParam struct {
	data builder.Field
}

func (p likeSetParam) userField() {
	//TODO implement me
	panic("implement me")
}

func (p likeSetParam) getQuery() builder.Query {
	//TODO implement me
	panic("implement me")
}

func (p likeSetParam) postField() {
	//TODO implement me
	panic("implement me")
}

func (likeSetParam) settable() {}

func (p likeSetParam) field() builder.Field {
	return p.data
}

func (p likeSetParam) likeModel() {}

type LikeWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likeModel()
	idField()
}

type LikeWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	idField()
}

type likeWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaIDSetParam) likeModel() {}

func (p likeWithPrismaIDSetParam) idField() {}

type LikeWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	idField()
}

type likeWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaIDEqualsParam) likeModel() {}

func (p likeWithPrismaIDEqualsParam) idField() {}

func (likeWithPrismaIDSetParam) settable()  {}
func (likeWithPrismaIDEqualsParam) equals() {}

type likeWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaIDEqualsUniqueParam) likeModel() {}
func (p likeWithPrismaIDEqualsUniqueParam) idField()   {}

func (likeWithPrismaIDEqualsUniqueParam) unique() {}
func (likeWithPrismaIDEqualsUniqueParam) equals() {}

type LikeWithPrismaPostIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likeModel()
	postIDField()
}

type LikeWithPrismaPostIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	postIDField()
}

type likeWithPrismaPostIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaPostIDSetParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaPostIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaPostIDSetParam) likeModel() {}

func (p likeWithPrismaPostIDSetParam) postIDField() {}

type LikeWithPrismaPostIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	postIDField()
}

type likeWithPrismaPostIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaPostIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaPostIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaPostIDEqualsParam) likeModel() {}

func (p likeWithPrismaPostIDEqualsParam) postIDField() {}

func (likeWithPrismaPostIDSetParam) settable()  {}
func (likeWithPrismaPostIDEqualsParam) equals() {}

type likeWithPrismaPostIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaPostIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaPostIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaPostIDEqualsUniqueParam) likeModel()   {}
func (p likeWithPrismaPostIDEqualsUniqueParam) postIDField() {}

func (likeWithPrismaPostIDEqualsUniqueParam) unique() {}
func (likeWithPrismaPostIDEqualsUniqueParam) equals() {}

type LikeWithPrismaPostEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likeModel()
	postField()
}

type LikeWithPrismaPostSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	postField()
}

type likeWithPrismaPostSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaPostSetParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaPostSetParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaPostSetParam) likeModel() {}

func (p likeWithPrismaPostSetParam) postField() {}

type LikeWithPrismaPostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	postField()
}

type likeWithPrismaPostEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaPostEqualsParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaPostEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaPostEqualsParam) likeModel() {}

func (p likeWithPrismaPostEqualsParam) postField() {}

func (likeWithPrismaPostSetParam) settable()  {}
func (likeWithPrismaPostEqualsParam) equals() {}

type likeWithPrismaPostEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaPostEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaPostEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaPostEqualsUniqueParam) likeModel() {}
func (p likeWithPrismaPostEqualsUniqueParam) postField() {}

func (likeWithPrismaPostEqualsUniqueParam) unique() {}
func (likeWithPrismaPostEqualsUniqueParam) equals() {}

type LikeWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likeModel()
	userIDField()
}

type LikeWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	userIDField()
}

type likeWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaUserIDSetParam) likeModel() {}

func (p likeWithPrismaUserIDSetParam) userIDField() {}

type LikeWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	userIDField()
}

type likeWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaUserIDEqualsParam) likeModel() {}

func (p likeWithPrismaUserIDEqualsParam) userIDField() {}

func (likeWithPrismaUserIDSetParam) settable()  {}
func (likeWithPrismaUserIDEqualsParam) equals() {}

type likeWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaUserIDEqualsUniqueParam) likeModel()   {}
func (p likeWithPrismaUserIDEqualsUniqueParam) userIDField() {}

func (likeWithPrismaUserIDEqualsUniqueParam) unique() {}
func (likeWithPrismaUserIDEqualsUniqueParam) equals() {}

type LikeWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likeModel()
	userField()
}

type LikeWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	userField()
}

type likeWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaUserSetParam) likeModel() {}

func (p likeWithPrismaUserSetParam) userField() {}

type LikeWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likeModel()
	userField()
}

type likeWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaUserEqualsParam) likeModel() {}

func (p likeWithPrismaUserEqualsParam) userField() {}

func (likeWithPrismaUserSetParam) settable()  {}
func (likeWithPrismaUserEqualsParam) equals() {}

type likeWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likeWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likeWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likeWithPrismaUserEqualsUniqueParam) likeModel() {}
func (p likeWithPrismaUserEqualsUniqueParam) userField() {}

func (likeWithPrismaUserEqualsUniqueParam) unique() {}
func (likeWithPrismaUserEqualsUniqueParam) equals() {}

type tagActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var tagOutput = []builder.Output{
	{Name: "id"},
	{Name: "postId"},
	{Name: "userId"},
}

type TagRelationWith interface {
	getQuery() builder.Query
	with()
	tagRelation()
}

type TagWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
}

type tagDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagDefaultParam) field() builder.Field {
	return p.data
}

func (p tagDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p tagDefaultParam) tagModel() {}

type TagOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
}

type tagOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagOrderByParam) field() builder.Field {
	return p.data
}

func (p tagOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p tagOrderByParam) tagModel() {}

type TagCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	isCursor()
}

type tagCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagCursorParam) field() builder.Field {
	return p.data
}

func (p tagCursorParam) isCursor() {}

func (p tagCursorParam) getQuery() builder.Query {
	return p.query
}

func (p tagCursorParam) tagModel() {}

type TagParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	tagModel()
}

type tagParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p tagParamUnique) tagModel() {}

func (tagParamUnique) unique() {}

func (p tagParamUnique) field() builder.Field {
	return p.data
}

func (p tagParamUnique) getQuery() builder.Query {
	return p.query
}

type TagEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagModel()
}

type tagEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagEqualsParam) tagModel() {}

func (tagEqualsParam) equals() {}

func (p tagEqualsParam) field() builder.Field {
	return p.data
}

func (p tagEqualsParam) getQuery() builder.Query {
	return p.query
}

type TagEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	tagModel()
}

type tagEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagEqualsUniqueParam) tagModel() {}

func (tagEqualsUniqueParam) unique() {}
func (tagEqualsUniqueParam) equals() {}

func (p tagEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TagSetParam interface {
	field() builder.Field
	settable()
	tagModel()
}

type tagSetParam struct {
	data builder.Field
}

func (tagSetParam) settable() {}

func (p tagSetParam) field() builder.Field {
	return p.data
}

func (p tagSetParam) tagModel() {}

type TagWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagModel()
	idField()
}

type TagWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	idField()
}

type tagWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaIDSetParam) tagModel() {}

func (p tagWithPrismaIDSetParam) idField() {}

type TagWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	idField()
}

type tagWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaIDEqualsParam) tagModel() {}

func (p tagWithPrismaIDEqualsParam) idField() {}

func (tagWithPrismaIDSetParam) settable()  {}
func (tagWithPrismaIDEqualsParam) equals() {}

type tagWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaIDEqualsUniqueParam) tagModel() {}
func (p tagWithPrismaIDEqualsUniqueParam) idField()  {}

func (tagWithPrismaIDEqualsUniqueParam) unique() {}
func (tagWithPrismaIDEqualsUniqueParam) equals() {}

type TagWithPrismaPostIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagModel()
	postIDField()
}

type TagWithPrismaPostIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	postIDField()
}

type tagWithPrismaPostIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaPostIDSetParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaPostIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaPostIDSetParam) tagModel() {}

func (p tagWithPrismaPostIDSetParam) postIDField() {}

type TagWithPrismaPostIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	postIDField()
}

type tagWithPrismaPostIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaPostIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaPostIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaPostIDEqualsParam) tagModel() {}

func (p tagWithPrismaPostIDEqualsParam) postIDField() {}

func (tagWithPrismaPostIDSetParam) settable()  {}
func (tagWithPrismaPostIDEqualsParam) equals() {}

type tagWithPrismaPostIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaPostIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaPostIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaPostIDEqualsUniqueParam) tagModel()    {}
func (p tagWithPrismaPostIDEqualsUniqueParam) postIDField() {}

func (tagWithPrismaPostIDEqualsUniqueParam) unique() {}
func (tagWithPrismaPostIDEqualsUniqueParam) equals() {}

type TagWithPrismaPostEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagModel()
	postField()
}

type TagWithPrismaPostSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	postField()
}

type tagWithPrismaPostSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaPostSetParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaPostSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaPostSetParam) tagModel() {}

func (p tagWithPrismaPostSetParam) postField() {}

type TagWithPrismaPostWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	postField()
}

type tagWithPrismaPostEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaPostEqualsParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaPostEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaPostEqualsParam) tagModel() {}

func (p tagWithPrismaPostEqualsParam) postField() {}

func (tagWithPrismaPostSetParam) settable()  {}
func (tagWithPrismaPostEqualsParam) equals() {}

type tagWithPrismaPostEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaPostEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaPostEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaPostEqualsUniqueParam) tagModel()  {}
func (p tagWithPrismaPostEqualsUniqueParam) postField() {}

func (tagWithPrismaPostEqualsUniqueParam) unique() {}
func (tagWithPrismaPostEqualsUniqueParam) equals() {}

type TagWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagModel()
	userIDField()
}

type TagWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	userIDField()
}

type tagWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaUserIDSetParam) tagModel() {}

func (p tagWithPrismaUserIDSetParam) userIDField() {}

type TagWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	userIDField()
}

type tagWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaUserIDEqualsParam) tagModel() {}

func (p tagWithPrismaUserIDEqualsParam) userIDField() {}

func (tagWithPrismaUserIDSetParam) settable()  {}
func (tagWithPrismaUserIDEqualsParam) equals() {}

type tagWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaUserIDEqualsUniqueParam) tagModel()    {}
func (p tagWithPrismaUserIDEqualsUniqueParam) userIDField() {}

func (tagWithPrismaUserIDEqualsUniqueParam) unique() {}
func (tagWithPrismaUserIDEqualsUniqueParam) equals() {}

type TagWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagModel()
	userField()
}

type TagWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	userField()
}

type tagWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaUserSetParam) tagModel() {}

func (p tagWithPrismaUserSetParam) userField() {}

type TagWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagModel()
	userField()
}

type tagWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaUserEqualsParam) tagModel() {}

func (p tagWithPrismaUserEqualsParam) userField() {}

func (tagWithPrismaUserSetParam) settable()  {}
func (tagWithPrismaUserEqualsParam) equals() {}

type tagWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagWithPrismaUserEqualsUniqueParam) tagModel()  {}
func (p tagWithPrismaUserEqualsUniqueParam) userField() {}

func (tagWithPrismaUserEqualsUniqueParam) unique() {}
func (tagWithPrismaUserEqualsUniqueParam) equals() {}

type followsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var followsOutput = []builder.Output{
	{Name: "id"},
	{Name: "followerId"},
	{Name: "followingId"},
}

type FollowsRelationWith interface {
	getQuery() builder.Query
	with()
	followsRelation()
}

type FollowsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
}

type followsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsDefaultParam) field() builder.Field {
	return p.data
}

func (p followsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p followsDefaultParam) followsModel() {}

type FollowsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
}

type followsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsOrderByParam) field() builder.Field {
	return p.data
}

func (p followsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p followsOrderByParam) followsModel() {}

type FollowsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	isCursor()
}

type followsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsCursorParam) field() builder.Field {
	return p.data
}

func (p followsCursorParam) isCursor() {}

func (p followsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p followsCursorParam) followsModel() {}

type FollowsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	followsModel()
}

type followsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p followsParamUnique) followsModel() {}

func (followsParamUnique) unique() {}

func (p followsParamUnique) field() builder.Field {
	return p.data
}

func (p followsParamUnique) getQuery() builder.Query {
	return p.query
}

type FollowsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	followsModel()
}

type followsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsEqualsParam) followsModel() {}

func (followsEqualsParam) equals() {}

func (p followsEqualsParam) field() builder.Field {
	return p.data
}

func (p followsEqualsParam) getQuery() builder.Query {
	return p.query
}

type FollowsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	followsModel()
}

type followsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsEqualsUniqueParam) followsModel() {}

func (followsEqualsUniqueParam) unique() {}
func (followsEqualsUniqueParam) equals() {}

func (p followsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p followsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type FollowsSetParam interface {
	field() builder.Field
	settable()
	followsModel()
}

type followsSetParam struct {
	data builder.Field
}

func (p followsSetParam) followingField() {
	//TODO implement me
	panic("implement me")
}

func (p followsSetParam) getQuery() builder.Query {
	//TODO implement me
	panic("implement me")
}

func (p followsSetParam) followerField() {
	//TODO implement me
	panic("implement me")
}

func (followsSetParam) settable() {}

func (p followsSetParam) field() builder.Field {
	return p.data
}

func (p followsSetParam) followsModel() {}

type FollowsWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	followsModel()
	idField()
}

type FollowsWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	idField()
}

type followsWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaIDSetParam) followsModel() {}

func (p followsWithPrismaIDSetParam) idField() {}

type FollowsWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	idField()
}

type followsWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaIDEqualsParam) followsModel() {}

func (p followsWithPrismaIDEqualsParam) idField() {}

func (followsWithPrismaIDSetParam) settable()  {}
func (followsWithPrismaIDEqualsParam) equals() {}

type followsWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaIDEqualsUniqueParam) followsModel() {}
func (p followsWithPrismaIDEqualsUniqueParam) idField()      {}

func (followsWithPrismaIDEqualsUniqueParam) unique() {}
func (followsWithPrismaIDEqualsUniqueParam) equals() {}

type FollowsWithPrismaFollowerIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	followsModel()
	followerIDField()
}

type FollowsWithPrismaFollowerIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followerIDField()
}

type followsWithPrismaFollowerIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowerIDSetParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowerIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowerIDSetParam) followsModel() {}

func (p followsWithPrismaFollowerIDSetParam) followerIDField() {}

type FollowsWithPrismaFollowerIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followerIDField()
}

type followsWithPrismaFollowerIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowerIDEqualsParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowerIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowerIDEqualsParam) followsModel() {}

func (p followsWithPrismaFollowerIDEqualsParam) followerIDField() {}

func (followsWithPrismaFollowerIDSetParam) settable()  {}
func (followsWithPrismaFollowerIDEqualsParam) equals() {}

type followsWithPrismaFollowerIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowerIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowerIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowerIDEqualsUniqueParam) followsModel()    {}
func (p followsWithPrismaFollowerIDEqualsUniqueParam) followerIDField() {}

func (followsWithPrismaFollowerIDEqualsUniqueParam) unique() {}
func (followsWithPrismaFollowerIDEqualsUniqueParam) equals() {}

type FollowsWithPrismaFollowerEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	followsModel()
	followerField()
}

type FollowsWithPrismaFollowerSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followerField()
}

type followsWithPrismaFollowerSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowerSetParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowerSetParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowerSetParam) followsModel() {}

func (p followsWithPrismaFollowerSetParam) followerField() {}

type FollowsWithPrismaFollowerWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followerField()
}

type followsWithPrismaFollowerEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowerEqualsParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowerEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowerEqualsParam) followsModel() {}

func (p followsWithPrismaFollowerEqualsParam) followerField() {}

func (followsWithPrismaFollowerSetParam) settable()  {}
func (followsWithPrismaFollowerEqualsParam) equals() {}

type followsWithPrismaFollowerEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowerEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowerEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowerEqualsUniqueParam) followsModel()  {}
func (p followsWithPrismaFollowerEqualsUniqueParam) followerField() {}

func (followsWithPrismaFollowerEqualsUniqueParam) unique() {}
func (followsWithPrismaFollowerEqualsUniqueParam) equals() {}

type FollowsWithPrismaFollowingIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	followsModel()
	followingIDField()
}

type FollowsWithPrismaFollowingIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followingIDField()
}

type followsWithPrismaFollowingIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowingIDSetParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowingIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowingIDSetParam) followsModel() {}

func (p followsWithPrismaFollowingIDSetParam) followingIDField() {}

type FollowsWithPrismaFollowingIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followingIDField()
}

type followsWithPrismaFollowingIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowingIDEqualsParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowingIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowingIDEqualsParam) followsModel() {}

func (p followsWithPrismaFollowingIDEqualsParam) followingIDField() {}

func (followsWithPrismaFollowingIDSetParam) settable()  {}
func (followsWithPrismaFollowingIDEqualsParam) equals() {}

type followsWithPrismaFollowingIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowingIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowingIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowingIDEqualsUniqueParam) followsModel()     {}
func (p followsWithPrismaFollowingIDEqualsUniqueParam) followingIDField() {}

func (followsWithPrismaFollowingIDEqualsUniqueParam) unique() {}
func (followsWithPrismaFollowingIDEqualsUniqueParam) equals() {}

type FollowsWithPrismaFollowingEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	followsModel()
	followingField()
}

type FollowsWithPrismaFollowingSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followingField()
}

type followsWithPrismaFollowingSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowingSetParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowingSetParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowingSetParam) followsModel() {}

func (p followsWithPrismaFollowingSetParam) followingField() {}

type FollowsWithPrismaFollowingWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	followsModel()
	followingField()
}

type followsWithPrismaFollowingEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowingEqualsParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowingEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowingEqualsParam) followsModel() {}

func (p followsWithPrismaFollowingEqualsParam) followingField() {}

func (followsWithPrismaFollowingSetParam) settable()  {}
func (followsWithPrismaFollowingEqualsParam) equals() {}

type followsWithPrismaFollowingEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p followsWithPrismaFollowingEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p followsWithPrismaFollowingEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p followsWithPrismaFollowingEqualsUniqueParam) followsModel()   {}
func (p followsWithPrismaFollowingEqualsUniqueParam) followingField() {}

func (followsWithPrismaFollowingEqualsUniqueParam) unique() {}
func (followsWithPrismaFollowingEqualsUniqueParam) equals() {}

type restaurantActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var restaurantOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "address"},
	{Name: "city"},
	{Name: "state"},
	{Name: "zipCode"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type RestaurantRelationWith interface {
	getQuery() builder.Query
	with()
	restaurantRelation()
}

type RestaurantWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
}

type restaurantDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantDefaultParam) field() builder.Field {
	return p.data
}

func (p restaurantDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantDefaultParam) restaurantModel() {}

type RestaurantOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
}

type restaurantOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantOrderByParam) field() builder.Field {
	return p.data
}

func (p restaurantOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantOrderByParam) restaurantModel() {}

type RestaurantCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	isCursor()
}

type restaurantCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantCursorParam) field() builder.Field {
	return p.data
}

func (p restaurantCursorParam) isCursor() {}

func (p restaurantCursorParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantCursorParam) restaurantModel() {}

type RestaurantParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	restaurantModel()
}

type restaurantParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantParamUnique) restaurantModel() {}

func (restaurantParamUnique) unique() {}

func (p restaurantParamUnique) field() builder.Field {
	return p.data
}

func (p restaurantParamUnique) getQuery() builder.Query {
	return p.query
}

type RestaurantEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
}

type restaurantEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantEqualsParam) restaurantModel() {}

func (restaurantEqualsParam) equals() {}

func (p restaurantEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantEqualsParam) getQuery() builder.Query {
	return p.query
}

type RestaurantEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	restaurantModel()
}

type restaurantEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantEqualsUniqueParam) restaurantModel() {}

func (restaurantEqualsUniqueParam) unique() {}
func (restaurantEqualsUniqueParam) equals() {}

func (p restaurantEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type RestaurantSetParam interface {
	field() builder.Field
	settable()
	restaurantModel()
}

type restaurantSetParam struct {
	data builder.Field
}

func (restaurantSetParam) settable() {}

func (p restaurantSetParam) field() builder.Field {
	return p.data
}

func (p restaurantSetParam) restaurantModel() {}

type RestaurantWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	idField()
}

type RestaurantWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	idField()
}

type restaurantWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaIDSetParam) restaurantModel() {}

func (p restaurantWithPrismaIDSetParam) idField() {}

type RestaurantWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	idField()
}

type restaurantWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaIDEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaIDEqualsParam) idField() {}

func (restaurantWithPrismaIDSetParam) settable()  {}
func (restaurantWithPrismaIDEqualsParam) equals() {}

type restaurantWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaIDEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaIDEqualsUniqueParam) idField()         {}

func (restaurantWithPrismaIDEqualsUniqueParam) unique() {}
func (restaurantWithPrismaIDEqualsUniqueParam) equals() {}

type RestaurantWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	nameField()
}

type RestaurantWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	nameField()
}

type restaurantWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaNameSetParam) restaurantModel() {}

func (p restaurantWithPrismaNameSetParam) nameField() {}

type RestaurantWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	nameField()
}

type restaurantWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaNameEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaNameEqualsParam) nameField() {}

func (restaurantWithPrismaNameSetParam) settable()  {}
func (restaurantWithPrismaNameEqualsParam) equals() {}

type restaurantWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaNameEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaNameEqualsUniqueParam) nameField()       {}

func (restaurantWithPrismaNameEqualsUniqueParam) unique() {}
func (restaurantWithPrismaNameEqualsUniqueParam) equals() {}

type RestaurantWithPrismaAddressEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	addressField()
}

type RestaurantWithPrismaAddressSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	addressField()
}

type restaurantWithPrismaAddressSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaAddressSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaAddressSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaAddressSetParam) restaurantModel() {}

func (p restaurantWithPrismaAddressSetParam) addressField() {}

type RestaurantWithPrismaAddressWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	addressField()
}

type restaurantWithPrismaAddressEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaAddressEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaAddressEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaAddressEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaAddressEqualsParam) addressField() {}

func (restaurantWithPrismaAddressSetParam) settable()  {}
func (restaurantWithPrismaAddressEqualsParam) equals() {}

type restaurantWithPrismaAddressEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaAddressEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaAddressEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaAddressEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaAddressEqualsUniqueParam) addressField()    {}

func (restaurantWithPrismaAddressEqualsUniqueParam) unique() {}
func (restaurantWithPrismaAddressEqualsUniqueParam) equals() {}

type RestaurantWithPrismaCityEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	cityField()
}

type RestaurantWithPrismaCitySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	cityField()
}

type restaurantWithPrismaCitySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaCitySetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaCitySetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaCitySetParam) restaurantModel() {}

func (p restaurantWithPrismaCitySetParam) cityField() {}

type RestaurantWithPrismaCityWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	cityField()
}

type restaurantWithPrismaCityEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaCityEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaCityEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaCityEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaCityEqualsParam) cityField() {}

func (restaurantWithPrismaCitySetParam) settable()  {}
func (restaurantWithPrismaCityEqualsParam) equals() {}

type restaurantWithPrismaCityEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaCityEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaCityEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaCityEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaCityEqualsUniqueParam) cityField()       {}

func (restaurantWithPrismaCityEqualsUniqueParam) unique() {}
func (restaurantWithPrismaCityEqualsUniqueParam) equals() {}

type RestaurantWithPrismaStateEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	stateField()
}

type RestaurantWithPrismaStateSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	stateField()
}

type restaurantWithPrismaStateSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaStateSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaStateSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaStateSetParam) restaurantModel() {}

func (p restaurantWithPrismaStateSetParam) stateField() {}

type RestaurantWithPrismaStateWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	stateField()
}

type restaurantWithPrismaStateEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaStateEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaStateEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaStateEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaStateEqualsParam) stateField() {}

func (restaurantWithPrismaStateSetParam) settable()  {}
func (restaurantWithPrismaStateEqualsParam) equals() {}

type restaurantWithPrismaStateEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaStateEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaStateEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaStateEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaStateEqualsUniqueParam) stateField()      {}

func (restaurantWithPrismaStateEqualsUniqueParam) unique() {}
func (restaurantWithPrismaStateEqualsUniqueParam) equals() {}

type RestaurantWithPrismaZipCodeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	zipCodeField()
}

type RestaurantWithPrismaZipCodeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	zipCodeField()
}

type restaurantWithPrismaZipCodeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaZipCodeSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaZipCodeSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaZipCodeSetParam) restaurantModel() {}

func (p restaurantWithPrismaZipCodeSetParam) zipCodeField() {}

type RestaurantWithPrismaZipCodeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	zipCodeField()
}

type restaurantWithPrismaZipCodeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaZipCodeEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaZipCodeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaZipCodeEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaZipCodeEqualsParam) zipCodeField() {}

func (restaurantWithPrismaZipCodeSetParam) settable()  {}
func (restaurantWithPrismaZipCodeEqualsParam) equals() {}

type restaurantWithPrismaZipCodeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaZipCodeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaZipCodeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaZipCodeEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaZipCodeEqualsUniqueParam) zipCodeField()    {}

func (restaurantWithPrismaZipCodeEqualsUniqueParam) unique() {}
func (restaurantWithPrismaZipCodeEqualsUniqueParam) equals() {}

type RestaurantWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	createdAtField()
}

type RestaurantWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	createdAtField()
}

type restaurantWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaCreatedAtSetParam) restaurantModel() {}

func (p restaurantWithPrismaCreatedAtSetParam) createdAtField() {}

type RestaurantWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	createdAtField()
}

type restaurantWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaCreatedAtEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (restaurantWithPrismaCreatedAtSetParam) settable()  {}
func (restaurantWithPrismaCreatedAtEqualsParam) equals() {}

type restaurantWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaCreatedAtEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaCreatedAtEqualsUniqueParam) createdAtField()  {}

func (restaurantWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (restaurantWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type RestaurantWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	updatedAtField()
}

type RestaurantWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	updatedAtField()
}

type restaurantWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaUpdatedAtSetParam) restaurantModel() {}

func (p restaurantWithPrismaUpdatedAtSetParam) updatedAtField() {}

type RestaurantWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	updatedAtField()
}

type restaurantWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaUpdatedAtEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (restaurantWithPrismaUpdatedAtSetParam) settable()  {}
func (restaurantWithPrismaUpdatedAtEqualsParam) equals() {}

type restaurantWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaUpdatedAtEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()  {}

func (restaurantWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (restaurantWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type RestaurantWithPrismaPostsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	restaurantModel()
	postsField()
}

type RestaurantWithPrismaPostsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	postsField()
}

type restaurantWithPrismaPostsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaPostsSetParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaPostsSetParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaPostsSetParam) restaurantModel() {}

func (p restaurantWithPrismaPostsSetParam) postsField() {}

type RestaurantWithPrismaPostsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	restaurantModel()
	postsField()
}

type restaurantWithPrismaPostsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaPostsEqualsParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaPostsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaPostsEqualsParam) restaurantModel() {}

func (p restaurantWithPrismaPostsEqualsParam) postsField() {}

func (restaurantWithPrismaPostsSetParam) settable()  {}
func (restaurantWithPrismaPostsEqualsParam) equals() {}

type restaurantWithPrismaPostsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p restaurantWithPrismaPostsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p restaurantWithPrismaPostsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p restaurantWithPrismaPostsEqualsUniqueParam) restaurantModel() {}
func (p restaurantWithPrismaPostsEqualsUniqueParam) postsField()      {}

func (restaurantWithPrismaPostsEqualsUniqueParam) unique() {}
func (restaurantWithPrismaPostsEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_email UserWithPrismaEmailSetParam,
	_username UserWithPrismaUsernameSetParam,
	_password UserWithPrismaPasswordSetParam,
	_bio UserWithPrismaBioSetParam,
	_avatar UserWithPrismaAvatarSetParam,
	_firstName UserWithPrismaFirstNameSetParam,
	_lastName UserWithPrismaLastNameSetParam,
	_spiciness UserWithPrismaSpicinessSetParam,
	_sweetness UserWithPrismaSweetnessSetParam,
	_sourness UserWithPrismaSournessSetParam,
	_type UserWithPrismaTypeSetParam,
	_allergies UserWithPrismaAllergiesSetParam,
	_city UserWithPrismaCitySetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _email.field())
	fields = append(fields, _username.field())
	fields = append(fields, _password.field())
	fields = append(fields, _bio.field())
	fields = append(fields, _avatar.field())
	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())
	fields = append(fields, _spiciness.field())
	fields = append(fields, _sweetness.field())
	fields = append(fields, _sourness.field())
	fields = append(fields, _type.field())
	fields = append(fields, _allergies.field())
	fields = append(fields, _city.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single post.
func (r postActions) CreateOne(
	_title PostWithPrismaTitleSetParam,
	_description PostWithPrismaDescriptionSetParam,
	_longitude PostWithPrismaLongitudeSetParam,
	_latitude PostWithPrismaLatitudeSetParam,
	_cuisine PostWithPrismaCuisineSetParam,
	_dish PostWithPrismaDishSetParam,
	_type PostWithPrismaTypeSetParam,
	_spiciness PostWithPrismaSpicinessSetParam,
	_sweetness PostWithPrismaSweetnessSetParam,
	_sourness PostWithPrismaSournessSetParam,
	_pictures PostWithPrismaPicturesSetParam,
	_city PostWithPrismaCitySetParam,
	_user PostWithPrismaUserSetParam,

	optional ...PostSetParam,
) postCreateOne {
	var v postCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var fields []builder.Field

	fields = append(fields, _title.field())
	fields = append(fields, _description.field())
	fields = append(fields, _longitude.field())
	fields = append(fields, _latitude.field())
	fields = append(fields, _cuisine.field())
	fields = append(fields, _dish.field())
	fields = append(fields, _type.field())
	fields = append(fields, _spiciness.field())
	fields = append(fields, _sweetness.field())
	fields = append(fields, _sourness.field())
	fields = append(fields, _pictures.field())
	fields = append(fields, _city.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r postCreateOne) With(params ...PostRelationWith) postCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type postCreateOne struct {
	query builder.Query
}

func (p postCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p postCreateOne) postModel() {}

func (r postCreateOne) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postCreateOne) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single comment.
func (r commentActions) CreateOne(
	_content CommentWithPrismaContentSetParam,
	_post CommentWithPrismaPostSetParam,
	_user CommentWithPrismaUserSetParam,

	optional ...CommentSetParam,
) commentCreateOne {
	var v commentCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	var fields []builder.Field

	fields = append(fields, _content.field())
	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r commentCreateOne) With(params ...CommentRelationWith) commentCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type commentCreateOne struct {
	query builder.Query
}

func (p commentCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p commentCreateOne) commentModel() {}

func (r commentCreateOne) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentCreateOne) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single like.
func (r likeActions) CreateOne(
	_post LikeWithPrismaPostSetParam,
	_user LikeWithPrismaUserSetParam,

	optional ...LikeSetParam,
) likeCreateOne {
	var v likeCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Like"
	v.query.Outputs = likeOutput

	var fields []builder.Field

	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r likeCreateOne) With(params ...LikeRelationWith) likeCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type likeCreateOne struct {
	query builder.Query
}

func (p likeCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p likeCreateOne) likeModel() {}

func (r likeCreateOne) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeCreateOne) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single tag.
func (r tagActions) CreateOne(
	_post TagWithPrismaPostSetParam,
	_user TagWithPrismaUserSetParam,

	optional ...TagSetParam,
) tagCreateOne {
	var v tagCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Tag"
	v.query.Outputs = tagOutput

	var fields []builder.Field

	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r tagCreateOne) With(params ...TagRelationWith) tagCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type tagCreateOne struct {
	query builder.Query
}

func (p tagCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p tagCreateOne) tagModel() {}

func (r tagCreateOne) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagCreateOne) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single follows.
func (r followsActions) CreateOne(
	_follower FollowsWithPrismaFollowerSetParam,
	_following FollowsWithPrismaFollowingSetParam,

	optional ...FollowsSetParam,
) followsCreateOne {
	var v followsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Follows"
	v.query.Outputs = followsOutput

	var fields []builder.Field

	fields = append(fields, _follower.field())
	fields = append(fields, _following.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r followsCreateOne) With(params ...FollowsRelationWith) followsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type followsCreateOne struct {
	query builder.Query
}

func (p followsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p followsCreateOne) followsModel() {}

func (r followsCreateOne) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsCreateOne) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single restaurant.
func (r restaurantActions) CreateOne(
	_name RestaurantWithPrismaNameSetParam,
	_address RestaurantWithPrismaAddressSetParam,
	_city RestaurantWithPrismaCitySetParam,
	_state RestaurantWithPrismaStateSetParam,
	_zipCode RestaurantWithPrismaZipCodeSetParam,

	optional ...RestaurantSetParam,
) restaurantCreateOne {
	var v restaurantCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Restaurant"
	v.query.Outputs = restaurantOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _address.field())
	fields = append(fields, _city.field())
	fields = append(fields, _state.field())
	fields = append(fields, _zipCode.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r restaurantCreateOne) With(params ...RestaurantRelationWith) restaurantCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type restaurantCreateOne struct {
	query builder.Query
}

func (p restaurantCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p restaurantCreateOne) restaurantModel() {}

func (r restaurantCreateOne) Exec(ctx context.Context) (*RestaurantModel, error) {
	var v RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantCreateOne) Tx() RestaurantUniqueTxResult {
	v := newRestaurantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userToPostsFindUnique struct {
	query builder.Query
}

func (r userToPostsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToPostsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostsFindUnique) with()         {}
func (r userToPostsFindUnique) userModel()    {}
func (r userToPostsFindUnique) userRelation() {}

func (r userToPostsFindUnique) With(params ...PostRelationWith) userToPostsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostsFindUnique) Select(params ...userPrismaFields) userToPostsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostsFindUnique) Omit(params ...userPrismaFields) userToPostsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostsFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPostsFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPostsFindUnique) Update(params ...UserSetParam) userToPostsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToPostsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPostsUpdateUnique struct {
	query builder.Query
}

func (r userToPostsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostsUpdateUnique) userModel() {}

func (r userToPostsUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostsUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToPostsFindUnique) Delete() userToPostsDeleteUnique {
	var v userToPostsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToPostsDeleteUnique struct {
	query builder.Query
}

func (r userToPostsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToPostsDeleteUnique) userModel() {}

func (r userToPostsDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostsDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToPostsFindFirst struct {
	query builder.Query
}

func (r userToPostsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToPostsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostsFindFirst) with()         {}
func (r userToPostsFindFirst) userModel()    {}
func (r userToPostsFindFirst) userRelation() {}

func (r userToPostsFindFirst) With(params ...PostRelationWith) userToPostsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostsFindFirst) Select(params ...userPrismaFields) userToPostsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostsFindFirst) Omit(params ...userPrismaFields) userToPostsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostsFindFirst) OrderBy(params ...PostOrderByParam) userToPostsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToPostsFindFirst) Skip(count int) userToPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToPostsFindFirst) Take(count int) userToPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToPostsFindFirst) Cursor(cursor UserCursorParam) userToPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPostsFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToPostsFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToPostsFindMany struct {
	query builder.Query
}

func (r userToPostsFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToPostsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostsFindMany) with()         {}
func (r userToPostsFindMany) userModel()    {}
func (r userToPostsFindMany) userRelation() {}

func (r userToPostsFindMany) With(params ...PostRelationWith) userToPostsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostsFindMany) Select(params ...userPrismaFields) userToPostsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostsFindMany) Omit(params ...userPrismaFields) userToPostsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToPostsFindMany) OrderBy(params ...PostOrderByParam) userToPostsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToPostsFindMany) Skip(count int) userToPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToPostsFindMany) Take(count int) userToPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToPostsFindMany) Cursor(cursor UserCursorParam) userToPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPostsFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToPostsFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToPostsFindMany) Update(params ...UserSetParam) userToPostsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToPostsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPostsUpdateMany struct {
	query builder.Query
}

func (r userToPostsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToPostsUpdateMany) userModel() {}

func (r userToPostsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostsUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToPostsFindMany) Delete() userToPostsDeleteMany {
	var v userToPostsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToPostsDeleteMany struct {
	query builder.Query
}

func (r userToPostsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToPostsDeleteMany) userModel() {}

func (r userToPostsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToPostsDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToLikesFindUnique struct {
	query builder.Query
}

func (r userToLikesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToLikesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesFindUnique) with()         {}
func (r userToLikesFindUnique) userModel()    {}
func (r userToLikesFindUnique) userRelation() {}

func (r userToLikesFindUnique) With(params ...LikeRelationWith) userToLikesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToLikesFindUnique) Select(params ...userPrismaFields) userToLikesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindUnique) Omit(params ...userPrismaFields) userToLikesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToLikesFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToLikesFindUnique) Update(params ...UserSetParam) userToLikesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToLikesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToLikesUpdateUnique struct {
	query builder.Query
}

func (r userToLikesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesUpdateUnique) userModel() {}

func (r userToLikesUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToLikesFindUnique) Delete() userToLikesDeleteUnique {
	var v userToLikesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToLikesDeleteUnique struct {
	query builder.Query
}

func (r userToLikesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToLikesDeleteUnique) userModel() {}

func (r userToLikesDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToLikesFindFirst struct {
	query builder.Query
}

func (r userToLikesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToLikesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesFindFirst) with()         {}
func (r userToLikesFindFirst) userModel()    {}
func (r userToLikesFindFirst) userRelation() {}

func (r userToLikesFindFirst) With(params ...LikeRelationWith) userToLikesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToLikesFindFirst) Select(params ...userPrismaFields) userToLikesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindFirst) Omit(params ...userPrismaFields) userToLikesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindFirst) OrderBy(params ...LikeOrderByParam) userToLikesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToLikesFindFirst) Skip(count int) userToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToLikesFindFirst) Take(count int) userToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToLikesFindFirst) Cursor(cursor UserCursorParam) userToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToLikesFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToLikesFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToLikesFindMany struct {
	query builder.Query
}

func (r userToLikesFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToLikesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesFindMany) with()         {}
func (r userToLikesFindMany) userModel()    {}
func (r userToLikesFindMany) userRelation() {}

func (r userToLikesFindMany) With(params ...LikeRelationWith) userToLikesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToLikesFindMany) Select(params ...userPrismaFields) userToLikesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindMany) Omit(params ...userPrismaFields) userToLikesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindMany) OrderBy(params ...LikeOrderByParam) userToLikesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToLikesFindMany) Skip(count int) userToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToLikesFindMany) Take(count int) userToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToLikesFindMany) Cursor(cursor UserCursorParam) userToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToLikesFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToLikesFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToLikesFindMany) Update(params ...UserSetParam) userToLikesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToLikesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToLikesUpdateMany struct {
	query builder.Query
}

func (r userToLikesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesUpdateMany) userModel() {}

func (r userToLikesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToLikesFindMany) Delete() userToLikesDeleteMany {
	var v userToLikesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToLikesDeleteMany struct {
	query builder.Query
}

func (r userToLikesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToLikesDeleteMany) userModel() {}

func (r userToLikesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToCommentsFindUnique struct {
	query builder.Query
}

func (r userToCommentsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindUnique) with()         {}
func (r userToCommentsFindUnique) userModel()    {}
func (r userToCommentsFindUnique) userRelation() {}

func (r userToCommentsFindUnique) With(params ...CommentRelationWith) userToCommentsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindUnique) Select(params ...userPrismaFields) userToCommentsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindUnique) Omit(params ...userPrismaFields) userToCommentsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindUnique) Update(params ...UserSetParam) userToCommentsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToCommentsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToCommentsUpdateUnique struct {
	query builder.Query
}

func (r userToCommentsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsUpdateUnique) userModel() {}

func (r userToCommentsUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToCommentsFindUnique) Delete() userToCommentsDeleteUnique {
	var v userToCommentsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToCommentsDeleteUnique struct {
	query builder.Query
}

func (r userToCommentsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToCommentsDeleteUnique) userModel() {}

func (r userToCommentsDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToCommentsFindFirst struct {
	query builder.Query
}

func (r userToCommentsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindFirst) with()         {}
func (r userToCommentsFindFirst) userModel()    {}
func (r userToCommentsFindFirst) userRelation() {}

func (r userToCommentsFindFirst) With(params ...CommentRelationWith) userToCommentsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindFirst) Select(params ...userPrismaFields) userToCommentsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindFirst) Omit(params ...userPrismaFields) userToCommentsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindFirst) OrderBy(params ...CommentOrderByParam) userToCommentsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToCommentsFindFirst) Skip(count int) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToCommentsFindFirst) Take(count int) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToCommentsFindFirst) Cursor(cursor UserCursorParam) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToCommentsFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToCommentsFindMany struct {
	query builder.Query
}

func (r userToCommentsFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindMany) with()         {}
func (r userToCommentsFindMany) userModel()    {}
func (r userToCommentsFindMany) userRelation() {}

func (r userToCommentsFindMany) With(params ...CommentRelationWith) userToCommentsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindMany) Select(params ...userPrismaFields) userToCommentsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindMany) Omit(params ...userPrismaFields) userToCommentsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindMany) OrderBy(params ...CommentOrderByParam) userToCommentsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToCommentsFindMany) Skip(count int) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToCommentsFindMany) Take(count int) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToCommentsFindMany) Cursor(cursor UserCursorParam) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToCommentsFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToCommentsFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToCommentsFindMany) Update(params ...UserSetParam) userToCommentsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToCommentsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToCommentsUpdateMany struct {
	query builder.Query
}

func (r userToCommentsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsUpdateMany) userModel() {}

func (r userToCommentsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToCommentsFindMany) Delete() userToCommentsDeleteMany {
	var v userToCommentsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToCommentsDeleteMany struct {
	query builder.Query
}

func (r userToCommentsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToCommentsDeleteMany) userModel() {}

func (r userToCommentsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToFollowersFindUnique struct {
	query builder.Query
}

func (r userToFollowersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToFollowersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowersFindUnique) with()         {}
func (r userToFollowersFindUnique) userModel()    {}
func (r userToFollowersFindUnique) userRelation() {}

func (r userToFollowersFindUnique) With(params ...FollowsRelationWith) userToFollowersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToFollowersFindUnique) Select(params ...userPrismaFields) userToFollowersFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowersFindUnique) Omit(params ...userPrismaFields) userToFollowersFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowersFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToFollowersFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToFollowersFindUnique) Update(params ...UserSetParam) userToFollowersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToFollowersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToFollowersUpdateUnique struct {
	query builder.Query
}

func (r userToFollowersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowersUpdateUnique) userModel() {}

func (r userToFollowersUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowersUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToFollowersFindUnique) Delete() userToFollowersDeleteUnique {
	var v userToFollowersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToFollowersDeleteUnique struct {
	query builder.Query
}

func (r userToFollowersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToFollowersDeleteUnique) userModel() {}

func (r userToFollowersDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowersDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToFollowersFindFirst struct {
	query builder.Query
}

func (r userToFollowersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToFollowersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowersFindFirst) with()         {}
func (r userToFollowersFindFirst) userModel()    {}
func (r userToFollowersFindFirst) userRelation() {}

func (r userToFollowersFindFirst) With(params ...FollowsRelationWith) userToFollowersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToFollowersFindFirst) Select(params ...userPrismaFields) userToFollowersFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowersFindFirst) Omit(params ...userPrismaFields) userToFollowersFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowersFindFirst) OrderBy(params ...FollowsOrderByParam) userToFollowersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToFollowersFindFirst) Skip(count int) userToFollowersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToFollowersFindFirst) Take(count int) userToFollowersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToFollowersFindFirst) Cursor(cursor UserCursorParam) userToFollowersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToFollowersFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToFollowersFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToFollowersFindMany struct {
	query builder.Query
}

func (r userToFollowersFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToFollowersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowersFindMany) with()         {}
func (r userToFollowersFindMany) userModel()    {}
func (r userToFollowersFindMany) userRelation() {}

func (r userToFollowersFindMany) With(params ...FollowsRelationWith) userToFollowersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToFollowersFindMany) Select(params ...userPrismaFields) userToFollowersFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowersFindMany) Omit(params ...userPrismaFields) userToFollowersFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowersFindMany) OrderBy(params ...FollowsOrderByParam) userToFollowersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToFollowersFindMany) Skip(count int) userToFollowersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToFollowersFindMany) Take(count int) userToFollowersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToFollowersFindMany) Cursor(cursor UserCursorParam) userToFollowersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToFollowersFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToFollowersFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToFollowersFindMany) Update(params ...UserSetParam) userToFollowersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToFollowersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToFollowersUpdateMany struct {
	query builder.Query
}

func (r userToFollowersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowersUpdateMany) userModel() {}

func (r userToFollowersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowersUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToFollowersFindMany) Delete() userToFollowersDeleteMany {
	var v userToFollowersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToFollowersDeleteMany struct {
	query builder.Query
}

func (r userToFollowersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToFollowersDeleteMany) userModel() {}

func (r userToFollowersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowersDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToFollowingFindUnique struct {
	query builder.Query
}

func (r userToFollowingFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToFollowingFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowingFindUnique) with()         {}
func (r userToFollowingFindUnique) userModel()    {}
func (r userToFollowingFindUnique) userRelation() {}

func (r userToFollowingFindUnique) With(params ...FollowsRelationWith) userToFollowingFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToFollowingFindUnique) Select(params ...userPrismaFields) userToFollowingFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowingFindUnique) Omit(params ...userPrismaFields) userToFollowingFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowingFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToFollowingFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToFollowingFindUnique) Update(params ...UserSetParam) userToFollowingUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToFollowingUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToFollowingUpdateUnique struct {
	query builder.Query
}

func (r userToFollowingUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowingUpdateUnique) userModel() {}

func (r userToFollowingUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowingUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToFollowingFindUnique) Delete() userToFollowingDeleteUnique {
	var v userToFollowingDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToFollowingDeleteUnique struct {
	query builder.Query
}

func (r userToFollowingDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToFollowingDeleteUnique) userModel() {}

func (r userToFollowingDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowingDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToFollowingFindFirst struct {
	query builder.Query
}

func (r userToFollowingFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToFollowingFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowingFindFirst) with()         {}
func (r userToFollowingFindFirst) userModel()    {}
func (r userToFollowingFindFirst) userRelation() {}

func (r userToFollowingFindFirst) With(params ...FollowsRelationWith) userToFollowingFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToFollowingFindFirst) Select(params ...userPrismaFields) userToFollowingFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowingFindFirst) Omit(params ...userPrismaFields) userToFollowingFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowingFindFirst) OrderBy(params ...FollowsOrderByParam) userToFollowingFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToFollowingFindFirst) Skip(count int) userToFollowingFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToFollowingFindFirst) Take(count int) userToFollowingFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToFollowingFindFirst) Cursor(cursor UserCursorParam) userToFollowingFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToFollowingFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToFollowingFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToFollowingFindMany struct {
	query builder.Query
}

func (r userToFollowingFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToFollowingFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowingFindMany) with()         {}
func (r userToFollowingFindMany) userModel()    {}
func (r userToFollowingFindMany) userRelation() {}

func (r userToFollowingFindMany) With(params ...FollowsRelationWith) userToFollowingFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToFollowingFindMany) Select(params ...userPrismaFields) userToFollowingFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowingFindMany) Omit(params ...userPrismaFields) userToFollowingFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToFollowingFindMany) OrderBy(params ...FollowsOrderByParam) userToFollowingFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToFollowingFindMany) Skip(count int) userToFollowingFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToFollowingFindMany) Take(count int) userToFollowingFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToFollowingFindMany) Cursor(cursor UserCursorParam) userToFollowingFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToFollowingFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToFollowingFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToFollowingFindMany) Update(params ...UserSetParam) userToFollowingUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToFollowingUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToFollowingUpdateMany struct {
	query builder.Query
}

func (r userToFollowingUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToFollowingUpdateMany) userModel() {}

func (r userToFollowingUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowingUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToFollowingFindMany) Delete() userToFollowingDeleteMany {
	var v userToFollowingDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToFollowingDeleteMany struct {
	query builder.Query
}

func (r userToFollowingDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToFollowingDeleteMany) userModel() {}

func (r userToFollowingDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToFollowingDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToTagFindUnique struct {
	query builder.Query
}

func (r userToTagFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToTagFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTagFindUnique) with()         {}
func (r userToTagFindUnique) userModel()    {}
func (r userToTagFindUnique) userRelation() {}

func (r userToTagFindUnique) With(params ...TagRelationWith) userToTagFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToTagFindUnique) Select(params ...userPrismaFields) userToTagFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTagFindUnique) Omit(params ...userPrismaFields) userToTagFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTagFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToTagFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToTagFindUnique) Update(params ...UserSetParam) userToTagUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToTagUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToTagUpdateUnique struct {
	query builder.Query
}

func (r userToTagUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTagUpdateUnique) userModel() {}

func (r userToTagUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTagUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToTagFindUnique) Delete() userToTagDeleteUnique {
	var v userToTagDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToTagDeleteUnique struct {
	query builder.Query
}

func (r userToTagDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToTagDeleteUnique) userModel() {}

func (r userToTagDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTagDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToTagFindFirst struct {
	query builder.Query
}

func (r userToTagFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToTagFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTagFindFirst) with()         {}
func (r userToTagFindFirst) userModel()    {}
func (r userToTagFindFirst) userRelation() {}

func (r userToTagFindFirst) With(params ...TagRelationWith) userToTagFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToTagFindFirst) Select(params ...userPrismaFields) userToTagFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTagFindFirst) Omit(params ...userPrismaFields) userToTagFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTagFindFirst) OrderBy(params ...TagOrderByParam) userToTagFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToTagFindFirst) Skip(count int) userToTagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToTagFindFirst) Take(count int) userToTagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToTagFindFirst) Cursor(cursor UserCursorParam) userToTagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToTagFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToTagFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToTagFindMany struct {
	query builder.Query
}

func (r userToTagFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToTagFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTagFindMany) with()         {}
func (r userToTagFindMany) userModel()    {}
func (r userToTagFindMany) userRelation() {}

func (r userToTagFindMany) With(params ...TagRelationWith) userToTagFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToTagFindMany) Select(params ...userPrismaFields) userToTagFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTagFindMany) Omit(params ...userPrismaFields) userToTagFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTagFindMany) OrderBy(params ...TagOrderByParam) userToTagFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToTagFindMany) Skip(count int) userToTagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToTagFindMany) Take(count int) userToTagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToTagFindMany) Cursor(cursor UserCursorParam) userToTagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToTagFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToTagFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToTagFindMany) Update(params ...UserSetParam) userToTagUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToTagUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToTagUpdateMany struct {
	query builder.Query
}

func (r userToTagUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTagUpdateMany) userModel() {}

func (r userToTagUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTagUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToTagFindMany) Delete() userToTagDeleteMany {
	var v userToTagDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToTagDeleteMany struct {
	query builder.Query
}

func (r userToTagDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToTagDeleteMany) userModel() {}

func (r userToTagDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTagDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Select(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Omit(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) Select(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) Omit(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) Select(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) Omit(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToUserFindUnique struct {
	query builder.Query
}

func (r postToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToUserFindUnique) with()         {}
func (r postToUserFindUnique) postModel()    {}
func (r postToUserFindUnique) postRelation() {}

func (r postToUserFindUnique) With(params ...UserRelationWith) postToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToUserFindUnique) Select(params ...postPrismaFields) postToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToUserFindUnique) Omit(params ...postPrismaFields) postToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToUserFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToUserFindUnique) Update(params ...PostSetParam) postToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToUserUpdateUnique struct {
	query builder.Query
}

func (r postToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToUserUpdateUnique) postModel() {}

func (r postToUserUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToUserUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToUserFindUnique) Delete() postToUserDeleteUnique {
	var v postToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToUserDeleteUnique struct {
	query builder.Query
}

func (r postToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToUserDeleteUnique) postModel() {}

func (r postToUserDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToUserDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToUserFindFirst struct {
	query builder.Query
}

func (r postToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToUserFindFirst) with()         {}
func (r postToUserFindFirst) postModel()    {}
func (r postToUserFindFirst) postRelation() {}

func (r postToUserFindFirst) With(params ...UserRelationWith) postToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToUserFindFirst) Select(params ...postPrismaFields) postToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToUserFindFirst) Omit(params ...postPrismaFields) postToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToUserFindFirst) OrderBy(params ...UserOrderByParam) postToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToUserFindFirst) Skip(count int) postToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToUserFindFirst) Take(count int) postToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToUserFindFirst) Cursor(cursor PostCursorParam) postToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToUserFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToUserFindMany struct {
	query builder.Query
}

func (r postToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToUserFindMany) with()         {}
func (r postToUserFindMany) postModel()    {}
func (r postToUserFindMany) postRelation() {}

func (r postToUserFindMany) With(params ...UserRelationWith) postToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToUserFindMany) Select(params ...postPrismaFields) postToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToUserFindMany) Omit(params ...postPrismaFields) postToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToUserFindMany) OrderBy(params ...UserOrderByParam) postToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToUserFindMany) Skip(count int) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToUserFindMany) Take(count int) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToUserFindMany) Cursor(cursor PostCursorParam) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToUserFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToUserFindMany) Update(params ...PostSetParam) postToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToUserUpdateMany struct {
	query builder.Query
}

func (r postToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToUserUpdateMany) postModel() {}

func (r postToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToUserUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToUserFindMany) Delete() postToUserDeleteMany {
	var v postToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToUserDeleteMany struct {
	query builder.Query
}

func (r postToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToUserDeleteMany) postModel() {}

func (r postToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToUserDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToLikesFindUnique struct {
	query builder.Query
}

func (r postToLikesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToLikesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToLikesFindUnique) with()         {}
func (r postToLikesFindUnique) postModel()    {}
func (r postToLikesFindUnique) postRelation() {}

func (r postToLikesFindUnique) With(params ...LikeRelationWith) postToLikesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToLikesFindUnique) Select(params ...postPrismaFields) postToLikesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToLikesFindUnique) Omit(params ...postPrismaFields) postToLikesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToLikesFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToLikesFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToLikesFindUnique) Update(params ...PostSetParam) postToLikesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToLikesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToLikesUpdateUnique struct {
	query builder.Query
}

func (r postToLikesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToLikesUpdateUnique) postModel() {}

func (r postToLikesUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToLikesUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToLikesFindUnique) Delete() postToLikesDeleteUnique {
	var v postToLikesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToLikesDeleteUnique struct {
	query builder.Query
}

func (r postToLikesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToLikesDeleteUnique) postModel() {}

func (r postToLikesDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToLikesDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToLikesFindFirst struct {
	query builder.Query
}

func (r postToLikesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToLikesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToLikesFindFirst) with()         {}
func (r postToLikesFindFirst) postModel()    {}
func (r postToLikesFindFirst) postRelation() {}

func (r postToLikesFindFirst) With(params ...LikeRelationWith) postToLikesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToLikesFindFirst) Select(params ...postPrismaFields) postToLikesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToLikesFindFirst) Omit(params ...postPrismaFields) postToLikesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToLikesFindFirst) OrderBy(params ...LikeOrderByParam) postToLikesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToLikesFindFirst) Skip(count int) postToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToLikesFindFirst) Take(count int) postToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToLikesFindFirst) Cursor(cursor PostCursorParam) postToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToLikesFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToLikesFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToLikesFindMany struct {
	query builder.Query
}

func (r postToLikesFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToLikesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToLikesFindMany) with()         {}
func (r postToLikesFindMany) postModel()    {}
func (r postToLikesFindMany) postRelation() {}

func (r postToLikesFindMany) With(params ...LikeRelationWith) postToLikesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToLikesFindMany) Select(params ...postPrismaFields) postToLikesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToLikesFindMany) Omit(params ...postPrismaFields) postToLikesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToLikesFindMany) OrderBy(params ...LikeOrderByParam) postToLikesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToLikesFindMany) Skip(count int) postToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToLikesFindMany) Take(count int) postToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToLikesFindMany) Cursor(cursor PostCursorParam) postToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToLikesFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToLikesFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToLikesFindMany) Update(params ...PostSetParam) postToLikesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToLikesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToLikesUpdateMany struct {
	query builder.Query
}

func (r postToLikesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToLikesUpdateMany) postModel() {}

func (r postToLikesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToLikesUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToLikesFindMany) Delete() postToLikesDeleteMany {
	var v postToLikesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToLikesDeleteMany struct {
	query builder.Query
}

func (r postToLikesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToLikesDeleteMany) postModel() {}

func (r postToLikesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToLikesDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToCommentsFindUnique struct {
	query builder.Query
}

func (r postToCommentsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindUnique) with()         {}
func (r postToCommentsFindUnique) postModel()    {}
func (r postToCommentsFindUnique) postRelation() {}

func (r postToCommentsFindUnique) With(params ...CommentRelationWith) postToCommentsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToCommentsFindUnique) Select(params ...postPrismaFields) postToCommentsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindUnique) Omit(params ...postPrismaFields) postToCommentsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToCommentsFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToCommentsFindUnique) Update(params ...PostSetParam) postToCommentsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToCommentsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToCommentsUpdateUnique struct {
	query builder.Query
}

func (r postToCommentsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsUpdateUnique) postModel() {}

func (r postToCommentsUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToCommentsFindUnique) Delete() postToCommentsDeleteUnique {
	var v postToCommentsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToCommentsDeleteUnique struct {
	query builder.Query
}

func (r postToCommentsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToCommentsDeleteUnique) postModel() {}

func (r postToCommentsDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToCommentsFindFirst struct {
	query builder.Query
}

func (r postToCommentsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindFirst) with()         {}
func (r postToCommentsFindFirst) postModel()    {}
func (r postToCommentsFindFirst) postRelation() {}

func (r postToCommentsFindFirst) With(params ...CommentRelationWith) postToCommentsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToCommentsFindFirst) Select(params ...postPrismaFields) postToCommentsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindFirst) Omit(params ...postPrismaFields) postToCommentsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindFirst) OrderBy(params ...CommentOrderByParam) postToCommentsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToCommentsFindFirst) Skip(count int) postToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToCommentsFindFirst) Take(count int) postToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToCommentsFindFirst) Cursor(cursor PostCursorParam) postToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToCommentsFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToCommentsFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToCommentsFindMany struct {
	query builder.Query
}

func (r postToCommentsFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsFindMany) with()         {}
func (r postToCommentsFindMany) postModel()    {}
func (r postToCommentsFindMany) postRelation() {}

func (r postToCommentsFindMany) With(params ...CommentRelationWith) postToCommentsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToCommentsFindMany) Select(params ...postPrismaFields) postToCommentsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindMany) Omit(params ...postPrismaFields) postToCommentsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToCommentsFindMany) OrderBy(params ...CommentOrderByParam) postToCommentsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToCommentsFindMany) Skip(count int) postToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToCommentsFindMany) Take(count int) postToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToCommentsFindMany) Cursor(cursor PostCursorParam) postToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToCommentsFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToCommentsFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToCommentsFindMany) Update(params ...PostSetParam) postToCommentsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToCommentsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToCommentsUpdateMany struct {
	query builder.Query
}

func (r postToCommentsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToCommentsUpdateMany) postModel() {}

func (r postToCommentsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToCommentsFindMany) Delete() postToCommentsDeleteMany {
	var v postToCommentsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToCommentsDeleteMany struct {
	query builder.Query
}

func (r postToCommentsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToCommentsDeleteMany) postModel() {}

func (r postToCommentsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToCommentsDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToTagsFindUnique struct {
	query builder.Query
}

func (r postToTagsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToTagsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToTagsFindUnique) with()         {}
func (r postToTagsFindUnique) postModel()    {}
func (r postToTagsFindUnique) postRelation() {}

func (r postToTagsFindUnique) With(params ...TagRelationWith) postToTagsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToTagsFindUnique) Select(params ...postPrismaFields) postToTagsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToTagsFindUnique) Omit(params ...postPrismaFields) postToTagsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToTagsFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToTagsFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToTagsFindUnique) Update(params ...PostSetParam) postToTagsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToTagsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToTagsUpdateUnique struct {
	query builder.Query
}

func (r postToTagsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToTagsUpdateUnique) postModel() {}

func (r postToTagsUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToTagsUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToTagsFindUnique) Delete() postToTagsDeleteUnique {
	var v postToTagsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToTagsDeleteUnique struct {
	query builder.Query
}

func (r postToTagsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToTagsDeleteUnique) postModel() {}

func (r postToTagsDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToTagsDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToTagsFindFirst struct {
	query builder.Query
}

func (r postToTagsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToTagsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToTagsFindFirst) with()         {}
func (r postToTagsFindFirst) postModel()    {}
func (r postToTagsFindFirst) postRelation() {}

func (r postToTagsFindFirst) With(params ...TagRelationWith) postToTagsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToTagsFindFirst) Select(params ...postPrismaFields) postToTagsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToTagsFindFirst) Omit(params ...postPrismaFields) postToTagsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToTagsFindFirst) OrderBy(params ...TagOrderByParam) postToTagsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToTagsFindFirst) Skip(count int) postToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToTagsFindFirst) Take(count int) postToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToTagsFindFirst) Cursor(cursor PostCursorParam) postToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToTagsFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToTagsFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToTagsFindMany struct {
	query builder.Query
}

func (r postToTagsFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToTagsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToTagsFindMany) with()         {}
func (r postToTagsFindMany) postModel()    {}
func (r postToTagsFindMany) postRelation() {}

func (r postToTagsFindMany) With(params ...TagRelationWith) postToTagsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToTagsFindMany) Select(params ...postPrismaFields) postToTagsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToTagsFindMany) Omit(params ...postPrismaFields) postToTagsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToTagsFindMany) OrderBy(params ...TagOrderByParam) postToTagsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToTagsFindMany) Skip(count int) postToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToTagsFindMany) Take(count int) postToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToTagsFindMany) Cursor(cursor PostCursorParam) postToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToTagsFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToTagsFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToTagsFindMany) Update(params ...PostSetParam) postToTagsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToTagsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToTagsUpdateMany struct {
	query builder.Query
}

func (r postToTagsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToTagsUpdateMany) postModel() {}

func (r postToTagsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToTagsUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToTagsFindMany) Delete() postToTagsDeleteMany {
	var v postToTagsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToTagsDeleteMany struct {
	query builder.Query
}

func (r postToTagsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToTagsDeleteMany) postModel() {}

func (r postToTagsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToTagsDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToRestaurantFindUnique struct {
	query builder.Query
}

func (r postToRestaurantFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToRestaurantFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRestaurantFindUnique) with()         {}
func (r postToRestaurantFindUnique) postModel()    {}
func (r postToRestaurantFindUnique) postRelation() {}

func (r postToRestaurantFindUnique) With(params ...RestaurantRelationWith) postToRestaurantFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToRestaurantFindUnique) Select(params ...postPrismaFields) postToRestaurantFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRestaurantFindUnique) Omit(params ...postPrismaFields) postToRestaurantFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRestaurantFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToRestaurantFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToRestaurantFindUnique) Update(params ...PostSetParam) postToRestaurantUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToRestaurantUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToRestaurantUpdateUnique struct {
	query builder.Query
}

func (r postToRestaurantUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRestaurantUpdateUnique) postModel() {}

func (r postToRestaurantUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRestaurantUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToRestaurantFindUnique) Delete() postToRestaurantDeleteUnique {
	var v postToRestaurantDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToRestaurantDeleteUnique struct {
	query builder.Query
}

func (r postToRestaurantDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToRestaurantDeleteUnique) postModel() {}

func (r postToRestaurantDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRestaurantDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToRestaurantFindFirst struct {
	query builder.Query
}

func (r postToRestaurantFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToRestaurantFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRestaurantFindFirst) with()         {}
func (r postToRestaurantFindFirst) postModel()    {}
func (r postToRestaurantFindFirst) postRelation() {}

func (r postToRestaurantFindFirst) With(params ...RestaurantRelationWith) postToRestaurantFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToRestaurantFindFirst) Select(params ...postPrismaFields) postToRestaurantFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRestaurantFindFirst) Omit(params ...postPrismaFields) postToRestaurantFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRestaurantFindFirst) OrderBy(params ...RestaurantOrderByParam) postToRestaurantFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToRestaurantFindFirst) Skip(count int) postToRestaurantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToRestaurantFindFirst) Take(count int) postToRestaurantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToRestaurantFindFirst) Cursor(cursor PostCursorParam) postToRestaurantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToRestaurantFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToRestaurantFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToRestaurantFindMany struct {
	query builder.Query
}

func (r postToRestaurantFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToRestaurantFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRestaurantFindMany) with()         {}
func (r postToRestaurantFindMany) postModel()    {}
func (r postToRestaurantFindMany) postRelation() {}

func (r postToRestaurantFindMany) With(params ...RestaurantRelationWith) postToRestaurantFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToRestaurantFindMany) Select(params ...postPrismaFields) postToRestaurantFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRestaurantFindMany) Omit(params ...postPrismaFields) postToRestaurantFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRestaurantFindMany) OrderBy(params ...RestaurantOrderByParam) postToRestaurantFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToRestaurantFindMany) Skip(count int) postToRestaurantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToRestaurantFindMany) Take(count int) postToRestaurantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToRestaurantFindMany) Cursor(cursor PostCursorParam) postToRestaurantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToRestaurantFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToRestaurantFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToRestaurantFindMany) Update(params ...PostSetParam) postToRestaurantUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToRestaurantUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToRestaurantUpdateMany struct {
	query builder.Query
}

func (r postToRestaurantUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRestaurantUpdateMany) postModel() {}

func (r postToRestaurantUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRestaurantUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToRestaurantFindMany) Delete() postToRestaurantDeleteMany {
	var v postToRestaurantDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToRestaurantDeleteMany struct {
	query builder.Query
}

func (r postToRestaurantDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToRestaurantDeleteMany) postModel() {}

func (r postToRestaurantDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRestaurantDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToOriginalPostFindUnique struct {
	query builder.Query
}

func (r postToOriginalPostFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostFindUnique) with()         {}
func (r postToOriginalPostFindUnique) postModel()    {}
func (r postToOriginalPostFindUnique) postRelation() {}

func (r postToOriginalPostFindUnique) With(params ...PostRelationWith) postToOriginalPostFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToOriginalPostFindUnique) Select(params ...postPrismaFields) postToOriginalPostFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToOriginalPostFindUnique) Omit(params ...postPrismaFields) postToOriginalPostFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToOriginalPostFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToOriginalPostFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToOriginalPostFindUnique) Update(params ...PostSetParam) postToOriginalPostUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToOriginalPostUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToOriginalPostUpdateUnique struct {
	query builder.Query
}

func (r postToOriginalPostUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostUpdateUnique) postModel() {}

func (r postToOriginalPostUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToOriginalPostUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToOriginalPostFindUnique) Delete() postToOriginalPostDeleteUnique {
	var v postToOriginalPostDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToOriginalPostDeleteUnique struct {
	query builder.Query
}

func (r postToOriginalPostDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToOriginalPostDeleteUnique) postModel() {}

func (r postToOriginalPostDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToOriginalPostDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToOriginalPostFindFirst struct {
	query builder.Query
}

func (r postToOriginalPostFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostFindFirst) with()         {}
func (r postToOriginalPostFindFirst) postModel()    {}
func (r postToOriginalPostFindFirst) postRelation() {}

func (r postToOriginalPostFindFirst) With(params ...PostRelationWith) postToOriginalPostFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToOriginalPostFindFirst) Select(params ...postPrismaFields) postToOriginalPostFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToOriginalPostFindFirst) Omit(params ...postPrismaFields) postToOriginalPostFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToOriginalPostFindFirst) OrderBy(params ...PostOrderByParam) postToOriginalPostFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToOriginalPostFindFirst) Skip(count int) postToOriginalPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToOriginalPostFindFirst) Take(count int) postToOriginalPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToOriginalPostFindFirst) Cursor(cursor PostCursorParam) postToOriginalPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToOriginalPostFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToOriginalPostFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToOriginalPostFindMany struct {
	query builder.Query
}

func (r postToOriginalPostFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostFindMany) with()         {}
func (r postToOriginalPostFindMany) postModel()    {}
func (r postToOriginalPostFindMany) postRelation() {}

func (r postToOriginalPostFindMany) With(params ...PostRelationWith) postToOriginalPostFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToOriginalPostFindMany) Select(params ...postPrismaFields) postToOriginalPostFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToOriginalPostFindMany) Omit(params ...postPrismaFields) postToOriginalPostFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToOriginalPostFindMany) OrderBy(params ...PostOrderByParam) postToOriginalPostFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToOriginalPostFindMany) Skip(count int) postToOriginalPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToOriginalPostFindMany) Take(count int) postToOriginalPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToOriginalPostFindMany) Cursor(cursor PostCursorParam) postToOriginalPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToOriginalPostFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToOriginalPostFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToOriginalPostFindMany) Update(params ...PostSetParam) postToOriginalPostUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToOriginalPostUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToOriginalPostUpdateMany struct {
	query builder.Query
}

func (r postToOriginalPostUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToOriginalPostUpdateMany) postModel() {}

func (r postToOriginalPostUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToOriginalPostUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToOriginalPostFindMany) Delete() postToOriginalPostDeleteMany {
	var v postToOriginalPostDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToOriginalPostDeleteMany struct {
	query builder.Query
}

func (r postToOriginalPostDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToOriginalPostDeleteMany) postModel() {}

func (r postToOriginalPostDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToOriginalPostDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToRepostedPostsFindUnique struct {
	query builder.Query
}

func (r postToRepostedPostsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsFindUnique) with()         {}
func (r postToRepostedPostsFindUnique) postModel()    {}
func (r postToRepostedPostsFindUnique) postRelation() {}

func (r postToRepostedPostsFindUnique) With(params ...PostRelationWith) postToRepostedPostsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToRepostedPostsFindUnique) Select(params ...postPrismaFields) postToRepostedPostsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRepostedPostsFindUnique) Omit(params ...postPrismaFields) postToRepostedPostsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRepostedPostsFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToRepostedPostsFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToRepostedPostsFindUnique) Update(params ...PostSetParam) postToRepostedPostsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postToRepostedPostsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToRepostedPostsUpdateUnique struct {
	query builder.Query
}

func (r postToRepostedPostsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsUpdateUnique) postModel() {}

func (r postToRepostedPostsUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRepostedPostsUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToRepostedPostsFindUnique) Delete() postToRepostedPostsDeleteUnique {
	var v postToRepostedPostsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postToRepostedPostsDeleteUnique struct {
	query builder.Query
}

func (r postToRepostedPostsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postToRepostedPostsDeleteUnique) postModel() {}

func (r postToRepostedPostsDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRepostedPostsDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postToRepostedPostsFindFirst struct {
	query builder.Query
}

func (r postToRepostedPostsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsFindFirst) with()         {}
func (r postToRepostedPostsFindFirst) postModel()    {}
func (r postToRepostedPostsFindFirst) postRelation() {}

func (r postToRepostedPostsFindFirst) With(params ...PostRelationWith) postToRepostedPostsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToRepostedPostsFindFirst) Select(params ...postPrismaFields) postToRepostedPostsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRepostedPostsFindFirst) Omit(params ...postPrismaFields) postToRepostedPostsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRepostedPostsFindFirst) OrderBy(params ...PostOrderByParam) postToRepostedPostsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToRepostedPostsFindFirst) Skip(count int) postToRepostedPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToRepostedPostsFindFirst) Take(count int) postToRepostedPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToRepostedPostsFindFirst) Cursor(cursor PostCursorParam) postToRepostedPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToRepostedPostsFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postToRepostedPostsFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postToRepostedPostsFindMany struct {
	query builder.Query
}

func (r postToRepostedPostsFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsFindMany) with()         {}
func (r postToRepostedPostsFindMany) postModel()    {}
func (r postToRepostedPostsFindMany) postRelation() {}

func (r postToRepostedPostsFindMany) With(params ...PostRelationWith) postToRepostedPostsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToRepostedPostsFindMany) Select(params ...postPrismaFields) postToRepostedPostsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRepostedPostsFindMany) Omit(params ...postPrismaFields) postToRepostedPostsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postToRepostedPostsFindMany) OrderBy(params ...PostOrderByParam) postToRepostedPostsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postToRepostedPostsFindMany) Skip(count int) postToRepostedPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToRepostedPostsFindMany) Take(count int) postToRepostedPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postToRepostedPostsFindMany) Cursor(cursor PostCursorParam) postToRepostedPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToRepostedPostsFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToRepostedPostsFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postToRepostedPostsFindMany) Update(params ...PostSetParam) postToRepostedPostsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postToRepostedPostsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToRepostedPostsUpdateMany struct {
	query builder.Query
}

func (r postToRepostedPostsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postToRepostedPostsUpdateMany) postModel() {}

func (r postToRepostedPostsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRepostedPostsUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postToRepostedPostsFindMany) Delete() postToRepostedPostsDeleteMany {
	var v postToRepostedPostsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postToRepostedPostsDeleteMany struct {
	query builder.Query
}

func (r postToRepostedPostsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postToRepostedPostsDeleteMany) postModel() {}

func (r postToRepostedPostsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postToRepostedPostsDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postFindUnique struct {
	query builder.Query
}

func (r postFindUnique) getQuery() builder.Query {
	return r.query
}

func (r postFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindUnique) with()         {}
func (r postFindUnique) postModel()    {}
func (r postFindUnique) postRelation() {}

func (r postActions) FindUnique(
	params PostEqualsUniqueWhereParam,
) postFindUnique {
	var v postFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r postFindUnique) With(params ...PostRelationWith) postFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindUnique) Select(params ...postPrismaFields) postFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindUnique) Omit(params ...postPrismaFields) postFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindUnique) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindUnique) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindUnique) Update(params ...PostSetParam) postUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"

	var v postUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateUnique struct {
	query builder.Query
}

func (r postUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpdateUnique) postModel() {}

func (r postUpdateUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpdateUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postFindUnique) Delete() postDeleteUnique {
	var v postDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"

	return v
}

type postDeleteUnique struct {
	query builder.Query
}

func (r postDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p postDeleteUnique) postModel() {}

func (r postDeleteUnique) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postDeleteUnique) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postFindFirst struct {
	query builder.Query
}

func (r postFindFirst) getQuery() builder.Query {
	return r.query
}

func (r postFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindFirst) with()         {}
func (r postFindFirst) postModel()    {}
func (r postFindFirst) postRelation() {}

func (r postActions) FindFirst(
	params ...PostWhereParam,
) postFindFirst {
	var v postFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postFindFirst) With(params ...PostRelationWith) postFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindFirst) Select(params ...postPrismaFields) postFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindFirst) Omit(params ...postPrismaFields) postFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindFirst) OrderBy(params ...PostOrderByParam) postFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postFindFirst) Skip(count int) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postFindFirst) Take(count int) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postFindFirst) Cursor(cursor PostCursorParam) postFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindFirst) Exec(ctx context.Context) (
	*PostModel,
	error,
) {
	var v *PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r postFindFirst) ExecInner(ctx context.Context) (
	*InnerPost,
	error,
) {
	var v *InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type postFindMany struct {
	query builder.Query
}

func (r postFindMany) getQuery() builder.Query {
	return r.query
}

func (r postFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postFindMany) with()         {}
func (r postFindMany) postModel()    {}
func (r postFindMany) postRelation() {}

func (r postActions) FindMany(
	params ...PostWhereParam,
) postFindMany {
	var v postFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postFindMany) With(params ...PostRelationWith) postFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindMany) Select(params ...postPrismaFields) postFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindMany) Omit(params ...postPrismaFields) postFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range postOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r postFindMany) OrderBy(params ...PostOrderByParam) postFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r postFindMany) Skip(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postFindMany) Take(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r postFindMany) Cursor(cursor PostCursorParam) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v []PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postFindMany) ExecInner(ctx context.Context) (
	[]InnerPost,
	error,
) {
	var v []InnerPost
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r postFindMany) Update(params ...PostSetParam) postUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"

	r.query.Outputs = countOutput

	var v postUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateMany struct {
	query builder.Query
}

func (r postUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpdateMany) postModel() {}

func (r postUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpdateMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r postFindMany) Delete() postDeleteMany {
	var v postDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"

	v.query.Outputs = countOutput

	return v
}

type postDeleteMany struct {
	query builder.Query
}

func (r postDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p postDeleteMany) postModel() {}

func (r postDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postDeleteMany) Tx() PostManyTxResult {
	v := newPostManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToPostFindUnique struct {
	query builder.Query
}

func (r commentToPostFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentToPostFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostFindUnique) with()            {}
func (r commentToPostFindUnique) commentModel()    {}
func (r commentToPostFindUnique) commentRelation() {}

func (r commentToPostFindUnique) With(params ...PostRelationWith) commentToPostFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToPostFindUnique) Select(params ...commentPrismaFields) commentToPostFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindUnique) Omit(params ...commentPrismaFields) commentToPostFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindUnique) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToPostFindUnique) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToPostFindUnique) Update(params ...CommentSetParam) commentToPostUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comment"

	var v commentToPostUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToPostUpdateUnique struct {
	query builder.Query
}

func (r commentToPostUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostUpdateUnique) commentModel() {}

func (r commentToPostUpdateUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostUpdateUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToPostFindUnique) Delete() commentToPostDeleteUnique {
	var v commentToPostDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comment"

	return v
}

type commentToPostDeleteUnique struct {
	query builder.Query
}

func (r commentToPostDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToPostDeleteUnique) commentModel() {}

func (r commentToPostDeleteUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostDeleteUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToPostFindFirst struct {
	query builder.Query
}

func (r commentToPostFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentToPostFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostFindFirst) with()            {}
func (r commentToPostFindFirst) commentModel()    {}
func (r commentToPostFindFirst) commentRelation() {}

func (r commentToPostFindFirst) With(params ...PostRelationWith) commentToPostFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToPostFindFirst) Select(params ...commentPrismaFields) commentToPostFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindFirst) Omit(params ...commentPrismaFields) commentToPostFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindFirst) OrderBy(params ...PostOrderByParam) commentToPostFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToPostFindFirst) Skip(count int) commentToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToPostFindFirst) Take(count int) commentToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToPostFindFirst) Cursor(cursor CommentCursorParam) commentToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToPostFindFirst) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToPostFindFirst) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentToPostFindMany struct {
	query builder.Query
}

func (r commentToPostFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentToPostFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostFindMany) with()            {}
func (r commentToPostFindMany) commentModel()    {}
func (r commentToPostFindMany) commentRelation() {}

func (r commentToPostFindMany) With(params ...PostRelationWith) commentToPostFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToPostFindMany) Select(params ...commentPrismaFields) commentToPostFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindMany) Omit(params ...commentPrismaFields) commentToPostFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToPostFindMany) OrderBy(params ...PostOrderByParam) commentToPostFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToPostFindMany) Skip(count int) commentToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToPostFindMany) Take(count int) commentToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToPostFindMany) Cursor(cursor CommentCursorParam) commentToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToPostFindMany) Exec(ctx context.Context) (
	[]CommentModel,
	error,
) {
	var v []CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToPostFindMany) ExecInner(ctx context.Context) (
	[]InnerComment,
	error,
) {
	var v []InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToPostFindMany) Update(params ...CommentSetParam) commentToPostUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comment"

	r.query.Outputs = countOutput

	var v commentToPostUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToPostUpdateMany struct {
	query builder.Query
}

func (r commentToPostUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToPostUpdateMany) commentModel() {}

func (r commentToPostUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostUpdateMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToPostFindMany) Delete() commentToPostDeleteMany {
	var v commentToPostDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comment"

	v.query.Outputs = countOutput

	return v
}

type commentToPostDeleteMany struct {
	query builder.Query
}

func (r commentToPostDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToPostDeleteMany) commentModel() {}

func (r commentToPostDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToPostDeleteMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToUserFindUnique struct {
	query builder.Query
}

func (r commentToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserFindUnique) with()            {}
func (r commentToUserFindUnique) commentModel()    {}
func (r commentToUserFindUnique) commentRelation() {}

func (r commentToUserFindUnique) With(params ...UserRelationWith) commentToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToUserFindUnique) Select(params ...commentPrismaFields) commentToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindUnique) Omit(params ...commentPrismaFields) commentToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindUnique) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToUserFindUnique) Update(params ...CommentSetParam) commentToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comment"

	var v commentToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToUserUpdateUnique struct {
	query builder.Query
}

func (r commentToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserUpdateUnique) commentModel() {}

func (r commentToUserUpdateUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserUpdateUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToUserFindUnique) Delete() commentToUserDeleteUnique {
	var v commentToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comment"

	return v
}

type commentToUserDeleteUnique struct {
	query builder.Query
}

func (r commentToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToUserDeleteUnique) commentModel() {}

func (r commentToUserDeleteUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserDeleteUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentToUserFindFirst struct {
	query builder.Query
}

func (r commentToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserFindFirst) with()            {}
func (r commentToUserFindFirst) commentModel()    {}
func (r commentToUserFindFirst) commentRelation() {}

func (r commentToUserFindFirst) With(params ...UserRelationWith) commentToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToUserFindFirst) Select(params ...commentPrismaFields) commentToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindFirst) Omit(params ...commentPrismaFields) commentToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindFirst) OrderBy(params ...UserOrderByParam) commentToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToUserFindFirst) Skip(count int) commentToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToUserFindFirst) Take(count int) commentToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToUserFindFirst) Cursor(cursor CommentCursorParam) commentToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToUserFindFirst) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentToUserFindMany struct {
	query builder.Query
}

func (r commentToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserFindMany) with()            {}
func (r commentToUserFindMany) commentModel()    {}
func (r commentToUserFindMany) commentRelation() {}

func (r commentToUserFindMany) With(params ...UserRelationWith) commentToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentToUserFindMany) Select(params ...commentPrismaFields) commentToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindMany) Omit(params ...commentPrismaFields) commentToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentToUserFindMany) OrderBy(params ...UserOrderByParam) commentToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentToUserFindMany) Skip(count int) commentToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentToUserFindMany) Take(count int) commentToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentToUserFindMany) Cursor(cursor CommentCursorParam) commentToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentToUserFindMany) Exec(ctx context.Context) (
	[]CommentModel,
	error,
) {
	var v []CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerComment,
	error,
) {
	var v []InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentToUserFindMany) Update(params ...CommentSetParam) commentToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comment"

	r.query.Outputs = countOutput

	var v commentToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentToUserUpdateMany struct {
	query builder.Query
}

func (r commentToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentToUserUpdateMany) commentModel() {}

func (r commentToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserUpdateMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentToUserFindMany) Delete() commentToUserDeleteMany {
	var v commentToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comment"

	v.query.Outputs = countOutput

	return v
}

type commentToUserDeleteMany struct {
	query builder.Query
}

func (r commentToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentToUserDeleteMany) commentModel() {}

func (r commentToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentToUserDeleteMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentFindUnique struct {
	query builder.Query
}

func (r commentFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentFindUnique) with()            {}
func (r commentFindUnique) commentModel()    {}
func (r commentFindUnique) commentRelation() {}

func (r commentActions) FindUnique(
	params CommentEqualsUniqueWhereParam,
) commentFindUnique {
	var v commentFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r commentFindUnique) With(params ...CommentRelationWith) commentFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentFindUnique) Select(params ...commentPrismaFields) commentFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindUnique) Omit(params ...commentPrismaFields) commentFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindUnique) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentFindUnique) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentFindUnique) Update(params ...CommentSetParam) commentUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comment"

	var v commentUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentUpdateUnique struct {
	query builder.Query
}

func (r commentUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentUpdateUnique) commentModel() {}

func (r commentUpdateUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentUpdateUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentFindUnique) Delete() commentDeleteUnique {
	var v commentDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comment"

	return v
}

type commentDeleteUnique struct {
	query builder.Query
}

func (r commentDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentDeleteUnique) commentModel() {}

func (r commentDeleteUnique) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentDeleteUnique) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentFindFirst struct {
	query builder.Query
}

func (r commentFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentFindFirst) with()            {}
func (r commentFindFirst) commentModel()    {}
func (r commentFindFirst) commentRelation() {}

func (r commentActions) FindFirst(
	params ...CommentWhereParam,
) commentFindFirst {
	var v commentFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r commentFindFirst) With(params ...CommentRelationWith) commentFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentFindFirst) Select(params ...commentPrismaFields) commentFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindFirst) Omit(params ...commentPrismaFields) commentFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindFirst) OrderBy(params ...CommentOrderByParam) commentFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentFindFirst) Skip(count int) commentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentFindFirst) Take(count int) commentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentFindFirst) Cursor(cursor CommentCursorParam) commentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentFindFirst) Exec(ctx context.Context) (
	*CommentModel,
	error,
) {
	var v *CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentFindFirst) ExecInner(ctx context.Context) (
	*InnerComment,
	error,
) {
	var v *InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentFindMany struct {
	query builder.Query
}

func (r commentFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentFindMany) with()            {}
func (r commentFindMany) commentModel()    {}
func (r commentFindMany) commentRelation() {}

func (r commentActions) FindMany(
	params ...CommentWhereParam,
) commentFindMany {
	var v commentFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r commentFindMany) With(params ...CommentRelationWith) commentFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentFindMany) Select(params ...commentPrismaFields) commentFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindMany) Omit(params ...commentPrismaFields) commentFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentFindMany) OrderBy(params ...CommentOrderByParam) commentFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentFindMany) Skip(count int) commentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentFindMany) Take(count int) commentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentFindMany) Cursor(cursor CommentCursorParam) commentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentFindMany) Exec(ctx context.Context) (
	[]CommentModel,
	error,
) {
	var v []CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentFindMany) ExecInner(ctx context.Context) (
	[]InnerComment,
	error,
) {
	var v []InnerComment
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentFindMany) Update(params ...CommentSetParam) commentUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comment"

	r.query.Outputs = countOutput

	var v commentUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentUpdateMany struct {
	query builder.Query
}

func (r commentUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentUpdateMany) commentModel() {}

func (r commentUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentUpdateMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentFindMany) Delete() commentDeleteMany {
	var v commentDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comment"

	v.query.Outputs = countOutput

	return v
}

type commentDeleteMany struct {
	query builder.Query
}

func (r commentDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentDeleteMany) commentModel() {}

func (r commentDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentDeleteMany) Tx() CommentManyTxResult {
	v := newCommentManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likeToPostFindUnique struct {
	query builder.Query
}

func (r likeToPostFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likeToPostFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToPostFindUnique) with()         {}
func (r likeToPostFindUnique) likeModel()    {}
func (r likeToPostFindUnique) likeRelation() {}

func (r likeToPostFindUnique) With(params ...PostRelationWith) likeToPostFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeToPostFindUnique) Select(params ...likePrismaFields) likeToPostFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToPostFindUnique) Omit(params ...likePrismaFields) likeToPostFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToPostFindUnique) Exec(ctx context.Context) (
	*LikeModel,
	error,
) {
	var v *LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeToPostFindUnique) ExecInner(ctx context.Context) (
	*InnerLike,
	error,
) {
	var v *InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeToPostFindUnique) Update(params ...LikeSetParam) likeToPostUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Like"

	var v likeToPostUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likeToPostUpdateUnique struct {
	query builder.Query
}

func (r likeToPostUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToPostUpdateUnique) likeModel() {}

func (r likeToPostUpdateUnique) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToPostUpdateUnique) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likeToPostFindUnique) Delete() likeToPostDeleteUnique {
	var v likeToPostDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Like"

	return v
}

type likeToPostDeleteUnique struct {
	query builder.Query
}

func (r likeToPostDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likeToPostDeleteUnique) likeModel() {}

func (r likeToPostDeleteUnique) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToPostDeleteUnique) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likeToPostFindFirst struct {
	query builder.Query
}

func (r likeToPostFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likeToPostFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToPostFindFirst) with()         {}
func (r likeToPostFindFirst) likeModel()    {}
func (r likeToPostFindFirst) likeRelation() {}

func (r likeToPostFindFirst) With(params ...PostRelationWith) likeToPostFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeToPostFindFirst) Select(params ...likePrismaFields) likeToPostFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToPostFindFirst) Omit(params ...likePrismaFields) likeToPostFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToPostFindFirst) OrderBy(params ...PostOrderByParam) likeToPostFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likeToPostFindFirst) Skip(count int) likeToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likeToPostFindFirst) Take(count int) likeToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likeToPostFindFirst) Cursor(cursor LikeCursorParam) likeToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likeToPostFindFirst) Exec(ctx context.Context) (
	*LikeModel,
	error,
) {
	var v *LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeToPostFindFirst) ExecInner(ctx context.Context) (
	*InnerLike,
	error,
) {
	var v *InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likeToPostFindMany struct {
	query builder.Query
}

func (r likeToPostFindMany) getQuery() builder.Query {
	return r.query
}

func (r likeToPostFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToPostFindMany) with()         {}
func (r likeToPostFindMany) likeModel()    {}
func (r likeToPostFindMany) likeRelation() {}

func (r likeToPostFindMany) With(params ...PostRelationWith) likeToPostFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeToPostFindMany) Select(params ...likePrismaFields) likeToPostFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToPostFindMany) Omit(params ...likePrismaFields) likeToPostFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToPostFindMany) OrderBy(params ...PostOrderByParam) likeToPostFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likeToPostFindMany) Skip(count int) likeToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likeToPostFindMany) Take(count int) likeToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likeToPostFindMany) Cursor(cursor LikeCursorParam) likeToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likeToPostFindMany) Exec(ctx context.Context) (
	[]LikeModel,
	error,
) {
	var v []LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likeToPostFindMany) ExecInner(ctx context.Context) (
	[]InnerLike,
	error,
) {
	var v []InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likeToPostFindMany) Update(params ...LikeSetParam) likeToPostUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Like"

	r.query.Outputs = countOutput

	var v likeToPostUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likeToPostUpdateMany struct {
	query builder.Query
}

func (r likeToPostUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToPostUpdateMany) likeModel() {}

func (r likeToPostUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToPostUpdateMany) Tx() LikeManyTxResult {
	v := newLikeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likeToPostFindMany) Delete() likeToPostDeleteMany {
	var v likeToPostDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Like"

	v.query.Outputs = countOutput

	return v
}

type likeToPostDeleteMany struct {
	query builder.Query
}

func (r likeToPostDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likeToPostDeleteMany) likeModel() {}

func (r likeToPostDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToPostDeleteMany) Tx() LikeManyTxResult {
	v := newLikeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likeToUserFindUnique struct {
	query builder.Query
}

func (r likeToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likeToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToUserFindUnique) with()         {}
func (r likeToUserFindUnique) likeModel()    {}
func (r likeToUserFindUnique) likeRelation() {}

func (r likeToUserFindUnique) With(params ...UserRelationWith) likeToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeToUserFindUnique) Select(params ...likePrismaFields) likeToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToUserFindUnique) Omit(params ...likePrismaFields) likeToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToUserFindUnique) Exec(ctx context.Context) (
	*LikeModel,
	error,
) {
	var v *LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerLike,
	error,
) {
	var v *InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeToUserFindUnique) Update(params ...LikeSetParam) likeToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Like"

	var v likeToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likeToUserUpdateUnique struct {
	query builder.Query
}

func (r likeToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToUserUpdateUnique) likeModel() {}

func (r likeToUserUpdateUnique) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToUserUpdateUnique) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likeToUserFindUnique) Delete() likeToUserDeleteUnique {
	var v likeToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Like"

	return v
}

type likeToUserDeleteUnique struct {
	query builder.Query
}

func (r likeToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likeToUserDeleteUnique) likeModel() {}

func (r likeToUserDeleteUnique) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToUserDeleteUnique) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likeToUserFindFirst struct {
	query builder.Query
}

func (r likeToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likeToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToUserFindFirst) with()         {}
func (r likeToUserFindFirst) likeModel()    {}
func (r likeToUserFindFirst) likeRelation() {}

func (r likeToUserFindFirst) With(params ...UserRelationWith) likeToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeToUserFindFirst) Select(params ...likePrismaFields) likeToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToUserFindFirst) Omit(params ...likePrismaFields) likeToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToUserFindFirst) OrderBy(params ...UserOrderByParam) likeToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likeToUserFindFirst) Skip(count int) likeToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likeToUserFindFirst) Take(count int) likeToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likeToUserFindFirst) Cursor(cursor LikeCursorParam) likeToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likeToUserFindFirst) Exec(ctx context.Context) (
	*LikeModel,
	error,
) {
	var v *LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerLike,
	error,
) {
	var v *InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likeToUserFindMany struct {
	query builder.Query
}

func (r likeToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r likeToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToUserFindMany) with()         {}
func (r likeToUserFindMany) likeModel()    {}
func (r likeToUserFindMany) likeRelation() {}

func (r likeToUserFindMany) With(params ...UserRelationWith) likeToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeToUserFindMany) Select(params ...likePrismaFields) likeToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToUserFindMany) Omit(params ...likePrismaFields) likeToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeToUserFindMany) OrderBy(params ...UserOrderByParam) likeToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likeToUserFindMany) Skip(count int) likeToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likeToUserFindMany) Take(count int) likeToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likeToUserFindMany) Cursor(cursor LikeCursorParam) likeToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likeToUserFindMany) Exec(ctx context.Context) (
	[]LikeModel,
	error,
) {
	var v []LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likeToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerLike,
	error,
) {
	var v []InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likeToUserFindMany) Update(params ...LikeSetParam) likeToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Like"

	r.query.Outputs = countOutput

	var v likeToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likeToUserUpdateMany struct {
	query builder.Query
}

func (r likeToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likeToUserUpdateMany) likeModel() {}

func (r likeToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToUserUpdateMany) Tx() LikeManyTxResult {
	v := newLikeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likeToUserFindMany) Delete() likeToUserDeleteMany {
	var v likeToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Like"

	v.query.Outputs = countOutput

	return v
}

type likeToUserDeleteMany struct {
	query builder.Query
}

func (r likeToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likeToUserDeleteMany) likeModel() {}

func (r likeToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeToUserDeleteMany) Tx() LikeManyTxResult {
	v := newLikeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likeFindUnique struct {
	query builder.Query
}

func (r likeFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likeFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likeFindUnique) with()         {}
func (r likeFindUnique) likeModel()    {}
func (r likeFindUnique) likeRelation() {}

func (r likeActions) FindUnique(
	params LikeEqualsUniqueWhereParam,
) likeFindUnique {
	var v likeFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Like"
	v.query.Outputs = likeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r likeFindUnique) With(params ...LikeRelationWith) likeFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeFindUnique) Select(params ...likePrismaFields) likeFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeFindUnique) Omit(params ...likePrismaFields) likeFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeFindUnique) Exec(ctx context.Context) (
	*LikeModel,
	error,
) {
	var v *LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeFindUnique) ExecInner(ctx context.Context) (
	*InnerLike,
	error,
) {
	var v *InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeFindUnique) Update(params ...LikeSetParam) likeUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Like"

	var v likeUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likeUpdateUnique struct {
	query builder.Query
}

func (r likeUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likeUpdateUnique) likeModel() {}

func (r likeUpdateUnique) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeUpdateUnique) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likeFindUnique) Delete() likeDeleteUnique {
	var v likeDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Like"

	return v
}

type likeDeleteUnique struct {
	query builder.Query
}

func (r likeDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likeDeleteUnique) likeModel() {}

func (r likeDeleteUnique) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeDeleteUnique) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likeFindFirst struct {
	query builder.Query
}

func (r likeFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likeFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likeFindFirst) with()         {}
func (r likeFindFirst) likeModel()    {}
func (r likeFindFirst) likeRelation() {}

func (r likeActions) FindFirst(
	params ...LikeWhereParam,
) likeFindFirst {
	var v likeFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Like"
	v.query.Outputs = likeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r likeFindFirst) With(params ...LikeRelationWith) likeFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeFindFirst) Select(params ...likePrismaFields) likeFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeFindFirst) Omit(params ...likePrismaFields) likeFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeFindFirst) OrderBy(params ...LikeOrderByParam) likeFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likeFindFirst) Skip(count int) likeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likeFindFirst) Take(count int) likeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likeFindFirst) Cursor(cursor LikeCursorParam) likeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likeFindFirst) Exec(ctx context.Context) (
	*LikeModel,
	error,
) {
	var v *LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likeFindFirst) ExecInner(ctx context.Context) (
	*InnerLike,
	error,
) {
	var v *InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likeFindMany struct {
	query builder.Query
}

func (r likeFindMany) getQuery() builder.Query {
	return r.query
}

func (r likeFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likeFindMany) with()         {}
func (r likeFindMany) likeModel()    {}
func (r likeFindMany) likeRelation() {}

func (r likeActions) FindMany(
	params ...LikeWhereParam,
) likeFindMany {
	var v likeFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Like"
	v.query.Outputs = likeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r likeFindMany) With(params ...LikeRelationWith) likeFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likeFindMany) Select(params ...likePrismaFields) likeFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likeFindMany) Omit(params ...likePrismaFields) likeFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likeFindMany) OrderBy(params ...LikeOrderByParam) likeFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likeFindMany) Skip(count int) likeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likeFindMany) Take(count int) likeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likeFindMany) Cursor(cursor LikeCursorParam) likeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likeFindMany) Exec(ctx context.Context) (
	[]LikeModel,
	error,
) {
	var v []LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likeFindMany) ExecInner(ctx context.Context) (
	[]InnerLike,
	error,
) {
	var v []InnerLike
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likeFindMany) Update(params ...LikeSetParam) likeUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Like"

	r.query.Outputs = countOutput

	var v likeUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likeUpdateMany struct {
	query builder.Query
}

func (r likeUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likeUpdateMany) likeModel() {}

func (r likeUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeUpdateMany) Tx() LikeManyTxResult {
	v := newLikeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likeFindMany) Delete() likeDeleteMany {
	var v likeDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Like"

	v.query.Outputs = countOutput

	return v
}

type likeDeleteMany struct {
	query builder.Query
}

func (r likeDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likeDeleteMany) likeModel() {}

func (r likeDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeDeleteMany) Tx() LikeManyTxResult {
	v := newLikeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagToPostFindUnique struct {
	query builder.Query
}

func (r tagToPostFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagToPostFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToPostFindUnique) with()        {}
func (r tagToPostFindUnique) tagModel()    {}
func (r tagToPostFindUnique) tagRelation() {}

func (r tagToPostFindUnique) With(params ...PostRelationWith) tagToPostFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagToPostFindUnique) Select(params ...tagPrismaFields) tagToPostFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToPostFindUnique) Omit(params ...tagPrismaFields) tagToPostFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToPostFindUnique) Exec(ctx context.Context) (
	*TagModel,
	error,
) {
	var v *TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagToPostFindUnique) ExecInner(ctx context.Context) (
	*InnerTag,
	error,
) {
	var v *InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagToPostFindUnique) Update(params ...TagSetParam) tagToPostUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Tag"

	var v tagToPostUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagToPostUpdateUnique struct {
	query builder.Query
}

func (r tagToPostUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToPostUpdateUnique) tagModel() {}

func (r tagToPostUpdateUnique) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToPostUpdateUnique) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagToPostFindUnique) Delete() tagToPostDeleteUnique {
	var v tagToPostDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Tag"

	return v
}

type tagToPostDeleteUnique struct {
	query builder.Query
}

func (r tagToPostDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagToPostDeleteUnique) tagModel() {}

func (r tagToPostDeleteUnique) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToPostDeleteUnique) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagToPostFindFirst struct {
	query builder.Query
}

func (r tagToPostFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagToPostFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToPostFindFirst) with()        {}
func (r tagToPostFindFirst) tagModel()    {}
func (r tagToPostFindFirst) tagRelation() {}

func (r tagToPostFindFirst) With(params ...PostRelationWith) tagToPostFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagToPostFindFirst) Select(params ...tagPrismaFields) tagToPostFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToPostFindFirst) Omit(params ...tagPrismaFields) tagToPostFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToPostFindFirst) OrderBy(params ...PostOrderByParam) tagToPostFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagToPostFindFirst) Skip(count int) tagToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagToPostFindFirst) Take(count int) tagToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagToPostFindFirst) Cursor(cursor TagCursorParam) tagToPostFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagToPostFindFirst) Exec(ctx context.Context) (
	*TagModel,
	error,
) {
	var v *TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagToPostFindFirst) ExecInner(ctx context.Context) (
	*InnerTag,
	error,
) {
	var v *InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagToPostFindMany struct {
	query builder.Query
}

func (r tagToPostFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagToPostFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToPostFindMany) with()        {}
func (r tagToPostFindMany) tagModel()    {}
func (r tagToPostFindMany) tagRelation() {}

func (r tagToPostFindMany) With(params ...PostRelationWith) tagToPostFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagToPostFindMany) Select(params ...tagPrismaFields) tagToPostFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToPostFindMany) Omit(params ...tagPrismaFields) tagToPostFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToPostFindMany) OrderBy(params ...PostOrderByParam) tagToPostFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagToPostFindMany) Skip(count int) tagToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagToPostFindMany) Take(count int) tagToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagToPostFindMany) Cursor(cursor TagCursorParam) tagToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagToPostFindMany) Exec(ctx context.Context) (
	[]TagModel,
	error,
) {
	var v []TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagToPostFindMany) ExecInner(ctx context.Context) (
	[]InnerTag,
	error,
) {
	var v []InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagToPostFindMany) Update(params ...TagSetParam) tagToPostUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Tag"

	r.query.Outputs = countOutput

	var v tagToPostUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagToPostUpdateMany struct {
	query builder.Query
}

func (r tagToPostUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToPostUpdateMany) tagModel() {}

func (r tagToPostUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToPostUpdateMany) Tx() TagManyTxResult {
	v := newTagManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagToPostFindMany) Delete() tagToPostDeleteMany {
	var v tagToPostDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Tag"

	v.query.Outputs = countOutput

	return v
}

type tagToPostDeleteMany struct {
	query builder.Query
}

func (r tagToPostDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagToPostDeleteMany) tagModel() {}

func (r tagToPostDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToPostDeleteMany) Tx() TagManyTxResult {
	v := newTagManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagToUserFindUnique struct {
	query builder.Query
}

func (r tagToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToUserFindUnique) with()        {}
func (r tagToUserFindUnique) tagModel()    {}
func (r tagToUserFindUnique) tagRelation() {}

func (r tagToUserFindUnique) With(params ...UserRelationWith) tagToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagToUserFindUnique) Select(params ...tagPrismaFields) tagToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToUserFindUnique) Omit(params ...tagPrismaFields) tagToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToUserFindUnique) Exec(ctx context.Context) (
	*TagModel,
	error,
) {
	var v *TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerTag,
	error,
) {
	var v *InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagToUserFindUnique) Update(params ...TagSetParam) tagToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Tag"

	var v tagToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagToUserUpdateUnique struct {
	query builder.Query
}

func (r tagToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToUserUpdateUnique) tagModel() {}

func (r tagToUserUpdateUnique) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToUserUpdateUnique) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagToUserFindUnique) Delete() tagToUserDeleteUnique {
	var v tagToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Tag"

	return v
}

type tagToUserDeleteUnique struct {
	query builder.Query
}

func (r tagToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagToUserDeleteUnique) tagModel() {}

func (r tagToUserDeleteUnique) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToUserDeleteUnique) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagToUserFindFirst struct {
	query builder.Query
}

func (r tagToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToUserFindFirst) with()        {}
func (r tagToUserFindFirst) tagModel()    {}
func (r tagToUserFindFirst) tagRelation() {}

func (r tagToUserFindFirst) With(params ...UserRelationWith) tagToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagToUserFindFirst) Select(params ...tagPrismaFields) tagToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToUserFindFirst) Omit(params ...tagPrismaFields) tagToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToUserFindFirst) OrderBy(params ...UserOrderByParam) tagToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagToUserFindFirst) Skip(count int) tagToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagToUserFindFirst) Take(count int) tagToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagToUserFindFirst) Cursor(cursor TagCursorParam) tagToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagToUserFindFirst) Exec(ctx context.Context) (
	*TagModel,
	error,
) {
	var v *TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerTag,
	error,
) {
	var v *InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagToUserFindMany struct {
	query builder.Query
}

func (r tagToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToUserFindMany) with()        {}
func (r tagToUserFindMany) tagModel()    {}
func (r tagToUserFindMany) tagRelation() {}

func (r tagToUserFindMany) With(params ...UserRelationWith) tagToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagToUserFindMany) Select(params ...tagPrismaFields) tagToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToUserFindMany) Omit(params ...tagPrismaFields) tagToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagToUserFindMany) OrderBy(params ...UserOrderByParam) tagToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagToUserFindMany) Skip(count int) tagToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagToUserFindMany) Take(count int) tagToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagToUserFindMany) Cursor(cursor TagCursorParam) tagToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagToUserFindMany) Exec(ctx context.Context) (
	[]TagModel,
	error,
) {
	var v []TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerTag,
	error,
) {
	var v []InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagToUserFindMany) Update(params ...TagSetParam) tagToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Tag"

	r.query.Outputs = countOutput

	var v tagToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagToUserUpdateMany struct {
	query builder.Query
}

func (r tagToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagToUserUpdateMany) tagModel() {}

func (r tagToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToUserUpdateMany) Tx() TagManyTxResult {
	v := newTagManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagToUserFindMany) Delete() tagToUserDeleteMany {
	var v tagToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Tag"

	v.query.Outputs = countOutput

	return v
}

type tagToUserDeleteMany struct {
	query builder.Query
}

func (r tagToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagToUserDeleteMany) tagModel() {}

func (r tagToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagToUserDeleteMany) Tx() TagManyTxResult {
	v := newTagManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagFindUnique struct {
	query builder.Query
}

func (r tagFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagFindUnique) with()        {}
func (r tagFindUnique) tagModel()    {}
func (r tagFindUnique) tagRelation() {}

func (r tagActions) FindUnique(
	params TagEqualsUniqueWhereParam,
) tagFindUnique {
	var v tagFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Tag"
	v.query.Outputs = tagOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r tagFindUnique) With(params ...TagRelationWith) tagFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagFindUnique) Select(params ...tagPrismaFields) tagFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagFindUnique) Omit(params ...tagPrismaFields) tagFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagFindUnique) Exec(ctx context.Context) (
	*TagModel,
	error,
) {
	var v *TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagFindUnique) ExecInner(ctx context.Context) (
	*InnerTag,
	error,
) {
	var v *InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagFindUnique) Update(params ...TagSetParam) tagUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Tag"

	var v tagUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagUpdateUnique struct {
	query builder.Query
}

func (r tagUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagUpdateUnique) tagModel() {}

func (r tagUpdateUnique) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagUpdateUnique) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagFindUnique) Delete() tagDeleteUnique {
	var v tagDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Tag"

	return v
}

type tagDeleteUnique struct {
	query builder.Query
}

func (r tagDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagDeleteUnique) tagModel() {}

func (r tagDeleteUnique) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagDeleteUnique) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagFindFirst struct {
	query builder.Query
}

func (r tagFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagFindFirst) with()        {}
func (r tagFindFirst) tagModel()    {}
func (r tagFindFirst) tagRelation() {}

func (r tagActions) FindFirst(
	params ...TagWhereParam,
) tagFindFirst {
	var v tagFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Tag"
	v.query.Outputs = tagOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r tagFindFirst) With(params ...TagRelationWith) tagFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagFindFirst) Select(params ...tagPrismaFields) tagFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagFindFirst) Omit(params ...tagPrismaFields) tagFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagFindFirst) OrderBy(params ...TagOrderByParam) tagFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagFindFirst) Skip(count int) tagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagFindFirst) Take(count int) tagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagFindFirst) Cursor(cursor TagCursorParam) tagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagFindFirst) Exec(ctx context.Context) (
	*TagModel,
	error,
) {
	var v *TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagFindFirst) ExecInner(ctx context.Context) (
	*InnerTag,
	error,
) {
	var v *InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagFindMany struct {
	query builder.Query
}

func (r tagFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagFindMany) with()        {}
func (r tagFindMany) tagModel()    {}
func (r tagFindMany) tagRelation() {}

func (r tagActions) FindMany(
	params ...TagWhereParam,
) tagFindMany {
	var v tagFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Tag"
	v.query.Outputs = tagOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r tagFindMany) With(params ...TagRelationWith) tagFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagFindMany) Select(params ...tagPrismaFields) tagFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagFindMany) Omit(params ...tagPrismaFields) tagFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagFindMany) OrderBy(params ...TagOrderByParam) tagFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagFindMany) Skip(count int) tagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagFindMany) Take(count int) tagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagFindMany) Cursor(cursor TagCursorParam) tagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagFindMany) Exec(ctx context.Context) (
	[]TagModel,
	error,
) {
	var v []TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagFindMany) ExecInner(ctx context.Context) (
	[]InnerTag,
	error,
) {
	var v []InnerTag
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagFindMany) Update(params ...TagSetParam) tagUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Tag"

	r.query.Outputs = countOutput

	var v tagUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagUpdateMany struct {
	query builder.Query
}

func (r tagUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagUpdateMany) tagModel() {}

func (r tagUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagUpdateMany) Tx() TagManyTxResult {
	v := newTagManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagFindMany) Delete() tagDeleteMany {
	var v tagDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Tag"

	v.query.Outputs = countOutput

	return v
}

type tagDeleteMany struct {
	query builder.Query
}

func (r tagDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagDeleteMany) tagModel() {}

func (r tagDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagDeleteMany) Tx() TagManyTxResult {
	v := newTagManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type followsToFollowerFindUnique struct {
	query builder.Query
}

func (r followsToFollowerFindUnique) getQuery() builder.Query {
	return r.query
}

func (r followsToFollowerFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowerFindUnique) with()            {}
func (r followsToFollowerFindUnique) followsModel()    {}
func (r followsToFollowerFindUnique) followsRelation() {}

func (r followsToFollowerFindUnique) With(params ...UserRelationWith) followsToFollowerFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsToFollowerFindUnique) Select(params ...followsPrismaFields) followsToFollowerFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowerFindUnique) Omit(params ...followsPrismaFields) followsToFollowerFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowerFindUnique) Exec(ctx context.Context) (
	*FollowsModel,
	error,
) {
	var v *FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsToFollowerFindUnique) ExecInner(ctx context.Context) (
	*InnerFollows,
	error,
) {
	var v *InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsToFollowerFindUnique) Update(params ...FollowsSetParam) followsToFollowerUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Follows"

	var v followsToFollowerUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type followsToFollowerUpdateUnique struct {
	query builder.Query
}

func (r followsToFollowerUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowerUpdateUnique) followsModel() {}

func (r followsToFollowerUpdateUnique) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowerUpdateUnique) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r followsToFollowerFindUnique) Delete() followsToFollowerDeleteUnique {
	var v followsToFollowerDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Follows"

	return v
}

type followsToFollowerDeleteUnique struct {
	query builder.Query
}

func (r followsToFollowerDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p followsToFollowerDeleteUnique) followsModel() {}

func (r followsToFollowerDeleteUnique) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowerDeleteUnique) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type followsToFollowerFindFirst struct {
	query builder.Query
}

func (r followsToFollowerFindFirst) getQuery() builder.Query {
	return r.query
}

func (r followsToFollowerFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowerFindFirst) with()            {}
func (r followsToFollowerFindFirst) followsModel()    {}
func (r followsToFollowerFindFirst) followsRelation() {}

func (r followsToFollowerFindFirst) With(params ...UserRelationWith) followsToFollowerFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsToFollowerFindFirst) Select(params ...followsPrismaFields) followsToFollowerFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowerFindFirst) Omit(params ...followsPrismaFields) followsToFollowerFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowerFindFirst) OrderBy(params ...UserOrderByParam) followsToFollowerFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r followsToFollowerFindFirst) Skip(count int) followsToFollowerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r followsToFollowerFindFirst) Take(count int) followsToFollowerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r followsToFollowerFindFirst) Cursor(cursor FollowsCursorParam) followsToFollowerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r followsToFollowerFindFirst) Exec(ctx context.Context) (
	*FollowsModel,
	error,
) {
	var v *FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsToFollowerFindFirst) ExecInner(ctx context.Context) (
	*InnerFollows,
	error,
) {
	var v *InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type followsToFollowerFindMany struct {
	query builder.Query
}

func (r followsToFollowerFindMany) getQuery() builder.Query {
	return r.query
}

func (r followsToFollowerFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowerFindMany) with()            {}
func (r followsToFollowerFindMany) followsModel()    {}
func (r followsToFollowerFindMany) followsRelation() {}

func (r followsToFollowerFindMany) With(params ...UserRelationWith) followsToFollowerFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsToFollowerFindMany) Select(params ...followsPrismaFields) followsToFollowerFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowerFindMany) Omit(params ...followsPrismaFields) followsToFollowerFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowerFindMany) OrderBy(params ...UserOrderByParam) followsToFollowerFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r followsToFollowerFindMany) Skip(count int) followsToFollowerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r followsToFollowerFindMany) Take(count int) followsToFollowerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r followsToFollowerFindMany) Cursor(cursor FollowsCursorParam) followsToFollowerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r followsToFollowerFindMany) Exec(ctx context.Context) (
	[]FollowsModel,
	error,
) {
	var v []FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r followsToFollowerFindMany) ExecInner(ctx context.Context) (
	[]InnerFollows,
	error,
) {
	var v []InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r followsToFollowerFindMany) Update(params ...FollowsSetParam) followsToFollowerUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Follows"

	r.query.Outputs = countOutput

	var v followsToFollowerUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type followsToFollowerUpdateMany struct {
	query builder.Query
}

func (r followsToFollowerUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowerUpdateMany) followsModel() {}

func (r followsToFollowerUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowerUpdateMany) Tx() FollowsManyTxResult {
	v := newFollowsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r followsToFollowerFindMany) Delete() followsToFollowerDeleteMany {
	var v followsToFollowerDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Follows"

	v.query.Outputs = countOutput

	return v
}

type followsToFollowerDeleteMany struct {
	query builder.Query
}

func (r followsToFollowerDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p followsToFollowerDeleteMany) followsModel() {}

func (r followsToFollowerDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowerDeleteMany) Tx() FollowsManyTxResult {
	v := newFollowsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type followsToFollowingFindUnique struct {
	query builder.Query
}

func (r followsToFollowingFindUnique) getQuery() builder.Query {
	return r.query
}

func (r followsToFollowingFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowingFindUnique) with()            {}
func (r followsToFollowingFindUnique) followsModel()    {}
func (r followsToFollowingFindUnique) followsRelation() {}

func (r followsToFollowingFindUnique) With(params ...UserRelationWith) followsToFollowingFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsToFollowingFindUnique) Select(params ...followsPrismaFields) followsToFollowingFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowingFindUnique) Omit(params ...followsPrismaFields) followsToFollowingFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowingFindUnique) Exec(ctx context.Context) (
	*FollowsModel,
	error,
) {
	var v *FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsToFollowingFindUnique) ExecInner(ctx context.Context) (
	*InnerFollows,
	error,
) {
	var v *InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsToFollowingFindUnique) Update(params ...FollowsSetParam) followsToFollowingUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Follows"

	var v followsToFollowingUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type followsToFollowingUpdateUnique struct {
	query builder.Query
}

func (r followsToFollowingUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowingUpdateUnique) followsModel() {}

func (r followsToFollowingUpdateUnique) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowingUpdateUnique) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r followsToFollowingFindUnique) Delete() followsToFollowingDeleteUnique {
	var v followsToFollowingDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Follows"

	return v
}

type followsToFollowingDeleteUnique struct {
	query builder.Query
}

func (r followsToFollowingDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p followsToFollowingDeleteUnique) followsModel() {}

func (r followsToFollowingDeleteUnique) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowingDeleteUnique) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type followsToFollowingFindFirst struct {
	query builder.Query
}

func (r followsToFollowingFindFirst) getQuery() builder.Query {
	return r.query
}

func (r followsToFollowingFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowingFindFirst) with()            {}
func (r followsToFollowingFindFirst) followsModel()    {}
func (r followsToFollowingFindFirst) followsRelation() {}

func (r followsToFollowingFindFirst) With(params ...UserRelationWith) followsToFollowingFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsToFollowingFindFirst) Select(params ...followsPrismaFields) followsToFollowingFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowingFindFirst) Omit(params ...followsPrismaFields) followsToFollowingFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowingFindFirst) OrderBy(params ...UserOrderByParam) followsToFollowingFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r followsToFollowingFindFirst) Skip(count int) followsToFollowingFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r followsToFollowingFindFirst) Take(count int) followsToFollowingFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r followsToFollowingFindFirst) Cursor(cursor FollowsCursorParam) followsToFollowingFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r followsToFollowingFindFirst) Exec(ctx context.Context) (
	*FollowsModel,
	error,
) {
	var v *FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsToFollowingFindFirst) ExecInner(ctx context.Context) (
	*InnerFollows,
	error,
) {
	var v *InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type followsToFollowingFindMany struct {
	query builder.Query
}

func (r followsToFollowingFindMany) getQuery() builder.Query {
	return r.query
}

func (r followsToFollowingFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowingFindMany) with()            {}
func (r followsToFollowingFindMany) followsModel()    {}
func (r followsToFollowingFindMany) followsRelation() {}

func (r followsToFollowingFindMany) With(params ...UserRelationWith) followsToFollowingFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsToFollowingFindMany) Select(params ...followsPrismaFields) followsToFollowingFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowingFindMany) Omit(params ...followsPrismaFields) followsToFollowingFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsToFollowingFindMany) OrderBy(params ...UserOrderByParam) followsToFollowingFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r followsToFollowingFindMany) Skip(count int) followsToFollowingFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r followsToFollowingFindMany) Take(count int) followsToFollowingFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r followsToFollowingFindMany) Cursor(cursor FollowsCursorParam) followsToFollowingFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r followsToFollowingFindMany) Exec(ctx context.Context) (
	[]FollowsModel,
	error,
) {
	var v []FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r followsToFollowingFindMany) ExecInner(ctx context.Context) (
	[]InnerFollows,
	error,
) {
	var v []InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r followsToFollowingFindMany) Update(params ...FollowsSetParam) followsToFollowingUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Follows"

	r.query.Outputs = countOutput

	var v followsToFollowingUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type followsToFollowingUpdateMany struct {
	query builder.Query
}

func (r followsToFollowingUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r followsToFollowingUpdateMany) followsModel() {}

func (r followsToFollowingUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowingUpdateMany) Tx() FollowsManyTxResult {
	v := newFollowsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r followsToFollowingFindMany) Delete() followsToFollowingDeleteMany {
	var v followsToFollowingDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Follows"

	v.query.Outputs = countOutput

	return v
}

type followsToFollowingDeleteMany struct {
	query builder.Query
}

func (r followsToFollowingDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p followsToFollowingDeleteMany) followsModel() {}

func (r followsToFollowingDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsToFollowingDeleteMany) Tx() FollowsManyTxResult {
	v := newFollowsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type followsFindUnique struct {
	query builder.Query
}

func (r followsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r followsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r followsFindUnique) with()            {}
func (r followsFindUnique) followsModel()    {}
func (r followsFindUnique) followsRelation() {}

func (r followsActions) FindUnique(
	params FollowsEqualsUniqueWhereParam,
) followsFindUnique {
	var v followsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Follows"
	v.query.Outputs = followsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r followsFindUnique) With(params ...FollowsRelationWith) followsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsFindUnique) Select(params ...followsPrismaFields) followsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsFindUnique) Omit(params ...followsPrismaFields) followsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsFindUnique) Exec(ctx context.Context) (
	*FollowsModel,
	error,
) {
	var v *FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsFindUnique) ExecInner(ctx context.Context) (
	*InnerFollows,
	error,
) {
	var v *InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsFindUnique) Update(params ...FollowsSetParam) followsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Follows"

	var v followsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type followsUpdateUnique struct {
	query builder.Query
}

func (r followsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r followsUpdateUnique) followsModel() {}

func (r followsUpdateUnique) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsUpdateUnique) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r followsFindUnique) Delete() followsDeleteUnique {
	var v followsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Follows"

	return v
}

type followsDeleteUnique struct {
	query builder.Query
}

func (r followsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p followsDeleteUnique) followsModel() {}

func (r followsDeleteUnique) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsDeleteUnique) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type followsFindFirst struct {
	query builder.Query
}

func (r followsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r followsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r followsFindFirst) with()            {}
func (r followsFindFirst) followsModel()    {}
func (r followsFindFirst) followsRelation() {}

func (r followsActions) FindFirst(
	params ...FollowsWhereParam,
) followsFindFirst {
	var v followsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Follows"
	v.query.Outputs = followsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r followsFindFirst) With(params ...FollowsRelationWith) followsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsFindFirst) Select(params ...followsPrismaFields) followsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsFindFirst) Omit(params ...followsPrismaFields) followsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsFindFirst) OrderBy(params ...FollowsOrderByParam) followsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r followsFindFirst) Skip(count int) followsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r followsFindFirst) Take(count int) followsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r followsFindFirst) Cursor(cursor FollowsCursorParam) followsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r followsFindFirst) Exec(ctx context.Context) (
	*FollowsModel,
	error,
) {
	var v *FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r followsFindFirst) ExecInner(ctx context.Context) (
	*InnerFollows,
	error,
) {
	var v *InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type followsFindMany struct {
	query builder.Query
}

func (r followsFindMany) getQuery() builder.Query {
	return r.query
}

func (r followsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r followsFindMany) with()            {}
func (r followsFindMany) followsModel()    {}
func (r followsFindMany) followsRelation() {}

func (r followsActions) FindMany(
	params ...FollowsWhereParam,
) followsFindMany {
	var v followsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Follows"
	v.query.Outputs = followsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r followsFindMany) With(params ...FollowsRelationWith) followsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r followsFindMany) Select(params ...followsPrismaFields) followsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r followsFindMany) Omit(params ...followsPrismaFields) followsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range followsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r followsFindMany) OrderBy(params ...FollowsOrderByParam) followsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r followsFindMany) Skip(count int) followsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r followsFindMany) Take(count int) followsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r followsFindMany) Cursor(cursor FollowsCursorParam) followsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r followsFindMany) Exec(ctx context.Context) (
	[]FollowsModel,
	error,
) {
	var v []FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r followsFindMany) ExecInner(ctx context.Context) (
	[]InnerFollows,
	error,
) {
	var v []InnerFollows
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r followsFindMany) Update(params ...FollowsSetParam) followsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Follows"

	r.query.Outputs = countOutput

	var v followsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type followsUpdateMany struct {
	query builder.Query
}

func (r followsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r followsUpdateMany) followsModel() {}

func (r followsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsUpdateMany) Tx() FollowsManyTxResult {
	v := newFollowsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r followsFindMany) Delete() followsDeleteMany {
	var v followsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Follows"

	v.query.Outputs = countOutput

	return v
}

type followsDeleteMany struct {
	query builder.Query
}

func (r followsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p followsDeleteMany) followsModel() {}

func (r followsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsDeleteMany) Tx() FollowsManyTxResult {
	v := newFollowsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type restaurantToPostsFindUnique struct {
	query builder.Query
}

func (r restaurantToPostsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsFindUnique) with()               {}
func (r restaurantToPostsFindUnique) restaurantModel()    {}
func (r restaurantToPostsFindUnique) restaurantRelation() {}

func (r restaurantToPostsFindUnique) With(params ...PostRelationWith) restaurantToPostsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r restaurantToPostsFindUnique) Select(params ...restaurantPrismaFields) restaurantToPostsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantToPostsFindUnique) Omit(params ...restaurantPrismaFields) restaurantToPostsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range restaurantOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantToPostsFindUnique) Exec(ctx context.Context) (
	*RestaurantModel,
	error,
) {
	var v *RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r restaurantToPostsFindUnique) ExecInner(ctx context.Context) (
	*InnerRestaurant,
	error,
) {
	var v *InnerRestaurant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r restaurantToPostsFindUnique) Update(params ...RestaurantSetParam) restaurantToPostsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Restaurant"

	var v restaurantToPostsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type restaurantToPostsUpdateUnique struct {
	query builder.Query
}

func (r restaurantToPostsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsUpdateUnique) restaurantModel() {}

func (r restaurantToPostsUpdateUnique) Exec(ctx context.Context) (*RestaurantModel, error) {
	var v RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantToPostsUpdateUnique) Tx() RestaurantUniqueTxResult {
	v := newRestaurantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r restaurantToPostsFindUnique) Delete() restaurantToPostsDeleteUnique {
	var v restaurantToPostsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Restaurant"

	return v
}

type restaurantToPostsDeleteUnique struct {
	query builder.Query
}

func (r restaurantToPostsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p restaurantToPostsDeleteUnique) restaurantModel() {}

func (r restaurantToPostsDeleteUnique) Exec(ctx context.Context) (*RestaurantModel, error) {
	var v RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantToPostsDeleteUnique) Tx() RestaurantUniqueTxResult {
	v := newRestaurantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type restaurantToPostsFindFirst struct {
	query builder.Query
}

func (r restaurantToPostsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsFindFirst) with()               {}
func (r restaurantToPostsFindFirst) restaurantModel()    {}
func (r restaurantToPostsFindFirst) restaurantRelation() {}

func (r restaurantToPostsFindFirst) With(params ...PostRelationWith) restaurantToPostsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r restaurantToPostsFindFirst) Select(params ...restaurantPrismaFields) restaurantToPostsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantToPostsFindFirst) Omit(params ...restaurantPrismaFields) restaurantToPostsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range restaurantOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantToPostsFindFirst) OrderBy(params ...PostOrderByParam) restaurantToPostsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r restaurantToPostsFindFirst) Skip(count int) restaurantToPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r restaurantToPostsFindFirst) Take(count int) restaurantToPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r restaurantToPostsFindFirst) Cursor(cursor RestaurantCursorParam) restaurantToPostsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r restaurantToPostsFindFirst) Exec(ctx context.Context) (
	*RestaurantModel,
	error,
) {
	var v *RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r restaurantToPostsFindFirst) ExecInner(ctx context.Context) (
	*InnerRestaurant,
	error,
) {
	var v *InnerRestaurant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type restaurantToPostsFindMany struct {
	query builder.Query
}

func (r restaurantToPostsFindMany) getQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsFindMany) with()               {}
func (r restaurantToPostsFindMany) restaurantModel()    {}
func (r restaurantToPostsFindMany) restaurantRelation() {}

func (r restaurantToPostsFindMany) With(params ...PostRelationWith) restaurantToPostsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r restaurantToPostsFindMany) Select(params ...restaurantPrismaFields) restaurantToPostsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantToPostsFindMany) Omit(params ...restaurantPrismaFields) restaurantToPostsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range restaurantOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantToPostsFindMany) OrderBy(params ...PostOrderByParam) restaurantToPostsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r restaurantToPostsFindMany) Skip(count int) restaurantToPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r restaurantToPostsFindMany) Take(count int) restaurantToPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r restaurantToPostsFindMany) Cursor(cursor RestaurantCursorParam) restaurantToPostsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r restaurantToPostsFindMany) Exec(ctx context.Context) (
	[]RestaurantModel,
	error,
) {
	var v []RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r restaurantToPostsFindMany) ExecInner(ctx context.Context) (
	[]InnerRestaurant,
	error,
) {
	var v []InnerRestaurant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r restaurantToPostsFindMany) Update(params ...RestaurantSetParam) restaurantToPostsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Restaurant"

	r.query.Outputs = countOutput

	var v restaurantToPostsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type restaurantToPostsUpdateMany struct {
	query builder.Query
}

func (r restaurantToPostsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantToPostsUpdateMany) restaurantModel() {}

func (r restaurantToPostsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantToPostsUpdateMany) Tx() RestaurantManyTxResult {
	v := newRestaurantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r restaurantToPostsFindMany) Delete() restaurantToPostsDeleteMany {
	var v restaurantToPostsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Restaurant"

	v.query.Outputs = countOutput

	return v
}

type restaurantToPostsDeleteMany struct {
	query builder.Query
}

func (r restaurantToPostsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p restaurantToPostsDeleteMany) restaurantModel() {}

func (r restaurantToPostsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantToPostsDeleteMany) Tx() RestaurantManyTxResult {
	v := newRestaurantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type restaurantFindUnique struct {
	query builder.Query
}

func (r restaurantFindUnique) getQuery() builder.Query {
	return r.query
}

func (r restaurantFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantFindUnique) with()               {}
func (r restaurantFindUnique) restaurantModel()    {}
func (r restaurantFindUnique) restaurantRelation() {}

func (r restaurantActions) FindUnique(
	params RestaurantEqualsUniqueWhereParam,
) restaurantFindUnique {
	var v restaurantFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Restaurant"
	v.query.Outputs = restaurantOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r restaurantFindUnique) With(params ...RestaurantRelationWith) restaurantFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r restaurantFindUnique) Select(params ...restaurantPrismaFields) restaurantFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantFindUnique) Omit(params ...restaurantPrismaFields) restaurantFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range restaurantOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantFindUnique) Exec(ctx context.Context) (
	*RestaurantModel,
	error,
) {
	var v *RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r restaurantFindUnique) ExecInner(ctx context.Context) (
	*InnerRestaurant,
	error,
) {
	var v *InnerRestaurant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r restaurantFindUnique) Update(params ...RestaurantSetParam) restaurantUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Restaurant"

	var v restaurantUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type restaurantUpdateUnique struct {
	query builder.Query
}

func (r restaurantUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantUpdateUnique) restaurantModel() {}

func (r restaurantUpdateUnique) Exec(ctx context.Context) (*RestaurantModel, error) {
	var v RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantUpdateUnique) Tx() RestaurantUniqueTxResult {
	v := newRestaurantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r restaurantFindUnique) Delete() restaurantDeleteUnique {
	var v restaurantDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Restaurant"

	return v
}

type restaurantDeleteUnique struct {
	query builder.Query
}

func (r restaurantDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p restaurantDeleteUnique) restaurantModel() {}

func (r restaurantDeleteUnique) Exec(ctx context.Context) (*RestaurantModel, error) {
	var v RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantDeleteUnique) Tx() RestaurantUniqueTxResult {
	v := newRestaurantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type restaurantFindFirst struct {
	query builder.Query
}

func (r restaurantFindFirst) getQuery() builder.Query {
	return r.query
}

func (r restaurantFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantFindFirst) with()               {}
func (r restaurantFindFirst) restaurantModel()    {}
func (r restaurantFindFirst) restaurantRelation() {}

func (r restaurantActions) FindFirst(
	params ...RestaurantWhereParam,
) restaurantFindFirst {
	var v restaurantFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Restaurant"
	v.query.Outputs = restaurantOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r restaurantFindFirst) With(params ...RestaurantRelationWith) restaurantFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r restaurantFindFirst) Select(params ...restaurantPrismaFields) restaurantFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantFindFirst) Omit(params ...restaurantPrismaFields) restaurantFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range restaurantOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantFindFirst) OrderBy(params ...RestaurantOrderByParam) restaurantFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r restaurantFindFirst) Skip(count int) restaurantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r restaurantFindFirst) Take(count int) restaurantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r restaurantFindFirst) Cursor(cursor RestaurantCursorParam) restaurantFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r restaurantFindFirst) Exec(ctx context.Context) (
	*RestaurantModel,
	error,
) {
	var v *RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r restaurantFindFirst) ExecInner(ctx context.Context) (
	*InnerRestaurant,
	error,
) {
	var v *InnerRestaurant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type restaurantFindMany struct {
	query builder.Query
}

func (r restaurantFindMany) getQuery() builder.Query {
	return r.query
}

func (r restaurantFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantFindMany) with()               {}
func (r restaurantFindMany) restaurantModel()    {}
func (r restaurantFindMany) restaurantRelation() {}

func (r restaurantActions) FindMany(
	params ...RestaurantWhereParam,
) restaurantFindMany {
	var v restaurantFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Restaurant"
	v.query.Outputs = restaurantOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r restaurantFindMany) With(params ...RestaurantRelationWith) restaurantFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r restaurantFindMany) Select(params ...restaurantPrismaFields) restaurantFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantFindMany) Omit(params ...restaurantPrismaFields) restaurantFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range restaurantOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r restaurantFindMany) OrderBy(params ...RestaurantOrderByParam) restaurantFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r restaurantFindMany) Skip(count int) restaurantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r restaurantFindMany) Take(count int) restaurantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r restaurantFindMany) Cursor(cursor RestaurantCursorParam) restaurantFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r restaurantFindMany) Exec(ctx context.Context) (
	[]RestaurantModel,
	error,
) {
	var v []RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r restaurantFindMany) ExecInner(ctx context.Context) (
	[]InnerRestaurant,
	error,
) {
	var v []InnerRestaurant
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r restaurantFindMany) Update(params ...RestaurantSetParam) restaurantUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Restaurant"

	r.query.Outputs = countOutput

	var v restaurantUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type restaurantUpdateMany struct {
	query builder.Query
}

func (r restaurantUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantUpdateMany) restaurantModel() {}

func (r restaurantUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantUpdateMany) Tx() RestaurantManyTxResult {
	v := newRestaurantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r restaurantFindMany) Delete() restaurantDeleteMany {
	var v restaurantDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Restaurant"

	v.query.Outputs = countOutput

	return v
}

type restaurantDeleteMany struct {
	query builder.Query
}

func (r restaurantDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p restaurantDeleteMany) restaurantModel() {}

func (r restaurantDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantDeleteMany) Tx() RestaurantManyTxResult {
	v := newRestaurantManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newUserUniqueTxResult() UserUniqueTxResult {
	return UserUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserUniqueTxResult) IsTx() {}

func (r UserUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserManyTxResult() UserManyTxResult {
	return UserManyTxResult{
		result: &transaction.Result{},
	}
}

type UserManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserManyTxResult) IsTx() {}

func (r UserManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newPostUniqueTxResult() PostUniqueTxResult {
	return PostUniqueTxResult{
		result: &transaction.Result{},
	}
}

type PostUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p PostUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p PostUniqueTxResult) IsTx() {}

func (r PostUniqueTxResult) Result() (v *PostModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newPostManyTxResult() PostManyTxResult {
	return PostManyTxResult{
		result: &transaction.Result{},
	}
}

type PostManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p PostManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p PostManyTxResult) IsTx() {}

func (r PostManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCommentUniqueTxResult() CommentUniqueTxResult {
	return CommentUniqueTxResult{
		result: &transaction.Result{},
	}
}

type CommentUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CommentUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CommentUniqueTxResult) IsTx() {}

func (r CommentUniqueTxResult) Result() (v *CommentModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCommentManyTxResult() CommentManyTxResult {
	return CommentManyTxResult{
		result: &transaction.Result{},
	}
}

type CommentManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CommentManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CommentManyTxResult) IsTx() {}

func (r CommentManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newLikeUniqueTxResult() LikeUniqueTxResult {
	return LikeUniqueTxResult{
		result: &transaction.Result{},
	}
}

type LikeUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p LikeUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p LikeUniqueTxResult) IsTx() {}

func (r LikeUniqueTxResult) Result() (v *LikeModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newLikeManyTxResult() LikeManyTxResult {
	return LikeManyTxResult{
		result: &transaction.Result{},
	}
}

type LikeManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p LikeManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p LikeManyTxResult) IsTx() {}

func (r LikeManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTagUniqueTxResult() TagUniqueTxResult {
	return TagUniqueTxResult{
		result: &transaction.Result{},
	}
}

type TagUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TagUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TagUniqueTxResult) IsTx() {}

func (r TagUniqueTxResult) Result() (v *TagModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTagManyTxResult() TagManyTxResult {
	return TagManyTxResult{
		result: &transaction.Result{},
	}
}

type TagManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TagManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TagManyTxResult) IsTx() {}

func (r TagManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newFollowsUniqueTxResult() FollowsUniqueTxResult {
	return FollowsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type FollowsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p FollowsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p FollowsUniqueTxResult) IsTx() {}

func (r FollowsUniqueTxResult) Result() (v *FollowsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newFollowsManyTxResult() FollowsManyTxResult {
	return FollowsManyTxResult{
		result: &transaction.Result{},
	}
}

type FollowsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p FollowsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p FollowsManyTxResult) IsTx() {}

func (r FollowsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newRestaurantUniqueTxResult() RestaurantUniqueTxResult {
	return RestaurantUniqueTxResult{
		result: &transaction.Result{},
	}
}

type RestaurantUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p RestaurantUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p RestaurantUniqueTxResult) IsTx() {}

func (r RestaurantUniqueTxResult) Result() (v *RestaurantModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newRestaurantManyTxResult() RestaurantManyTxResult {
	return RestaurantManyTxResult{
		result: &transaction.Result{},
	}
}

type RestaurantManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p RestaurantManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p RestaurantManyTxResult) IsTx() {}

func (r RestaurantManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_email UserWithPrismaEmailSetParam,
	_username UserWithPrismaUsernameSetParam,
	_password UserWithPrismaPasswordSetParam,
	_bio UserWithPrismaBioSetParam,
	_avatar UserWithPrismaAvatarSetParam,
	_firstName UserWithPrismaFirstNameSetParam,
	_lastName UserWithPrismaLastNameSetParam,
	_spiciness UserWithPrismaSpicinessSetParam,
	_sweetness UserWithPrismaSweetnessSetParam,
	_sourness UserWithPrismaSournessSetParam,
	_type UserWithPrismaTypeSetParam,
	_allergies UserWithPrismaAllergiesSetParam,
	_city UserWithPrismaCitySetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _email.field())
	fields = append(fields, _username.field())
	fields = append(fields, _password.field())
	fields = append(fields, _bio.field())
	fields = append(fields, _avatar.field())
	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())
	fields = append(fields, _spiciness.field())
	fields = append(fields, _sweetness.field())
	fields = append(fields, _sourness.field())
	fields = append(fields, _type.field())
	fields = append(fields, _allergies.field())
	fields = append(fields, _city.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type postUpsertOne struct {
	query builder.Query
}

func (r postUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r postUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r postUpsertOne) with()         {}
func (r postUpsertOne) postModel()    {}
func (r postUpsertOne) postRelation() {}

func (r postActions) UpsertOne(
	params PostEqualsUniqueWhereParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r postUpsertOne) Create(

	_title PostWithPrismaTitleSetParam,
	_description PostWithPrismaDescriptionSetParam,
	_longitude PostWithPrismaLongitudeSetParam,
	_latitude PostWithPrismaLatitudeSetParam,
	_cuisine PostWithPrismaCuisineSetParam,
	_dish PostWithPrismaDishSetParam,
	_type PostWithPrismaTypeSetParam,
	_spiciness PostWithPrismaSpicinessSetParam,
	_sweetness PostWithPrismaSweetnessSetParam,
	_sourness PostWithPrismaSournessSetParam,
	_pictures PostWithPrismaPicturesSetParam,
	_city PostWithPrismaCitySetParam,
	_user PostWithPrismaUserSetParam,

	optional ...PostSetParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _title.field())
	fields = append(fields, _description.field())
	fields = append(fields, _longitude.field())
	fields = append(fields, _latitude.field())
	fields = append(fields, _cuisine.field())
	fields = append(fields, _dish.field())
	fields = append(fields, _type.field())
	fields = append(fields, _spiciness.field())
	fields = append(fields, _sweetness.field())
	fields = append(fields, _sourness.field())
	fields = append(fields, _pictures.field())
	fields = append(fields, _city.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r postUpsertOne) Update(
	params ...PostSetParam,
) postUpsertOne {
	var v postUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r postUpsertOne) Exec(ctx context.Context) (*PostModel, error) {
	var v PostModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r postUpsertOne) Tx() PostUniqueTxResult {
	v := newPostUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentUpsertOne struct {
	query builder.Query
}

func (r commentUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r commentUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r commentUpsertOne) with()            {}
func (r commentUpsertOne) commentModel()    {}
func (r commentUpsertOne) commentRelation() {}

func (r commentActions) UpsertOne(
	params CommentEqualsUniqueWhereParam,
) commentUpsertOne {
	var v commentUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Comment"
	v.query.Outputs = commentOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r commentUpsertOne) Create(

	_content CommentWithPrismaContentSetParam,
	_post CommentWithPrismaPostSetParam,
	_user CommentWithPrismaUserSetParam,

	optional ...CommentSetParam,
) commentUpsertOne {
	var v commentUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _content.field())
	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r commentUpsertOne) Update(
	params ...CommentSetParam,
) commentUpsertOne {
	var v commentUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r commentUpsertOne) Exec(ctx context.Context) (*CommentModel, error) {
	var v CommentModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentUpsertOne) Tx() CommentUniqueTxResult {
	v := newCommentUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likeUpsertOne struct {
	query builder.Query
}

func (r likeUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r likeUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r likeUpsertOne) with()         {}
func (r likeUpsertOne) likeModel()    {}
func (r likeUpsertOne) likeRelation() {}

func (r likeActions) UpsertOne(
	params LikeEqualsUniqueWhereParam,
) likeUpsertOne {
	var v likeUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Like"
	v.query.Outputs = likeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r likeUpsertOne) Create(

	_post LikeWithPrismaPostSetParam,
	_user LikeWithPrismaUserSetParam,

	optional ...LikeSetParam,
) likeUpsertOne {
	var v likeUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r likeUpsertOne) Update(
	params ...LikeSetParam,
) likeUpsertOne {
	var v likeUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r likeUpsertOne) Exec(ctx context.Context) (*LikeModel, error) {
	var v LikeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likeUpsertOne) Tx() LikeUniqueTxResult {
	v := newLikeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagUpsertOne struct {
	query builder.Query
}

func (r tagUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r tagUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r tagUpsertOne) with()        {}
func (r tagUpsertOne) tagModel()    {}
func (r tagUpsertOne) tagRelation() {}

func (r tagActions) UpsertOne(
	params TagEqualsUniqueWhereParam,
) tagUpsertOne {
	var v tagUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Tag"
	v.query.Outputs = tagOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r tagUpsertOne) Create(

	_post TagWithPrismaPostSetParam,
	_user TagWithPrismaUserSetParam,

	optional ...TagSetParam,
) tagUpsertOne {
	var v tagUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _post.field())
	fields = append(fields, _user.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r tagUpsertOne) Update(
	params ...TagSetParam,
) tagUpsertOne {
	var v tagUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r tagUpsertOne) Exec(ctx context.Context) (*TagModel, error) {
	var v TagModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagUpsertOne) Tx() TagUniqueTxResult {
	v := newTagUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type followsUpsertOne struct {
	query builder.Query
}

func (r followsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r followsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r followsUpsertOne) with()            {}
func (r followsUpsertOne) followsModel()    {}
func (r followsUpsertOne) followsRelation() {}

func (r followsActions) UpsertOne(
	params FollowsEqualsUniqueWhereParam,
) followsUpsertOne {
	var v followsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Follows"
	v.query.Outputs = followsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r followsUpsertOne) Create(

	_follower FollowsWithPrismaFollowerSetParam,
	_following FollowsWithPrismaFollowingSetParam,

	optional ...FollowsSetParam,
) followsUpsertOne {
	var v followsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _follower.field())
	fields = append(fields, _following.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r followsUpsertOne) Update(
	params ...FollowsSetParam,
) followsUpsertOne {
	var v followsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r followsUpsertOne) Exec(ctx context.Context) (*FollowsModel, error) {
	var v FollowsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r followsUpsertOne) Tx() FollowsUniqueTxResult {
	v := newFollowsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type restaurantUpsertOne struct {
	query builder.Query
}

func (r restaurantUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r restaurantUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r restaurantUpsertOne) with()               {}
func (r restaurantUpsertOne) restaurantModel()    {}
func (r restaurantUpsertOne) restaurantRelation() {}

func (r restaurantActions) UpsertOne(
	params RestaurantEqualsUniqueWhereParam,
) restaurantUpsertOne {
	var v restaurantUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Restaurant"
	v.query.Outputs = restaurantOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r restaurantUpsertOne) Create(

	_name RestaurantWithPrismaNameSetParam,
	_address RestaurantWithPrismaAddressSetParam,
	_city RestaurantWithPrismaCitySetParam,
	_state RestaurantWithPrismaStateSetParam,
	_zipCode RestaurantWithPrismaZipCodeSetParam,

	optional ...RestaurantSetParam,
) restaurantUpsertOne {
	var v restaurantUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _address.field())
	fields = append(fields, _city.field())
	fields = append(fields, _state.field())
	fields = append(fields, _zipCode.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r restaurantUpsertOne) Update(
	params ...RestaurantSetParam,
) restaurantUpsertOne {
	var v restaurantUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r restaurantUpsertOne) Exec(ctx context.Context) (*RestaurantModel, error) {
	var v RestaurantModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r restaurantUpsertOne) Tx() RestaurantUniqueTxResult {
	v := newRestaurantUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}
